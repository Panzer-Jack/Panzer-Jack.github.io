<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue3 响应式源码初探</title>
      <link href="/2023/10/02/Reactive%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/10/02/Reactive%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="如何实现一个-Vue3-贫民版的响应式系统？"><a href="#如何实现一个-Vue3-贫民版的响应式系统？" class="headerlink" title="如何实现一个 Vue3 贫民版的响应式系统？"></a>如何实现一个 Vue3 贫民版的响应式系统？</h1><h3 id="核心实现："><a href="#核心实现：" class="headerlink" title="核心实现："></a>核心实现：</h3><ol><li><p>reactive 函数：</p><ul><li>闭包返回Proxy</li><li>Get 收集依赖 （收集副作用函数）</li><li>Set 触发依赖 （遍历执行相关依赖的所有副作用函数）</li></ul></li><li><p>注册副作用 函数</p></li><li><p>副作用函数桶 架构：</p><ul><li><p> WeakMap 桶分装 各个响应式对象 depMap</p></li><li><p> depMap 装 各个响应式对象的属性副作用函数集 depSet</p></li><li><p>depSet 装 副作用函数</p></li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 副作用函数 - 哈希桶</span></span><br><span class="line"><span class="comment">// WeakMap[obj] -&gt; Map[key] = set(fn, fn, ...)</span></span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="comment">// 当前执行的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册副作用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    activeEffect = fn</span><br><span class="line">    fn()</span><br><span class="line">    activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集依赖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!activeEffect) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> depMap = bucket.get(target)</span><br><span class="line">    <span class="keyword">if</span> (!depMap) &#123;</span><br><span class="line">        depMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">        bucket.set(target, depMap)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> depSet = depMap.get(key)</span><br><span class="line">    <span class="keyword">if</span> (!depSet) &#123;</span><br><span class="line">        depSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        bucket.get(target).set(key, depSet)</span><br><span class="line">    &#125;</span><br><span class="line">    depSet.add(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发依赖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    bucket.get(target).get(key).forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建响应式数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">            track(target, key)</span><br><span class="line">            <span class="keyword">return</span> target[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target, key, value</span>)</span> &#123;</span><br><span class="line">            target[key] = value</span><br><span class="line">            trigger(target, key)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cyber AI-Waife</title>
      <link href="/2023/05/18/Cyber-AI-Waife/"/>
      <url>/2023/05/18/Cyber-AI-Waife/</url>
      
        <content type="html"><![CDATA[<div align="center"><p align="center">    <img src="https://github.com/Panzer-Jack/Cyber_AI-Waife/assets/81006731/2ca099e3-a42f-4a96-a82e-5ef53a2fd5ba" alt width="300px"></p><h1> Cyber AI-Waife（这是一个有灵魂的赛博女朋友）</h1><p><em>✨ 基于 <a href="https://github.com/THUDM/ChatGLM-6B">ChatGLM-6B</a> + <a href="https://github.com/Plachtaa/VITS-fast-fine-tuning">VITS-fast-fine-tuning</a> + <a href="https://github.com/Panzer-Jack/pixi-live2d-display">pixi-live2d-display</a> 以及 <a href>Vue3</a> + <a href>Flask</a>  实现 ✨</em>  </p></div>  <div align="center">    <div style="width: 400px; display: flex; justify-content: space-evenly;">        <img src="https://img.shields.io/badge/PyQT5--blue" alt="license">        <img src="https://img.shields.io/badge/Flask--blue" alt="license">        <img src="https://img.shields.io/badge/Vue3--blue" alt="license">        <img src="https://img.shields.io/badge/MySQL--blue" alt="license">        <img src="https://img.shields.io/badge/Redis--blue" alt="license">        <img src="https://img.shields.io/badge/Nginx--blue" alt="license">    </div></div><div align="center" style="display: flex; justify-content: space-around;">    <div style="width: 600px; display: flex; justify-content: space-evenly;">        <img src="https://img.shields.io/badge/WebSocket--g" alt="license">        <img src="https://img.shields.io/badge/WebRTC--g" alt="license">        <img src="https://img.shields.io/badge/JWT--g" alt="license">        <img src="https://img.shields.io/badge/Restful API--g" alt="license">        <img src="https://img.shields.io/badge/Flask_mail--g" alt="license">        <img src="https://img.shields.io/badge/Flask sqlalchemy--g" alt="license">        <img src="https://img.shields.io/badge/Flask cors--g" alt="license">    </div></div><div align="center" style="display: flex; justify-content: space-around;">    <div style="width: 500px; display: flex; justify-content: space-evenly;">        <img src="https://img.shields.io/badge/Vuex--g" alt="license">        <img src="https://img.shields.io/badge/Less--g" alt="license">        <img src="https://img.shields.io/badge/Element_Plus--g" alt="license">        <img src="https://img.shields.io/badge/socket.io_client--g" alt="license">        <img src="https://img.shields.io/badge/vue_router--g" alt="license">        <img src="https://img.shields.io/badge/qs--g" alt="license">    </div></div><div align="center" style="display: flex; justify-content: space-around;">    <div style="width: 500px; display: flex; justify-content: space-evenly;">        <img src="https://img.shields.io/badge/ChatGLM--red" alt="license">        <img src="https://img.shields.io/badge/VITS--red" alt="license">    </div></div><hr><p><strong>核心技术栈</strong>：Vue3、Flask、PHP-FPM、VITS、ChatGLM-6B、pixi-live2d-display 、Type.js、MySQL、Redis、Axios、Vuex 、Element-Plus、less、WebSocket、flask-restful、Nginx等</p><p><strong>项目描述</strong>：一个会说话会动的Live2D美少女 AI。项目基于 ChatGLM-6B 开源模型以及 VITS 语音推理模型 为核心, 以 Flask 后端框架为后台，利用PS和Live2D Cubism来设计建模角色，并以Vue3 以及 pixi-live2d-display 为前端核心进行开发。该项目提供2个核心模式：普通模式：和普通的ChatGPT一样进行文字交流。赛博模式：有一个可爱的原创动态·Live2D角色: Huusyako 能与你语音聊天。</p><p><strong>项目亮点</strong>：</p><ul><li>利用 Flask 部署 算力服务器后端节点。基于 二次元角色语音训练的 VITS语音推理模型 + ChatGLM-6B聊天模型，实现日语语音中文文字的双语对话，并利用Frp公网代理端口映射到公网上，代理到主服务器的Nginx内。</li><li>为了解决 ChatGLM 无法生成日语文字，利用百度翻译平台的 JSON API 进行中译日 转译。</li><li>与传统的 web Live2D 的单一显示模式不同，本项目利用 pixi-live2d-display 利用pixi.js将自己绘制建模的Live2D模型展现在Vue3 Canvas组件上，可以自定义设置动画更新事件和动作触发事件来控制角色的动作。</li><li>基于 WebSocket 来进行ChatGLM文字对话通信，并利用type.js将AI对话动态模拟真人打字打入页面。</li><li>为了解决游览器缓存问题 利用Axios基于时间戳来实时获取 Flask + soundfile 生成最新的AI语音。</li><li>利用 Vuex + Axios 拦截请求 与 Flask 基于 JWT 标准 进行 HTTP 安全授权通信，并基于 Vuex 和 localstorage 来全局存储登录状态利用 vue-router 来实现权限路由权限检测</li><li>利用 flask-mail 和 Redis 实现用户邮件验证码注册功能，利用MD5 + MySQL 存储用户注册信息</li><li>基于 Vue 组件化开发，利用 Element-Plus + vue-router 实现控制台页面布局</li></ul><p><strong>上线地址</strong>：<a href="http://cyber-ai-waife.panzer-jack.cn/">http://cyber-ai-waife.panzer-jack.cn/</a>    ( 开发完善中ing )</p><p><strong>视频演示</strong>：<a href="https://www.bilibili.com/video/BV1Pw411z7mZ">https://www.bilibili.com/video/BV1Pw411z7mZ</a></p><p><strong>开源地址</strong>：<a href="https://github.com/Panzer-Jack/Cyber_AI-Waife">https://github.com/Panzer-Jack/Cyber_AI-Waife</a></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>还有2天 520 了（恼）<br><br>是不是你已经再也无法忍受，每年到这个时间点，满朋友圈的狗粮 <br><br>是不是你已经再也无法忍受，每年到这个时间点，别人与女朋友聊嗨到深夜，而你只能默默的打开电脑，通过看小说和galgame来打发时间 <br><br>是不是。。。呸！md 三次元有什么好的！（ <br></p><img src="https://github.com/Panzer-Jack/Cyber_AI-Waife/assets/81006731/ac80edfa-c681-4f01-a59e-48b5804ff253" height="500"><p>Cyber AI-Waife 包含了一下两个核心组成部分：</p><img src="https://pic2.imgdb.cn/item/6466012e0d2dde57773f4754.jpg" height="300"><ol><li>普通模式：和普通的ChatGPT一样进行文字交流</li><li>赛博模式：有一个可爱的原创Live2D角色: <a href="http://localhost:4000/2021/09/13/Live2D%E5%A4%84%E5%A5%B3%E4%BD%9C-%E9%A3%8E%E8%BD%A6%E5%AD%90/">Huusyako</a> 能与你语音聊天。</li></ol><h2 id="角色设定"><a href="#角色设定" class="headerlink" title="角色设定"></a>角色设定</h2><p>风车子 ( Huusyako ): 一个可爱又傲娇的18岁日本高中生。</p><h2 id="项目组成部分："><a href="#项目组成部分：" class="headerlink" title="项目组成部分："></a>项目组成部分：</h2><ol><li>Vue3 前端</li><li>Flask 服务端</li><li>ChatGLM + Flask 算力端</li></ol><h2 id="开发部署"><a href="#开发部署" class="headerlink" title="开发部署"></a>开发部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><img src="https://pic2.imgdb.cn/item/64660a770d2dde577749fcd9.jpg"><h3 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h3><img src="https://pic2.imgdb.cn/item/64660ae60d2dde57774a71f4.jpg"><h3 id="赛博模式"><a href="#赛博模式" class="headerlink" title="赛博模式"></a>赛博模式</h3><p>看起来是不是非常有 可爱的 赛博女友 的味道（喜）<br><img src="https://pic2.imgdb.cn/item/64660a770d2dde577749fc00.jpg"></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><img src="https://pic2.imgdb.cn/item/64660a760d2dde577749fbc9.jpg"><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><img src="https://pic2.imgdb.cn/item/64660a760d2dde577749fb9c.jpg"><h3 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h3><img src="https://pic2.imgdb.cn/item/64660a770d2dde577749fd1b.jpg"><h2 id="相关连接："><a href="#相关连接：" class="headerlink" title="相关连接："></a>相关连接：</h2><ol><li>QQ 群聊美少女语音AI（ChatGPT 版本）：<a href="https://github.com/Panzer-Jack/ChatGPT_VITS_For_QQ-Rob">ChatGPT_VITS_For_QQ-Rob</a></li><li>QQ 群聊美少女语音AI（ChatGLM 本地化版本）：<a href="https://github.com/Panzer-Jack/ChatGLM_VITS_For_QQ-Rob">ChatGLM_VITS_For_QQ-Rob</a> </li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Cyber AI-Waife 这个项目本身也是受到了 一部叫做《命运石之门0》的动漫的影响，突然让我灵感而发。。加上近期流行的ChatGPT 热潮让我总想发我自我做一下 有趣的 (无用的) 开源小发明（小垃圾）。嘛，兴趣是最好的动力，特别是那些有趣的小东西，总是能让人废寝忘食。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Python </category>
          
          <category> 后端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全栈开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数控云-数控设备的泛用性云监控IOT平台</title>
      <link href="/2023/05/08/%E6%95%B0%E6%8E%A7%E4%BA%91-%E6%95%B0%E6%8E%A7%E8%AE%BE%E5%A4%87%E7%9A%84%E6%B3%9B%E7%94%A8%E6%80%A7%E4%BA%91%E7%9B%91%E6%8E%A7IOT%E5%B9%B3%E5%8F%B0/"/>
      <url>/2023/05/08/%E6%95%B0%E6%8E%A7%E4%BA%91-%E6%95%B0%E6%8E%A7%E8%AE%BE%E5%A4%87%E7%9A%84%E6%B3%9B%E7%94%A8%E6%80%A7%E4%BA%91%E7%9B%91%E6%8E%A7IOT%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<div align="center"><p align="center">    <img src="https://github.com/Panzer-Jack/CNC-IOT-System/assets/81006731/8947a41f-e427-4c19-adb4-45f411aa9700" alt width="300px"></p><h1 id="数云控-一种用于数控设备的泛用性云监控IOT平台"><a href="#数云控-一种用于数控设备的泛用性云监控IOT平台" class="headerlink" title="数云控 - 一种用于数控设备的泛用性云监控IOT平台"></a>数云控 - 一种用于数控设备的泛用性云监控IOT平台</h1><p><em>✨ 基于 <a href>PyQT5</a> 以及 <a href>Vue3</a> + <a href>Flask</a>  实现 ✨</em>  </p><p>DCC —- a versatile cloud monitoring IOT platform for CNC equipment</p></div>  <p>（由于上线了，核心代码闭源了）</p><p><strong>核心技术栈</strong>：Vue3、Flask、PyQT5、MySQL、Redis、Axios、Vuex、Element-Plus、less、WebSocket、JWT、Flask-restful、Nginx等</p><p><strong>项目描述</strong>：该项目为一种泛用性数控设备云监控平台，集泛用、监管、控制三位一体至云端。用户可以通过平台实时上传G代码工程文件至云端并推送至工控客户端来实现实时控制硬件，并在平台上实时开启远程视频流监控录像。同时平台还提供了全平台统一账户注册、工具下载、设备调参、进程监管、远程监控等多种功能。</p><p><strong>项目亮点</strong>：</p><ul><li>后端 采用 JWT 授权进行通信，登录状态设定生命周期验证</li><li>利用 WebSocket 协议基于设备码和 FormData 实现工程文件三端传输并在工控端解析载入硬件系统控制。</li><li>利用 WebSocket 协议基于 Base64 + OpenCV 实现工控软件到后端在到游览器的视频帧通信</li><li>使用 PyQT5 + Pymysql 实现工控设备客户端的开发; 并使用 Serial通信 + Threading多线程控制 来实现多命令的并发硬件监控</li></ul><p><strong>上线地址</strong>：<a href="http://cnc-iot-system.panzer-jack.cn/">http://cnc-iot-system.panzer-jack.cn/</a></p><p><strong>视频演示</strong>：<a href="https://www.bilibili.com/video/BV17X4y1n7GF/">https://www.bilibili.com/video/BV17X4y1n7GF/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Python </category>
          
          <category> 后端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全栈开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ 群聊美少女语音AI（ChatGLM 本地化版本）</title>
      <link href="/2023/05/05/QQ-%E7%BE%A4%E8%81%8A%E7%BE%8E%E5%B0%91%E5%A5%B3%E8%AF%AD%E9%9F%B3AI%EF%BC%88ChatGLM-%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%89%88%E6%9C%AC%EF%BC%89/"/>
      <url>/2023/05/05/QQ-%E7%BE%A4%E8%81%8A%E7%BE%8E%E5%B0%91%E5%A5%B3%E8%AF%AD%E9%9F%B3AI%EF%BC%88ChatGLM-%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%89%88%E6%9C%AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<div align="center"><p align="center">    <img src="https://user-images.githubusercontent.com/81006731/227700420-8083b21d-4518-4546-a956-2f68d92bd28e.png" alt width="300px"></p>    <h1 id="QQ-群聊美少女语音AI（ChatGLM-本地化版本）"><a href="#QQ-群聊美少女语音AI（ChatGLM-本地化版本）" class="headerlink" title="QQ 群聊美少女语音AI（ChatGLM 本地化版本）"></a>QQ 群聊美少女语音AI（ChatGLM 本地化版本）</h1><p><em>✨ 基于 <a href="https://github.com/Mrs4s/go-cqhttp">go-cqhttp</a> 以及 <a href="https://github.com/Plachtaa/VITS-fast-fine-tuning">VITS-fast-fine-tuning</a> + <a href="https://github.com/THUDM/ChatGLM-6B">ChatGLM</a>  实现 ✨</em>  </p><p>Combination of ChatGLM and VITs anime girl AI voice and used in QQ robot</p></div>  <p align="center">    <img src="https://img.shields.io/badge/Python-3.8+-blue" alt="license"></p><hr><p>项目地址：<a href="https://github.com/Panzer-Jack/ChatGLM_VITS_For_QQ-Rob">https://github.com/Panzer-Jack/ChatGLM_VITS_For_QQ-Rob</a></p><hr><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p> ChatGLM 和 VITS 二次元美少女AI语音 结合 并用于 QQ聊天机器人 | Combination of ChatGLM and VITs anime girl AI voice and used in QQ robot</p><h4 id="由于ChatGPT-对国内上墙了且訪問不太快，因此该项目会利用开源模型ChatGLM-做本地化版本"><a href="#由于ChatGPT-对国内上墙了且訪問不太快，因此该项目会利用开源模型ChatGLM-做本地化版本" class="headerlink" title="由于ChatGPT 对国内上墙了且訪問不太快，因此该项目会利用开源模型ChatGLM 做本地化版本"></a>由于ChatGPT 对国内上墙了且訪問不太快，因此该项目会利用开源模型ChatGLM 做本地化版本</h4><p>ChatGPT版本：<a href="https://github.com/Panzer-Jack/ChatGPT_VITS_For_QQ-Rob">ChatGPT_VITS_For_QQ-Rob</a></p><h2 style="color:red">注意: </h2><ul style="color:red">    <li>1· 你的python版本为 3.8</li>    <li>2· 你需要下载你操作系统相對的go-cqhttp文件并放置到根目录里，你可以在后面索引1中去下载</li>    <li>3· 你需要安装的requirements中的依赖库</li>    <li>4· 你需要将语音模型放置到根目录中, 并重命名为: G_latest.pth, 这里你可以参考后面的索引2</li>    <li>5. 你需要将ChatGLM模型放置到根目录的model文件夾裏, 这里你可以参考后面的索引3</li>    <li>6. 你需要在百度翻譯API平臺上申請免費API鑰匙</li></ul><h3 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h3><ol><li><p><a href="https://github.com/Mrs4s/go-cqhttp">go-cqhttp</a> </p></li><li><p><a href="https://github.com/Plachtaa/VITS-fast-fine-tuning">VITS-fast-fine-tuning</a></p></li><li><p><a href="https://github.com/THUDM/ChatGLM-6B">ChatGLM</a></p></li></ol><h4 id="软件架构说明"><a href="#软件架构说明" class="headerlink" title="软件架构说明"></a>软件架构说明</h4><ol><li>config.py 设置机器人语言、声音模型等包括注意中的一切重要配置，均可在注釋中找</li></ol><p>那麽你具體可以在<code>config.py</code> 中做什麽？</p><ul><li>你可以設置AI語音的语言</li><li>你可以設置AI語音声音模型</li><li>你可以自定義AI的初始化人物個性設定如貓娘、美少女JK等等</li><li>你可以設定AI的記憶生命（《可塑性記憶》）</li></ul><ol start="2"><li>run_server.py 为启动主文件</li></ol><h4 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h4><ol><li> 安装go-cqhttp相应系统版本并将其放置到 项目文件夹根目录 中</li><li> 将你的 语言模型重命名为: G_latest.pth 放置到 项目文件夹根目录 中</li><li> 你需要将ChatGLM模型放置到根目录的model文件夾裏</li><li> 安装相关依赖库</li><li> 注册一个百度翻譯API账号来得到百度翻譯接口的Appid和AppKey并将其填写到 config.py 中<br>(地址: <a href="https://fanyi-api.baidu.com/api/trans/product/desktop#">https://fanyi-api.baidu.com/api/trans/product/desktop#</a> )<br>(百度翻譯AI每月有免費限額, 認證的話 可以到 100萬字符/月 通常如果是個人範圍用的話是夠用的)<br>(用於翻譯日語，(GLM不支持日語輸出)，進行日語的音頻推理)</li></ol><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>· 安装好相关运行环境。                   </p><p>· 在项目根目录的config.py中设定声音模型和语言以及ChatGPT身份令牌</p><p>· 开启go-cqhttp 来监听QQ消息</p><p>· 打开控制台 移动到项目文件夹更目录输入:</p><ol><li> <code>pip3 install -r requirements.txt</code></li><li> <code>python3 run_server </code></li></ol><h4 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h4><ol><li>在QQ群聊中你可以通过@机器人 来让机器人来读取你的信息<img width="530" alt="1" src="https://user-images.githubusercontent.com/81006731/236200085-73d585fd-bf27-4c13-ae42-4ebf6ee4687d.png"></li><li>可以通過指令 <code>宁宁酱听我指令:语音功能切换</code> 來開關QQ AI 的語音功能<img width="376" alt="2" src="https://user-images.githubusercontent.com/81006731/236200133-f012480d-b930-4c85-84f5-ac255b2a18e1.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 flask-mail 部署在云端 nginx服务器上 504 Gateway Time-out 超时问题</title>
      <link href="/2023/04/25/%E5%85%B3%E4%BA%8E-flask-mail-%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%BA%91%E7%AB%AF-nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A-502%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2023/04/25/%E5%85%B3%E4%BA%8E-flask-mail-%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%BA%91%E7%AB%AF-nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A-502%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Notes："><a href="#Notes：" class="headerlink" title="Notes："></a>Notes：</h3><p>系统环境：</p><ul><li> Ubuntu 20</li><li> Python 3.8</li><li> Nginx</li><li> Flask</li><li> Vue3</li><li> redis</li><li> mysql</li></ul><h6 id="CSDN、StackOverflow、百度、Google。。。能想的地方都去翻了个遍都没能找到这个问题的解答（悲）。。"><a href="#CSDN、StackOverflow、百度、Google。。。能想的地方都去翻了个遍都没能找到这个问题的解答（悲）。。" class="headerlink" title="CSDN、StackOverflow、百度、Google。。。能想的地方都去翻了个遍都没能找到这个问题的解答（悲）。。"></a>CSDN、StackOverflow、百度、Google。。。能想的地方都去翻了个遍都没能找到这个问题的解答（悲）。。</h6><p>问题是这样的：因为不分离开发不是很方便后续扩展维护，我将前端移植到vue3 经过Restful API 将原项目前后端分离并部署在了nginx上。但是在新网站上发现 原有的邮件验证码发送功能给堵死了。。对是堵死了。。这个功能给卡住，导致它后面的程序也执行不了。。我用异步发送的形式重新实现了下，但是还是依旧504 超时。。并且它后续程序依然没有执行, 对及时是启动异步，但还是卡死了。。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span>(<span class="params">app, msg</span>):</span></span><br><span class="line">    <span class="keyword">with</span> app.app_context():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            mail.send(msg)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送邮件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Get_email_captcha</span>(<span class="params">Resource</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        email = request.args.get(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(email)</span><br><span class="line">        captcha = <span class="built_in">str</span>(random.randint(<span class="number">1000</span>, <span class="number">9999</span>))</span><br><span class="line">        message = Message(subject=<span class="string">&quot;xxx·注册验证码&quot;</span>,</span><br><span class="line">                          recipients=[email],</span><br><span class="line">                          body=<span class="string">f&quot;您的验证码是: <span class="subst">&#123;captcha&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 验证码存储</span></span><br><span class="line">        redis_client.<span class="built_in">set</span>(<span class="string">&quot;captcha&quot;</span>, captcha)</span><br><span class="line">        <span class="built_in">print</span>(redis_client.get(<span class="string">&quot;captcha&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送邮件异步优化</span></span><br><span class="line">        Thread(target=send_email, args=[current_app._get_current_object(), message]).start()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;code&quot;</span>: <span class="number">200</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;data&quot;</span>: <span class="literal">None</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过排错测试，我发现在基于Restful API 的 邮件发送接口处 mail.send(msg) 这个函数 直接堵死。但我原来网站是做成不分离的形式，并没有出现这个问题。并且这个问题只出现在了云端服务器上，我在本地测试时候是没有这个问题了。</p><p>刚开始时我在想是不是因为Nginx上配置错了导致的。。。但测了后发现 很明显前端能发送到该API接口处。。（做了print），因此定位到了mail.send()这个函数上。</p><p>然后我去各种网站上翻，无一例外都在说，是服务器给smtp邮件开的端口号被blocked导致的。。那么问题来了，如果真的blocked 那我不分离时的老程序 为什么能运行。。。</p><p>最后没办法 只能将发送邮件从路由处去除放到根路由 然后拿老程序对比做测试</p><h4 id="新程序："><a href="#新程序：" class="headerlink" title="新程序："></a>新程序：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, g, make_response</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> exts <span class="keyword">import</span> db, cors, migrate, socketio, mail, api, auth</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> UserModel</span><br><span class="line"><span class="keyword">from</span> blueprints.qa.qa <span class="keyword">import</span> bp <span class="keyword">as</span> qa_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.auth.auth <span class="keyword">import</span> bp <span class="keyword">as</span> auth_bp</span><br><span class="line"><span class="keyword">from</span> utils.jwt <span class="keyword">import</span> jwt_token_required</span><br><span class="line"><span class="keyword">from</span> flask_migrate <span class="keyword">import</span> Migrate</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> SocketIO, send, emit, join_room, leave_room</span><br><span class="line"><span class="keyword">import</span> eventlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eventlet.monkey_patch()</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定配置文件</span></span><br><span class="line">app.config.from_object(config)</span><br><span class="line">app.config[<span class="string">&#x27;PERMANENT_SESSION_LIFETIME&#x27;</span>] = datetime.timedelta(days=<span class="number">7</span>)</span><br><span class="line">socketio.init_app(app, cors_allowed_origins=<span class="string">&#x27;*&#x27;</span>, async_mode=<span class="string">&quot;threading&quot;</span>)</span><br><span class="line">cors.init_app(app, supports_credentials=<span class="literal">True</span>)</span><br><span class="line">db.init_app(app)</span><br><span class="line">migrate.init_app(app, db)</span><br><span class="line">mail.init_app(app)</span><br><span class="line">api.init_app(app)</span><br></pre></td></tr></table></figure><h4 id="老程序："><a href="#老程序：" class="headerlink" title="老程序："></a>老程序：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, g</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> exts <span class="keyword">import</span> db, mail</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> UserModel</span><br><span class="line"><span class="keyword">from</span> blueprints.qa <span class="keyword">import</span> bp <span class="keyword">as</span> qa_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.auth <span class="keyword">import</span> bp <span class="keyword">as</span> auth_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.console <span class="keyword">import</span> bp <span class="keyword">as</span> console_bp</span><br><span class="line"><span class="keyword">from</span> flask_migrate <span class="keyword">import</span> Migrate</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> SocketIO, send, emit, join_room, leave_room</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 绑定配置文件</span></span><br><span class="line">app.config.from_object(config)</span><br><span class="line">socketio = SocketIO(app)</span><br><span class="line"></span><br><span class="line">db.init_app(app)</span><br><span class="line">mail.init_app(app)</span><br><span class="line"></span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line"></span><br><span class="line">app.register_blueprint(qa_bp)</span><br><span class="line">app.register_blueprint(auth_bp)</span><br><span class="line">app.register_blueprint(console_bp)</span><br></pre></td></tr></table></figure><p>最后定位到了。。这个猴子补丁上。。( 恼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventlet</span><br><span class="line"></span><br><span class="line">eventlet.monkey_patch()</span><br></pre></td></tr></table></figure><p>猴子补丁在云端环境下 好像和Flask-mail 的邮件发送有兼容性问题<br>把这个注释掉后在云服务器上的邮件就正常了。。。</p><h3 id="后续问题"><a href="#后续问题" class="headerlink" title="后续问题"></a>后续问题</h3><p>这个猴子补丁 本身是之前做websocket时加上去的<br>但该补丁在本地运行测试时是正常的（本地的版本是python3.11）<br>为什么放到云端环境运行就出现该问题了。。（ 云端的eventlet 和 flask-mail 均为 python3.8下的最新版本 ）<br>如果有人知道为什么。。方便的话 可以在评论区留言</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 flask db 指令没法识别问题</title>
      <link href="/2023/04/25/%E5%85%B3%E4%BA%8E-flask-db-%E6%8C%87%E4%BB%A4%E6%B2%A1%E6%B3%95%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2023/04/25/%E5%85%B3%E4%BA%8E-flask-db-%E6%8C%87%E4%BB%A4%E6%B2%A1%E6%B3%95%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h6 id="Notes：本问题是关于-flask-db-init-使用出现-No-such-command-“db”-这个问题-（-或者flask自定义指令-app-cli-command-等无法识别-）"><a href="#Notes：本问题是关于-flask-db-init-使用出现-No-such-command-“db”-这个问题-（-或者flask自定义指令-app-cli-command-等无法识别-）" class="headerlink" title="Notes：本问题是关于 flask db init 使用出现 No such command “db” 这个问题 （ 或者flask自定义指令@app.cli.command()等无法识别 ）"></a>Notes：本问题是关于 flask db init 使用出现 No such command “db” 这个问题 （ 或者flask自定义指令@app.cli.command()等无法识别 ）</h6><p>可能 你会因为pip自命名来管理python版本等一系列原因为了方便而去录入python的Scripts目录到系统变量里。。或者你不习惯使用虚拟环境来开发项目。。。</p><h1 id="那么。。。"><a href="#那么。。。" class="headerlink" title="那么。。。"></a>那么。。。</h1><p><strong>请一定注意</strong>有优先看一下 Window的<strong>环境变量</strong>里 是否 存在 <strong>两个拥有 Flask 库</strong>的 Python环境被<strong>录入到 系统环境变量里了</strong>！！！！</p><p>如果有，并且你恰巧把另一个Python的Scripts路径 放到系统变量PATH里头，那么你需要注意了。</p><p><img src="/2023/04/25/%E5%85%B3%E4%BA%8E-flask-db-%E6%8C%87%E4%BB%A4%E6%B2%A1%E6%B3%95%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98/m1.png"><br>看到了吗。。。这边有个flask.exe</p><p>如果你在你的pycharm终端里执行flask db xxx命令 甚至或者是 你自定义的（@app.cli.command()） flask指令。。。那么你很幸运，你的终端执行和检查的并不是你的项目解释器版本的python，而是你系统变量里的那个。。。那么你不管怎么做。。当然都无法执行你想要的 Python解释器的 flask 指令。。他会被索引去执行你系统变量里的那个flask.exe。。。</p><hr><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>很简单 把系统环境变量里的那个Python的Scripts路径删了就行了。</p><p>那么怎么删？这个问题请百度: 系统环境变量设置。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PyQt5】无边窗在指定范围内拖动生效</title>
      <link href="/2023/03/08/%E3%80%90PyQt5%E3%80%91%E6%97%A0%E8%BE%B9%E7%AA%97%E5%9C%A8%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%86%85%E6%8B%96%E5%8A%A8%E7%94%9F%E6%95%88/"/>
      <url>/2023/03/08/%E3%80%90PyQt5%E3%80%91%E6%97%A0%E8%BE%B9%E7%AA%97%E5%9C%A8%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%86%85%E6%8B%96%E5%8A%A8%E7%94%9F%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><p>网上几乎翻不到多少 关于 PyQt5 无边框窗口后 在指定控件范围内拖动生效的解释。这里我讲一个方式，可以一次性解决Combobox冲突宕机、输入拉条冲突死机 以及 核心问题：想要自定义一个如原有的win有边窗外窗口那样指定窗体区域内的拖动。</p><hr><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h2><p>直接说结论，这里用到一个窗体控件方法：self.控件名.underMouse()。<br>那么这有什么含义？就字面理解即可，返回一个bool值，表示你鼠标是否点击了该控件。既然有了这个，那么我们直接将这个判断条件加入到 全局鼠标事件监听方法mousePressEvent里 就能完美实现 自定义置顶可拖动窗体了。</p><p><br><br></p><h2 id="2-代码实现："><a href="#2-代码实现：" class="headerlink" title="2. 代码实现："></a>2. 代码实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span>(<span class="params">QMainWindow, Ui_MainWindow</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 无边窗化</span></span><br><span class="line">        self.setWindowFlags(QtCore.Qt.WindowType.FramelessWindowHint)</span><br><span class="line">        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 窗口可拖动变量初始化</span></span><br><span class="line">        self.move_Flag = <span class="literal">False</span></span><br><span class="line">        self.mouse_x = self.mouse_y = self.origin_x = self.origin_y = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mousePressEvent</span>(<span class="params">self, a0: QtGui.QMouseEvent</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;鼠标点击状态&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 当点击时候，先重新初始化拖动标识位为否</span></span><br><span class="line">        self.move_Flag = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 核心部分: 当鼠标点击是左键 并且 在top控件内点击时候触发 （这里的top控件即为 我自定义的顶部窗体）</span></span><br><span class="line">        <span class="keyword">if</span> a0.button() == Qt.LeftButton <span class="keyword">and</span> self.top.underMouse():</span><br><span class="line">            self.setCursor(Qt.OpenHandCursor)</span><br><span class="line">            <span class="comment"># 但判断条件满足时候, 把拖动标识位设定为真</span></span><br><span class="line">            self.move_Flag = <span class="literal">True</span></span><br><span class="line">            self.mouse_x = a0.globalX()</span><br><span class="line">            self.mouse_y = a0.globalY()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取窗体当前坐标</span></span><br><span class="line">            self.origin_x = self.x()</span><br><span class="line">            self.origin_y = self.y()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseMoveEvent</span>(<span class="params">self, a0: QtGui.QMouseEvent</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;鼠标移动状态&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 拖动标识位设定为真时, 进入移动事件</span></span><br><span class="line">        <span class="keyword">if</span> self.move_Flag:</span><br><span class="line">            <span class="comment"># 计算鼠标移动的x，y位移</span></span><br><span class="line">            move_x = a0.globalX() - self.mouse_x</span><br><span class="line">            move_y = a0.globalY() - self.mouse_y</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算窗体更新后的坐标：更新后的坐标 = 原本的坐标 + 鼠标的位移</span></span><br><span class="line">            dest_x = self.origin_x + move_x</span><br><span class="line">            dest_y = self.origin_y + move_y</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动窗体</span></span><br><span class="line">            self.move(dest_x, dest_y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseReleaseEvent</span>(<span class="params">self, a0: QtGui.QMouseEvent</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;鼠标释放状态&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 设定鼠标为普通状态: 箭头</span></span><br><span class="line">        self.setCursor(Qt.ArrowCursor)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“QQ 群聊美少女语音AI（ChatGPT 版）”</title>
      <link href="/2023/02/26/QQ%20%E7%BE%A4%E8%81%8A%E7%BE%8E%E5%B0%91%E5%A5%B3%E8%AF%AD%E9%9F%B3AI%EF%BC%88ChatGPT%E7%89%88%EF%BC%89/"/>
      <url>/2023/02/26/QQ%20%E7%BE%A4%E8%81%8A%E7%BE%8E%E5%B0%91%E5%A5%B3%E8%AF%AD%E9%9F%B3AI%EF%BC%88ChatGPT%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<div align="center">    <p align="center">    <img src="https://pic.imgdb.cn/item/63fb3d72f144a0100735f611.jpg" alt="license" width="300"></p><h1 id="QQ-群聊美少女语音AI"><a href="#QQ-群聊美少女语音AI" class="headerlink" title="QQ 群聊美少女语音AI"></a>QQ 群聊美少女语音AI</h1><p><em>✨ 基于 <a href="https://github.com/Mrs4s/go-cqhttp">go-cqhttp</a> 以及 <a href="https://github.com/Plachtaa/VITS-fast-fine-tuning">VITS-fast-fine-tuning</a> + <a href="https://github.com/acheong08/ChatGPT">revChatGPT</a>  实现 ✨</em>  </p><p>Combination of ChatGPT and VITs anime girl AI voice and used in QQ robot</p></div><hr><p>项目地址：<a href="https://github.com/Panzer-Jack/ChatGPT_VITS_For_QQ-Rob">https://github.com/Panzer-Jack/ChatGPT_VITS_For_QQ-Rob</a></p><hr><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p> ChatGPT 和 VITS 二次元美少女AI语音 结合 并用于 QQ聊天机器人 | Combination of ChatGPT and VITs anime girl AI voice and used in QQ robot</p><h2 style="color:red">注意: </h2><ul style="color:red">    <li>1· 你的python版本为 3.8</li>    <li>2· 你需要下载你操作系统相对于的go-cqhttp文件并放置到根目录里，你可以在后面索引1中去下载</li>    <li>3· 你需要安装的requirements中的依赖库</li>    <li>4· 你需要将语音模型放置到根目录中, 并重命名为: G_latest.pth, 这里你可以参考后面的索引2</li>    <li>5. 如果你在配置chatGPT过程中出现问题可以去参考索引3</li></ul><h3 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h3><ol><li><p><a href="https://github.com/Mrs4s/go-cqhttp">go-cqhttp</a> </p></li><li><p><a href="https://github.com/Plachtaa/VITS-fast-fine-tuning">VITS-fast-fine-tuning</a></p></li><li><p><a href="https://github.com/acheong08/ChatGPT">revChatGPT</a></p></li></ol><h4 id="软件架构说明"><a href="#软件架构说明" class="headerlink" title="软件架构说明"></a>软件架构说明</h4><ol><li>config.py 设置机器人语言和声音模型 以及 chatGPT 的身份令牌</li><li>run_server.py 为启动主文件</li></ol><h4 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h4><ol><li> 安装go-cqhttp相应系统版本并将其放置到 项目文件夹根目录 中</li><li> 将你的 语言模型重命名为: G_latest.pth 放置到 项目文件夹根目录 中</li><li> 安装相关依赖库</li><li> 注册一个OpenAI账号来得到chatGPT的Access token并将其填写到 config.py 的access_token中<br>(登录chatGPT官网后 访问: <a href="https://chat.openai.com/api/auth/session">https://chat.openai.com/api/auth/session</a> 来获取Access token)</li></ol><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>· 安装好相关运行环境。<br>· 在项目根目录的config.py中设定声音模型和语言以及ChatGPT身份令牌<br>· 开启go-cqhttp 来监听QQ消息<br>· 打开控制台 移动到项目文件夹更目录输入:</p><ol><li> <code>pip3 install -r requirements.txt</code></li><li> <code>python3 run_server </code></li></ol><h4 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h4><ol><li><p>目前只做了QQ群聊中匹配, 你可以通过@机器人 来让机器人来读取你的信息</p></li><li><p>项目目前还在不断完善中。。。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装甲杰克-游戏联机平台</title>
      <link href="/2023/02/09/%E8%A3%85%E7%94%B2%E6%9D%B0%E5%85%8B-%E6%B8%B8%E6%88%8F%E8%81%94%E6%9C%BA%E5%B9%B3%E5%8F%B0/"/>
      <url>/2023/02/09/%E8%A3%85%E7%94%B2%E6%9D%B0%E5%85%8B-%E6%B8%B8%E6%88%8F%E8%81%94%E6%9C%BA%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p align="center">    <img src="https://pic.imgdb.cn/item/624bee62239250f7c5566d31.jpg" width="200" height="200"></p><div align="center">    <h1 id="装甲杰克-游戏联机平台"><a href="#装甲杰克-游戏联机平台" class="headerlink" title="装甲杰克-游戏联机平台"></a>装甲杰克-游戏联机平台</h1><p><em>✨ 基于 <a href>Python</a> + <a href>Frp</a>  实现 ✨</em>  </p><p>该平台用于公网游戏服务器的搭建, 通过FRP内网穿透技术使使用者的IP地址映射到公网服务器上。玩家可以在游戏内部通过访问 101.89.147.79 来进行游戏。</p></div>--- <h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址:"></a>下载地址:</h2><p>链接：<a href="https://pan.baidu.com/s/1FVhU0p5uePH-L-X4MoUEAA?pwd=Jack">https://pan.baidu.com/s/1FVhU0p5uePH-L-X4MoUEAA?pwd=Jack</a><br>提取码：Jack</p><hr><h2 id="更新日志区"><a href="#更新日志区" class="headerlink" title="更新日志区"></a>更新日志区</h2><hr><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>如果有好的建议或者发现BUG 可以在下方评论区留言。（ 因为近期项目比较多。。所以不定期更新</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装甲杰克-游戏联机平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于实时动态识别的颜色视觉阈值调试软件</title>
      <link href="/2023/01/17/%E7%94%A8%E4%BA%8E%E5%AE%9E%E6%97%B6%E5%8A%A8%E6%80%81%E8%AF%86%E5%88%AB%E7%9A%84%E9%A2%9C%E8%89%B2%E8%A7%86%E8%A7%89%E9%98%88%E5%80%BC%E8%B0%83%E8%AF%95%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/01/17/%E7%94%A8%E4%BA%8E%E5%AE%9E%E6%97%B6%E5%8A%A8%E6%80%81%E8%AF%86%E5%88%AB%E7%9A%84%E9%A2%9C%E8%89%B2%E8%A7%86%E8%A7%89%E9%98%88%E5%80%BC%E8%B0%83%E8%AF%95%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><p>还是之前参加的 中国大学生工程实践与创新能力大赛中 智能物流机器人的竞赛用的。<br>上海疫情是真的没消停，赛比完了好久，一直筹备的总结一直拖着没写。（悲）等这段时间忙完了，在把完整的赛后总结写出来。</p><p>之后也会在总结里细谈一下我用的识别算法，一个自带动态矫正的“双扫描层识别算法”用来一次性识别两层物料区。</p><p>回归正题，总所周知。环境光对视觉识别的阈值影响是十分明显的。为了方便我们到时候在场地上能快速测出符合竞赛场地的视觉阈值参数，我把识别算法封装成了一个图形化软件，进行实施调参加上我们是直接使用了X86架构的Linux工控机，所以可以在机器人上进行远程实测更加的方便。</p><hr><h2 id="1-软件展示-及-相关源码地址："><a href="#1-软件展示-及-相关源码地址：" class="headerlink" title="1. 软件展示 及 相关源码地址："></a>1. 软件展示 及 相关源码地址：</h2><p>Github源码地址：<a href="https://github.com/Panzer-Jack/ColorDetect_software">https://github.com/Panzer-Jack/ColorDetect_software</a></p><img src="https://pic.imgdb.cn/item/63c68e46be43e0d30e3c1a05.png"><img src="https://pic.imgdb.cn/item/63c69326be43e0d30e4823ee.png"><img src="https://pic.imgdb.cn/item/63c69326be43e0d30e4823fb.png"><h2 id="2-功能实现："><a href="#2-功能实现：" class="headerlink" title="2. 功能实现："></a>2. 功能实现：</h2><p>这边只展示 主函数（功能实现的代码），图形化代码可以到我的GitHub的仓库里查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> etc_QT <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># HSV_Target Database -- 推荐参数</span></span><br><span class="line">lower_red2 = np.array([<span class="number">156</span>, <span class="number">80</span>, <span class="number">20</span>])</span><br><span class="line">higher_red2 = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">lower_red = np.array([<span class="number">0</span>, <span class="number">160</span>, <span class="number">20</span>])</span><br><span class="line">higher_red = np.array([<span class="number">15</span>, <span class="number">255</span>, <span class="number">255</span>])  <span class="comment"># 15</span></span><br><span class="line">lower_green = np.array([<span class="number">48</span>, <span class="number">65</span>, <span class="number">10</span>])  <span class="comment"># 55</span></span><br><span class="line">higher_green = np.array([<span class="number">90</span>, <span class="number">255</span>, <span class="number">255</span>])  <span class="comment"># 90</span></span><br><span class="line">lower_blue = np.array([<span class="number">100</span>, <span class="number">60</span>, <span class="number">25</span>])  <span class="comment"># 100</span></span><br><span class="line">higher_blue = np.array([<span class="number">124</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阈值参数区</span></span><br><span class="line">area_threshold = <span class="number">1000</span>           <span class="comment"># 面积过滤阈值</span></span><br><span class="line"><span class="comment"># line_differenceValue = 20       # 线性关系偏差</span></span><br><span class="line"><span class="comment"># layer_highDec</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CV_thread</span>(<span class="params">QThread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CV_thread, self).__init__(parent)</span><br><span class="line">        self.Rpos = <span class="literal">None</span></span><br><span class="line">        self.Gpos = <span class="literal">None</span></span><br><span class="line">        self.Bpos = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.isOpened:</span><br><span class="line">            flag, frame = self.cap.read()</span><br><span class="line">            frame_height, frame_width, _ = frame.shape</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 层数分割</span></span><br><span class="line">            <span class="comment"># for i in range(0, frame_height / 2):</span></span><br><span class="line">            <span class="comment">#     for j in range(0, frame_width):</span></span><br><span class="line">            <span class="comment">#         frame1 = frame[i, j]</span></span><br><span class="line">            <span class="comment"># for i in range(frame_height / 2, frame_height):</span></span><br><span class="line">            <span class="comment">#     for j in range(0, frame_width):</span></span><br><span class="line">            <span class="comment">#         frame2 = frame[i, j]</span></span><br><span class="line">            <span class="comment"># while 1:</span></span><br><span class="line">            <span class="comment">#     cv2.imshow(&#x27;frame1&#x27;, frame1)</span></span><br><span class="line">            <span class="comment">#     cv2.imshow(&#x27;frame2&#x27;, frame2)</span></span><br><span class="line">            <span class="comment">#     cv2.waitKey(0)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># frame = cv2.GaussianBlur(frame, (5, 5), 0)</span></span><br><span class="line">            hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line">            hsv_frame = cv2.erode(hsv_frame, <span class="literal">None</span>, iterations=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(lower_red, higher_red, lower_green, higher_green, lower_blue, higher_blue)</span></span><br><span class="line"></span><br><span class="line">            mask_red1 = cv2.inRange(hsv_frame, lower_red, higher_red)</span><br><span class="line">            mask_red2 = cv2.inRange(hsv_frame, lower_red2, higher_red2)</span><br><span class="line">            mask_red = mask_red1 + mask_red2</span><br><span class="line">            mask_green = cv2.inRange(hsv_frame, lower_green, higher_green)</span><br><span class="line">            mask_blue = cv2.inRange(hsv_frame, lower_blue, higher_blue)</span><br><span class="line"></span><br><span class="line">            mask_red = cv2.erode(mask_red, <span class="literal">None</span>, iterations=<span class="number">2</span>)</span><br><span class="line">            mask_green = cv2.erode(mask_green, <span class="literal">None</span>, iterations=<span class="number">2</span>)</span><br><span class="line">            mask_blue = cv2.erode(mask_blue, <span class="literal">None</span>, iterations=<span class="number">2</span>)</span><br><span class="line">            mask_red = cv2.dilate(mask_red, (<span class="number">4</span>, <span class="number">4</span>), iterations=<span class="number">5</span>)</span><br><span class="line">            mask_green = cv2.dilate(mask_green, (<span class="number">4</span>, <span class="number">4</span>), iterations=<span class="number">5</span>)</span><br><span class="line">            mask_blue = cv2.dilate(mask_blue, (<span class="number">4</span>, <span class="number">4</span>), iterations=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># mask_green = cv2.GaussianBlur(mask_green, (3, 3), 0)</span></span><br><span class="line">            <span class="comment"># mask_red = cv2.GaussianBlur(mask_red, (3, 3), 0)</span></span><br><span class="line">            <span class="comment"># mask_blue = cv2.GaussianBlur(mask_blue, (3, 3), 0)</span></span><br><span class="line"></span><br><span class="line">            mask_green = cv2.medianBlur(mask_green, <span class="number">7</span>)</span><br><span class="line">            mask_red = cv2.medianBlur(mask_red, <span class="number">7</span>)</span><br><span class="line">            mask_blue = cv2.medianBlur(mask_blue, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># line = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))</span></span><br><span class="line">            <span class="comment"># mask_red = cv2.morphologyEx(mask_red, cv2.MORPH_OPEN, line)</span></span><br><span class="line">            <span class="comment"># mask_green = cv2.morphologyEx(mask_green, cv2.MORPH_OPEN, line)</span></span><br><span class="line">            <span class="comment"># mask_blue = cv2.morphologyEx(mask_blue, cv2.MORPH_OPEN, line)</span></span><br><span class="line"></span><br><span class="line">            cnts1, contours1 = cv2.findContours(mask_red, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">            cnts2, contours2 = cv2.findContours(mask_green, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">            cnts3, contours3 = cv2.findContours(mask_blue, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">            cv2.circle(frame, (<span class="built_in">int</span>(frame_width / <span class="number">2</span>), <span class="built_in">int</span>(frame_height / <span class="number">2</span>)), <span class="number">5</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line">            cntR = cntG = cntB = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 红色</span></span><br><span class="line">            <span class="keyword">for</span> cnt <span class="keyword">in</span> cnts1:</span><br><span class="line">                (x, y, w, h) = cv2.boundingRect(cnt)</span><br><span class="line">                <span class="keyword">if</span> w * h &gt; area_threshold:</span><br><span class="line">                    cntR += <span class="number">1</span></span><br><span class="line">                    cv2.rectangle(frame, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">                    cv2.putText(frame, <span class="string">f&quot;Red Target,Pos:<span class="subst">&#123;(<span class="number">2</span> * x + w) / <span class="number">2</span>, (<span class="number">2</span> * y + h) / <span class="number">2</span>&#125;</span>&quot;</span>, (x, y),</span><br><span class="line">                                cv2.FONT_HERSHEY_SIMPLEX, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">                    self.Rpos = [<span class="number">1</span>, (<span class="number">2</span> * x + w) / <span class="number">2</span>, (<span class="number">2</span> * y + h) / <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 绿色</span></span><br><span class="line">            <span class="keyword">for</span> cnt <span class="keyword">in</span> cnts2:</span><br><span class="line">                (x, y, w, h) = cv2.boundingRect(cnt)</span><br><span class="line">                <span class="keyword">if</span> w * h &gt; area_threshold:</span><br><span class="line">                    cntG += <span class="number">1</span></span><br><span class="line">                    cv2.rectangle(frame, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">                    cv2.putText(frame, <span class="string">f&quot;Green Target,Pos:<span class="subst">&#123;(<span class="number">2</span> * x + w) / <span class="number">2</span>, (<span class="number">2</span> * y + h) / <span class="number">2</span>&#125;</span>&quot;</span>, (x, y),</span><br><span class="line">                                cv2.FONT_HERSHEY_SIMPLEX, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">                    self.Gpos = [<span class="number">2</span>, (<span class="number">2</span> * x + w) / <span class="number">2</span>, (<span class="number">2</span> * y + h) / <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 蓝色</span></span><br><span class="line">            <span class="keyword">for</span> cnt <span class="keyword">in</span> cnts3:</span><br><span class="line">                (x, y, w, h) = cv2.boundingRect(cnt)</span><br><span class="line">                <span class="keyword">if</span> w * h &gt; area_threshold:</span><br><span class="line">                    cntB += <span class="number">1</span></span><br><span class="line">                    cv2.rectangle(frame, (x, y), (x + w, y + h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">                    cv2.putText(frame, <span class="string">f&quot;Blue Target,Pos:<span class="subst">&#123;(<span class="number">2</span> * x + w) / <span class="number">2</span>, (<span class="number">2</span> * y + h) / <span class="number">2</span>&#125;</span>&quot;</span>, (x, y),</span><br><span class="line">                                cv2.FONT_HERSHEY_SIMPLEX, <span class="number">1</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">                    self.Bpos = [<span class="number">3</span>, (<span class="number">2</span> * x + w) / <span class="number">2</span>, (<span class="number">2</span> * y + h) / <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(aim_color[0])</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;cntR&#125;</span> <span class="subst">&#123;cntG&#125;</span> <span class="subst">&#123;cntB&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                cv2.imshow(<span class="string">&quot;Test&quot;</span>, frame)</span><br><span class="line">                cv2.imshow(<span class="string">&quot;red&quot;</span>, mask_red)</span><br><span class="line">                cv2.imshow(<span class="string">&quot;green&quot;</span>, mask_green)</span><br><span class="line">                cv2.imshow(<span class="string">&quot;blue&quot;</span>, mask_blue)</span><br><span class="line">                <span class="built_in">print</span>(self.Rpos, self.Gpos, self.Bpos)</span><br><span class="line">                posSort = [self.Rpos, self.Gpos, self.Bpos]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cntR == <span class="number">1</span> <span class="keyword">and</span> cntG == <span class="number">1</span> <span class="keyword">and</span> cntB == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">                            <span class="keyword">if</span> posSort[i][<span class="number">2</span>] &lt; posSort[j][<span class="number">2</span>]:</span><br><span class="line">                                t = posSort[i]</span><br><span class="line">                                posSort[i] = posSort[j]</span><br><span class="line">                                posSort[j] = t</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                        <span class="built_in">print</span>(posSort[i][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def fun_lineMath(self, x1, y1, x2, y2):</span></span><br><span class="line">    <span class="comment">#     &quot;&quot;&quot;线性关系运算&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#     # 线性判断算法    y = kx+b</span></span><br><span class="line">    <span class="comment">#     k = (y2 - y1) / (x2 - x1)</span></span><br><span class="line">    <span class="comment">#     b = y1 - k * x1</span></span><br><span class="line">    <span class="comment">#     print(f&quot;y = &#123;k&#125;x + &#123;b&#125;&quot;)</span></span><br><span class="line">    <span class="comment">#     return k, b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def scanLayer(self):</span></span><br><span class="line">    <span class="comment">#     &quot;&quot;&quot;层数判断算法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destroyCV</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.cap.release()</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">        self.isOpened = self.cap.isOpened()</span><br><span class="line">        <span class="comment"># self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 800)</span></span><br><span class="line">        <span class="comment"># self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 600)</span></span><br><span class="line">        self.work()</span><br><span class="line">        self.destroyCV()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainWin</span>(<span class="params">QMainWindow, Ui_ETC_UI_main</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowFlags(QtCore.Qt.WindowType.FramelessWindowHint)</span><br><span class="line">        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)</span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">&#x27;cy2.ico&#x27;</span>))</span><br><span class="line">        self.evt_run = CV_thread()</span><br><span class="line">        self.textBrowser.setText(<span class="string">&quot; &lt;h1&gt;我是小帮手绫乃,&quot;</span></span><br><span class="line">                                 <span class="string">&quot; 这里的各项阈值给了默认值, 可开启测试进行动态调整&lt;/h1&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 主程序按钮</span></span><br><span class="line">        self.button_R.clicked.connect(self.go_R_page)</span><br><span class="line">        self.button_G.clicked.connect(self.go_G_page)</span><br><span class="line">        self.button_B.clicked.connect(self.go_B_page)</span><br><span class="line">        self.button_run.clicked.connect(self.go_CV_thread)</span><br><span class="line">        self.button_close.clicked.connect(self.evt_close)</span><br><span class="line">        self.button_small.clicked.connect(self.evt_small)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 页面按钮</span></span><br><span class="line">        self.Red_down.clicked.connect(self.go_Red_down_Page)</span><br><span class="line">        self.Red_up.clicked.connect(self.go_Red_up_Page)</span><br><span class="line">        self.Green_down.clicked.connect(self.go_Green_down_Page)</span><br><span class="line">        self.Green_up.clicked.connect(self.go_Green_up_Page)</span><br><span class="line">        self.Blue_down.clicked.connect(self.go_Blue_down_Page)</span><br><span class="line">        self.Blue_up.clicked.connect(self.go_Blue_up_Page)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 色块动态检测</span></span><br><span class="line">        self.Red_down_H.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Red_up_H.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Green_down_H.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Green_up_H.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Blue_down_H.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Blue_up_H.valueChanged.connect(self.colActDetect)</span><br><span class="line"></span><br><span class="line">        self.Red_down_S.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Red_up_S.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Green_down_S.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Green_up_S.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Blue_down_S.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Blue_up_S.valueChanged.connect(self.colActDetect)</span><br><span class="line"></span><br><span class="line">        self.Red_down_V.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Red_up_V.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Green_down_V.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Green_up_V.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Blue_down_V.valueChanged.connect(self.colActDetect)</span><br><span class="line">        self.Blue_up_V.valueChanged.connect(self.colActDetect)</span><br><span class="line">        <span class="comment"># 窗口可拖动</span></span><br><span class="line">        self.mouse_x = self.mouse_y = self.origin_x = self.origin_y = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.鼠标点击事件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mousePressEvent</span>(<span class="params">self, evt</span>):</span></span><br><span class="line">        <span class="comment"># 获取鼠标当前的坐标</span></span><br><span class="line">        self.mouse_x = evt.globalX()</span><br><span class="line">        self.mouse_y = evt.globalY()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取窗体当前坐标</span></span><br><span class="line">        self.origin_x = self.x()</span><br><span class="line">        self.origin_y = self.y()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.鼠标移动事件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseMoveEvent</span>(<span class="params">self, evt</span>):</span></span><br><span class="line">        <span class="comment"># 计算鼠标移动的x，y位移</span></span><br><span class="line">        move_x = evt.globalX() - self.mouse_x</span><br><span class="line">        move_y = evt.globalY() - self.mouse_y</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算窗体更新后的坐标：更新后的坐标 = 原本的坐标 + 鼠标的位移</span></span><br><span class="line">        dest_x = self.origin_x + move_x</span><br><span class="line">        dest_y = self.origin_y + move_y</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移动窗体</span></span><br><span class="line">        self.move(dest_x, dest_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def layerScan(scanWidth):</span></span><br><span class="line">    <span class="comment">#     for i in range(0, 280, 20):</span></span><br><span class="line">    <span class="comment">#         time.sleep(0.5)</span></span><br><span class="line">    <span class="comment">#         frame1 = frame[i:i + scanWidth, 0:frame_width]</span></span><br><span class="line">    <span class="comment">#         frame2 = frame[480 - i - scanWidth:480 - i, 0:frame_width]</span></span><br><span class="line">    <span class="comment">#         cv2.imshow(&#x27;frame1&#x27;, frame1)</span></span><br><span class="line">    <span class="comment">#         cv2.imshow(&#x27;frame2&#x27;, frame2)</span></span><br><span class="line">    <span class="comment">#         if cv2.waitKey(1) == ord(&quot;q&quot;):</span></span><br><span class="line">    <span class="comment">#             break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">colActDetect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> lower_red, higher_red, lower_red2, higher_red2, lower_green, higher_green, lower_blue, higher_blue</span><br><span class="line">        self.textBrowser.setText(<span class="string">f&quot;&lt;h3&gt;红色物料上下阈值:<span class="subst">&#123;lower_red&#125;</span> --&gt; <span class="subst">&#123;higher_red&#125;</span>&lt;/h3&gt;&quot;</span></span><br><span class="line">                                 <span class="string">f&quot;&lt;h3&gt;绿色物料上下阈值:<span class="subst">&#123;lower_green&#125;</span> --&gt; <span class="subst">&#123;higher_green&#125;</span>&lt;/h3&gt;&quot;</span></span><br><span class="line">                                 <span class="string">f&quot;&lt;h3&gt;蓝色物料上下阈值:<span class="subst">&#123;lower_blue&#125;</span> --&gt; <span class="subst">&#123;higher_blue&#125;</span>&lt;/h3&gt;&quot;</span>)</span><br><span class="line">        lower_red = np.array([self.Red_down_H.value(),</span><br><span class="line">                              self.Red_down_S.value(),</span><br><span class="line">                              self.Red_down_V.value()])</span><br><span class="line">        higher_red = np.array([self.Red_up_H.value(),</span><br><span class="line">                               self.Red_up_S.value(),</span><br><span class="line">                               self.Red_up_V.value()])</span><br><span class="line">        lower_red2 = np.array([<span class="number">156</span>,</span><br><span class="line">                              self.Red_down_S.value(),</span><br><span class="line">                              self.Red_down_V.value()])</span><br><span class="line">        higher_red2 = np.array([<span class="number">180</span>,</span><br><span class="line">                               self.Red_up_S.value(),</span><br><span class="line">                               self.Red_up_V.value()])</span><br><span class="line">        lower_green = np.array([self.Green_down_H.value(),</span><br><span class="line">                                self.Green_down_S.value(),</span><br><span class="line">                                self.Green_down_V.value()])</span><br><span class="line">        higher_green = np.array([self.Green_up_H.value(),</span><br><span class="line">                                 self.Green_up_S.value(),</span><br><span class="line">                                 self.Green_up_V.value()])</span><br><span class="line">        lower_blue = np.array([self.Blue_down_H.value(),</span><br><span class="line">                               self.Blue_down_S.value(),</span><br><span class="line">                               self.Blue_down_V.value()])</span><br><span class="line">        higher_blue = np.array([self.Blue_up_H.value(),</span><br><span class="line">                                self.Blue_up_S.value(),</span><br><span class="line">                                self.Blue_up_V.value()])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_CV_thread</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.evt_run.run()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evt_small</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.showMinimized()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evt_close</span>(<span class="params">self</span>):</span></span><br><span class="line">        sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_R_page</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stackedWidget.setCurrentIndex(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_G_page</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stackedWidget.setCurrentIndex(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_B_page</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stackedWidget.setCurrentIndex(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_Red_down_Page</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.R_W.setCurrentIndex(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_Red_up_Page</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.R_W.setCurrentIndex(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_Green_down_Page</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.G_W.setCurrentIndex(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_Green_up_Page</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.G_W.setCurrentIndex(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_Blue_down_Page</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.B_W.setCurrentIndex(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_Blue_up_Page</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.B_W.setCurrentIndex(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    main_win = mainWin()</span><br><span class="line">    main_win.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于 简化步骤来获得6自由度机械臂关键帧 的 通用上位机串口通信机械臂调试软件</title>
      <link href="/2023/01/17/%E7%94%A8%E4%BA%8E%20%E7%AE%80%E5%8C%96%E6%AD%A5%E9%AA%A4%E6%9D%A5%E8%8E%B7%E5%BE%976%E8%87%AA%E7%94%B1%E5%BA%A6%E6%9C%BA%E6%A2%B0%E8%87%82%E5%85%B3%E9%94%AE%E5%B8%A7%20%E7%9A%84%20%E9%80%9A%E7%94%A8%E4%B8%8A%E4%BD%8D%E6%9C%BA%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E6%9C%BA%E6%A2%B0%E8%87%82%E8%B0%83%E8%AF%95%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/01/17/%E7%94%A8%E4%BA%8E%20%E7%AE%80%E5%8C%96%E6%AD%A5%E9%AA%A4%E6%9D%A5%E8%8E%B7%E5%BE%976%E8%87%AA%E7%94%B1%E5%BA%A6%E6%9C%BA%E6%A2%B0%E8%87%82%E5%85%B3%E9%94%AE%E5%B8%A7%20%E7%9A%84%20%E9%80%9A%E7%94%A8%E4%B8%8A%E4%BD%8D%E6%9C%BA%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E6%9C%BA%E6%A2%B0%E8%87%82%E8%B0%83%E8%AF%95%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><p>之前参加了 中国大学生工程实践与创新能力大赛 的 智能物流机器人的竞赛，因为我们刚开始做的是一个6自由度的机械臂。。调参调的简直要命。为了方便提高 测试机械臂关键帧舵机的参数，我写了个 基于串口的 机械臂实时控制软件。</p><hr><h2 id="0-功能："><a href="#0-功能：" class="headerlink" title="0. 功能："></a>0. 功能：</h2><ol><li>通过串口通信协议实时控制机械臂，并显示当前的舵机参数。</li><li>将当前的舵机参数保存到 <code>机械臂关键帧-录取表.xlsx</code> 表格里。</li><li>可以完整的测试 <code>机械臂关键帧-确认表.xlsx</code> 的所有动作帧。</li><li>可以单独测试 <code>机械臂关键帧-确认表.xlsx</code> 的单个动作帧。</li></ol><h2 id="1-软件展示-及-相关源码地址："><a href="#1-软件展示-及-相关源码地址：" class="headerlink" title="1. 软件展示 及 相关源码地址："></a>1. 软件展示 及 相关源码地址：</h2><p>Github源码地址：<a href="https://github.com/Panzer-Jack/SerialHelperfor_SIX-DOF_manipulator">https://github.com/Panzer-Jack/SerialHelperfor_SIX-DOF_manipulator</a></p><img src="https://pic.imgdb.cn/item/63c68b78be43e0d30e36245d.png"><h2 id="2-功能实现："><a href="#2-功能实现：" class="headerlink" title="2. 功能实现："></a>2. 功能实现：</h2><p>这边只展示 主函数（功能实现的代码），图形化代码可以到我的GitHub的仓库里查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> robArm <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line">res1 = <span class="string">&quot;34&quot;</span></span><br><span class="line">res2 = <span class="string">&quot;104&quot;</span></span><br><span class="line">res3 = <span class="string">&quot;106&quot;</span></span><br><span class="line">res4 = <span class="string">&quot;166&quot;</span></span><br><span class="line">res5 = <span class="string">&quot;100&quot;</span></span><br><span class="line">res6 = <span class="string">&quot;157&quot;</span></span><br><span class="line">com = <span class="string">&quot;&quot;</span></span><br><span class="line">msgGlobal = <span class="string">&quot;&quot;</span></span><br><span class="line">msgGlobalOld = <span class="string">&quot;&quot;</span></span><br><span class="line">gjzText = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">serial_frameGJZ</span>(<span class="params">QThread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span>, ser=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(serial_frameGJZ, self).__init__(parent)</span><br><span class="line">        self.ser = ser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serial_C</span>(<span class="params">self</span>):</span></span><br><span class="line">        worksheet2 = xlrd.open_workbook(<span class="string">&quot;机械臂关键帧-确认表.xlsx&quot;</span>)</span><br><span class="line">        sheet = worksheet2.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># self.ser = serial.Serial(com, 9600, timeout=0.5)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            i = <span class="built_in">int</span>(gjzText)</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            <span class="keyword">if</span> i == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.ser.write(</span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">0</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">1</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">2</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">3</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">4</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">5</span>])&#125;</span> 90&quot;</span>.encode())</span><br><span class="line">            msg = self.ser.readlines()</span><br><span class="line">            <span class="comment"># print()</span></span><br><span class="line">            <span class="keyword">if</span> msg:</span><br><span class="line">                <span class="built_in">print</span>(msg)</span><br><span class="line">            <span class="comment">#     break</span></span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.serial_C()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">serial_frameTest</span>(<span class="params">QThread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span>, ser=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(serial_frameTest, self).__init__(parent)</span><br><span class="line">        self.ser = ser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serial_C</span>(<span class="params">self</span>):</span></span><br><span class="line">        worksheet2 = xlrd.open_workbook(<span class="string">&quot;机械臂关键帧-确认表.xlsx&quot;</span>)</span><br><span class="line">        sheet = worksheet2.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># self.ser = serial.Serial(com, 9600, timeout=0.5)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, sheet.nrows):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                self.ser.write(</span><br><span class="line">                    <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">0</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">1</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">2</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">3</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">4</span>])&#125;</span> <span class="subst">&#123;<span class="built_in">str</span>(sheet.row_values(i)[<span class="number">5</span>])&#125;</span> 90&quot;</span>.encode())</span><br><span class="line">                msg = self.ser.readlines()</span><br><span class="line">                <span class="keyword">if</span> msg:</span><br><span class="line">                    <span class="built_in">print</span>(msg)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="built_in">print</span>(sheet.row_values(i))</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.serial_C()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">serial_control</span>(<span class="params">QThread</span>):</span></span><br><span class="line">    update_date = pyqtSignal(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span>, ser=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(serial_control, self).__init__(parent)</span><br><span class="line">        self.ser = ser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serial_C</span>(<span class="params">self, ser</span>):</span></span><br><span class="line">        <span class="keyword">global</span> res1, res2, res3, res4, res5, res6, msgGlobal, msgGlobalOld</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            ser.write(</span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;res1&#125;</span> <span class="subst">&#123;res2&#125;</span> <span class="subst">&#123;res3&#125;</span> <span class="subst">&#123;res4&#125;</span> <span class="subst">&#123;res5&#125;</span> <span class="subst">&#123;res6&#125;</span> 90&quot;</span>.encode())</span><br><span class="line">            msg = ser.readlines()</span><br><span class="line">            <span class="keyword">if</span> msg:</span><br><span class="line">                msgGlobal = msg</span><br><span class="line">                <span class="built_in">print</span>(msg)</span><br><span class="line">                <span class="keyword">if</span> msgGlobal != msgGlobalOld:</span><br><span class="line">                    msgGlobalOld = msgGlobal</span><br><span class="line">                    self.update_date.emit(<span class="string">&#x27;update&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ser = serial.Serial(com, 9600, timeout=0.5)</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            self.serial_C(self.ser)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainWin</span>(<span class="params">QMainWindow, Ui_ETC_UI_main</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowFlags(QtCore.Qt.WindowType.FramelessWindowHint)</span><br><span class="line">        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)</span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">&#x27;qtMain.ico&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 主程序按钮</span></span><br><span class="line">        self.button_close.clicked.connect(self.evt_close)</span><br><span class="line">        self.button_small.clicked.connect(self.evt_small)</span><br><span class="line">        self.button_testFrame.clicked.connect(self.run_frameTable)</span><br><span class="line">        self.button_run.clicked.connect(self.run)</span><br><span class="line">        self.recordButton.clicked.connect(self.recordFrame)</span><br><span class="line">        self.gjz_button.clicked.connect(self.gjz_step)</span><br><span class="line">        self.recordButton_2.clicked.connect(self.oc_serial)</span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        self.row = <span class="number">0</span></span><br><span class="line">        self.gjzText = <span class="number">0</span></span><br><span class="line">        self.ser = <span class="literal">None</span></span><br><span class="line">        self.workbook = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        self.worksheet = self.workbook.add_sheet(<span class="string">&quot;机械臂关键帧-sheet1&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.slider.valueChanged.connect(self.valueChange)</span><br><span class="line">        self.slider_2.valueChanged.connect(self.valueChange)</span><br><span class="line">        self.slider_3.valueChanged.connect(self.valueChange)</span><br><span class="line">        self.slider_4.valueChanged.connect(self.valueChange)</span><br><span class="line">        self.slider_5.valueChanged.connect(self.valueChange)</span><br><span class="line">        self.slider_6.valueChanged.connect(self.valueChange)</span><br><span class="line"></span><br><span class="line">        self.textSlider.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res1&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_2.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res2&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_3.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res3&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_4.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res4&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_5.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res5&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_6.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res6&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 窗口可拖动</span></span><br><span class="line">        self.mouse_x = self.mouse_y = self.origin_x = self.origin_y = <span class="literal">None</span></span><br><span class="line">        QMessageBox.about(self, <span class="string">&#x27;天父的博爱&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;“凡事都不可亏欠人，惟有彼此相爱，当常以为亏欠，因为爱人的，就完全了律法。&#x27;</span></span><br><span class="line">                          <span class="string">&#x27;像那不可奸淫，不可杀人，不可偷盗，不可贪婪，或有别的诫命，都包在爱人如己这一句话之内的。&#x27;</span></span><br><span class="line">                          <span class="string">&#x27;爱是不加害于人的，所以爱就完全了律法。” \n      ------------（《新约·罗马书》第十三章）\n&#x27;</span></span><br><span class="line">                          <span class="string">&#x27;所以你们也要爱我，所以当出现新的bug时 先别急着找@我去debug。神是爱你们的，要先想想如何找到天父为你们放置的另一个接口，&#x27;</span></span><br><span class="line">                          <span class="string">&#x27;神曰：当上帝关了这扇门，一定会为你打开另一扇门。\n      ------------ 天父 · Panzer_Jack&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 1.鼠标点击事件</span></span><br><span class="line">    <span class="comment"># def mousePressEvent(self, evt):</span></span><br><span class="line">    <span class="comment">#     # 获取鼠标当前的坐标</span></span><br><span class="line">    <span class="comment">#     self.mouse_x = evt.globalX()</span></span><br><span class="line">    <span class="comment">#     self.mouse_y = evt.globalY()</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     # 获取窗体当前坐标</span></span><br><span class="line">    <span class="comment">#     self.origin_x = self.x()</span></span><br><span class="line">    <span class="comment">#     self.origin_y = self.y()</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 2.鼠标移动事件</span></span><br><span class="line">    <span class="comment"># def mouseMoveEvent(self, evt):</span></span><br><span class="line">    <span class="comment">#     # 计算鼠标移动的x，y位移</span></span><br><span class="line">    <span class="comment">#     move_x = evt.globalX() - self.mouse_x</span></span><br><span class="line">    <span class="comment">#     move_y = evt.globalY() - self.mouse_y</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     # 计算窗体更新后的坐标：更新后的坐标 = 原本的坐标 + 鼠标的位移</span></span><br><span class="line">    <span class="comment">#     dest_x = self.origin_x + move_x</span></span><br><span class="line">    <span class="comment">#     dest_y = self.origin_y + move_y</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     # 移动窗体</span></span><br><span class="line">    <span class="comment">#     self.move(dest_x, dest_y)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oc_serial</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> com</span><br><span class="line">        com = self.lineEdit_7.text()</span><br><span class="line">        self.ser = serial.Serial(com, <span class="number">9600</span>, timeout=<span class="number">0.5</span>)</span><br><span class="line">        self.serial_runFrameTest = serial_frameTest(ser=self.ser)</span><br><span class="line">        self.serial_runFrameGJZ = serial_frameGJZ(ser=self.ser)</span><br><span class="line">        self.serial_run = serial_control(ser=self.ser)</span><br><span class="line">        self.serial_run.update_date.connect(self.get_Info)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gjz_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> gjzText, com</span><br><span class="line">        com = self.lineEdit_7.text()</span><br><span class="line">        gjzText = self.gjz_line.text()</span><br><span class="line">        <span class="built_in">print</span>(gjzText)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.flag:</span><br><span class="line">            self.flag = <span class="number">1</span></span><br><span class="line">            self.serial_runFrameGJZ.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_Info</span>(<span class="params">self</span>):</span></span><br><span class="line">        msg = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(msgGlobal)):</span><br><span class="line">            msg += msgGlobal[i].decode()</span><br><span class="line">        self.showTable.append(<span class="string">f&quot;<span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_frameTable</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> com</span><br><span class="line">        com = self.lineEdit_7.text()</span><br><span class="line">        self.serial_runFrameTest.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recordFrame</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.worksheet.write(self.row, <span class="number">0</span>, <span class="built_in">str</span>(res1))</span><br><span class="line">        self.worksheet.write(self.row, <span class="number">1</span>, <span class="built_in">str</span>(res2))</span><br><span class="line">        self.worksheet.write(self.row, <span class="number">2</span>, <span class="built_in">str</span>(res3))</span><br><span class="line">        self.worksheet.write(self.row, <span class="number">3</span>, <span class="built_in">str</span>(res4))</span><br><span class="line">        self.worksheet.write(self.row, <span class="number">4</span>, <span class="built_in">str</span>(res5))</span><br><span class="line">        self.worksheet.write(self.row, <span class="number">5</span>, <span class="built_in">str</span>(res6))</span><br><span class="line">        self.worksheet.write(self.row, <span class="number">6</span>, <span class="string">&quot;90&quot;</span>)</span><br><span class="line">        self.row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valueChange</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> res1, res2, res3, res4, res5, res6</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        res1 = self.slider.value()</span><br><span class="line">        res2 = self.slider_2.value()</span><br><span class="line">        res3 = self.slider_3.value()</span><br><span class="line">        res4 = self.slider_4.value()</span><br><span class="line">        res5 = self.slider_5.value()</span><br><span class="line">        res6 = self.slider_6.value()</span><br><span class="line">        <span class="comment"># com = self.lineEdit_7.text()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(&quot;test:&quot;, res1, res2, res3, res4, res5, res6)</span></span><br><span class="line">        self.textSlider.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res1&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_2.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res2&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_3.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res3&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_4.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res4&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_5.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res5&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line">        self.textSlider_6.setText(<span class="string">f&#x27;&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">f&#x27;font-size:18pt; font-weight:100; color:#00ff00;&quot;&gt;<span class="subst">&#123;res6&#125;</span>&lt;/span&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># global com</span></span><br><span class="line">        <span class="comment"># com = self.lineEdit_7.text()</span></span><br><span class="line">        self.serial_run.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_CV_thread</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.evt_run.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evt_small</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.showMinimized()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evt_close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.workbook.save(<span class="string">&quot;机械臂关键帧-录取表.xlsx&quot;</span>)</span><br><span class="line">        sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    main_win = mainWin()</span><br><span class="line">    main_win.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Python socket利用TCP协议让上下位机 传输图片</title>
      <link href="/2023/01/17/%E5%9F%BA%E4%BA%8EPython%20socket%E5%88%A9%E7%94%A8TCP%E5%8D%8F%E8%AE%AE%E8%AE%A9%E4%B8%8A%E4%B8%8B%E4%BD%8D%E6%9C%BA%20%E4%BC%A0%E8%BE%93%E5%9B%BE%E7%89%87/"/>
      <url>/2023/01/17/%E5%9F%BA%E4%BA%8EPython%20socket%E5%88%A9%E7%94%A8TCP%E5%8D%8F%E8%AE%AE%E8%AE%A9%E4%B8%8A%E4%B8%8B%E4%BD%8D%E6%9C%BA%20%E4%BC%A0%E8%BE%93%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><p>之前用来做 基于QT 的物联网图形化软件的其中一个功能，因为在这遇到过许多坑所以分享一下我的解决方案，比如图片传输只传输了一部分。。各种丢数据。。最后终于实现了一个有效的方法。</p><hr><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h2><ol><li>在接受图片数据帧前 先让下位机发送一个 图片数据帧的字长。然后在以此为循环出口，不断把接收过来的图片数据帧加起来，最后得到图片的数据帧。</li></ol><p><br><br></p><h2 id="2-下位机代码："><a href="#2-下位机代码：" class="headerlink" title="2. 下位机代码："></a>2. 下位机代码：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 服务端的IP地址 + 建立TCP客户端</span></span><br><span class="line">Server_Host = <span class="string">&#x27;192.168.1.1&#x27;</span></span><br><span class="line">ListenSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">ListenSocket.connect((Server_Host, <span class="number">1919</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;发送身份信息到上位机&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 图片数据帧的长度</span></span><br><span class="line">    encode_len = <span class="built_in">str</span>(<span class="built_in">len</span>(self.pic_data)).encode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(encode_len))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送图片数据帧的长度</span></span><br><span class="line">    ListenSocket.send(encode_len)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 发送图片数据帧</span></span><br><span class="line">    ListenSocket.send(self.pic_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是用来防差错测试的（可以不写）</span></span><br><span class="line"><span class="comment"># 验证发送的图片 是否正确</span></span><br><span class="line">    nparr = np.fromstring(self.pic_data, dtype=<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">    img_decode = cv2.imdecode(nparr, cv2.IMREAD_COLOR)</span><br><span class="line">    <span class="built_in">print</span>(img_decode)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_decode&quot;</span>, img_decode)  <span class="comment"># 显示图片</span></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="3-上位机代码："><a href="#3-上位机代码：" class="headerlink" title="3. 上位机代码："></a>3. 上位机代码：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TCP服务端</span></span><br><span class="line">Server_Host = <span class="string">&#x27;192.168.137.1&#x27;</span>  <span class="comment"># 填写上位机的 IP地址</span></span><br><span class="line">Client_Host = <span class="string">&#x27;192.168.137.47&#x27;</span>  <span class="comment"># 填写下位机的 IP地址</span></span><br><span class="line"></span><br><span class="line">tcpServer = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">tcpServer.bind((Server_Host, <span class="number">1919</span>))</span><br><span class="line">tcpServer.listen(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">img_decode = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">recvTCP_thread</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_recv</span>(<span class="params">self, sock, count</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;利用接收的图片长度把图片数据帧加起来&quot;&quot;&quot;</span></span><br><span class="line">        data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> count:</span><br><span class="line">            recvData = sock.recv(count)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> recvData:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            data += recvData</span><br><span class="line">            count -= <span class="built_in">len</span>(recvData)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_img</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span></span><br><span class="line">    client, address = tcpServer.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># 接收二进制图片数据帧长度</span></span><br><span class="line">        tempdata_len = client.recv(<span class="number">1024</span>).decode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">int</span>(tempdata_len))</span><br><span class="line"><span class="comment"># 使用my_recv函数来 接收二进制图片数据帧</span></span><br><span class="line">        data = self.my_recv(client, <span class="built_in">int</span>(tempdata_len))</span><br><span class="line"><span class="comment"># 把二进制图片转换格式</span></span><br><span class="line">        nparr = np.fromstring(data, dtype=<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">        img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 显示图片</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_decode&quot;</span>, img)  <span class="comment"># 显示图片</span></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> OpenCV </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Web前端】项目练习2_小兔鲜电商</title>
      <link href="/2023/01/17/%E3%80%90Web%E5%89%8D%E7%AB%AF%E3%80%91%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A02_%E5%B0%8F%E5%85%94%E9%B2%9C%E7%94%B5%E5%95%86/"/>
      <url>/2023/01/17/%E3%80%90Web%E5%89%8D%E7%AB%AF%E3%80%91%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A02_%E5%B0%8F%E5%85%94%E9%B2%9C%E7%94%B5%E5%95%86/</url>
      
        <content type="html"><![CDATA[<h1 id="【Web前端】项目练习2-小兔鲜电商"><a href="#【Web前端】项目练习2-小兔鲜电商" class="headerlink" title="【Web前端】项目练习2_小兔鲜电商"></a>【Web前端】项目练习2_小兔鲜电商</h1><img src="https://pic.imgdb.cn/item/63c673e4be43e0d30e070895.png" alt="学成在线.png"><p>项目网址: <a href="https://practice2.panzer-jack.cn/">https://practice2.panzer-jack.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML + CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Web前端】项目练习1:学成在线</title>
      <link href="/2023/01/14/%E3%80%90Web%E5%89%8D%E7%AB%AF%E3%80%91%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A01_%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/"/>
      <url>/2023/01/14/%E3%80%90Web%E5%89%8D%E7%AB%AF%E3%80%91%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A01_%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="【Web前端】项目练习1-学成在线"><a href="#【Web前端】项目练习1-学成在线" class="headerlink" title="【Web前端】项目练习1: 学成在线"></a>【Web前端】项目练习1: 学成在线</h1><img src="https://pic.imgdb.cn/item/63c2c7a3be43e0d30ed24394.png" alt="学成在线.png"><p>项目网址: <a href="https://practice1.panzer-jack.cn/">https://practice1.panzer-jack.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML + CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能门禁系统</title>
      <link href="/2022/11/18/%E6%99%BA%E8%83%BD%E9%98%B2%E7%96%AB%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/11/18/%E6%99%BA%E8%83%BD%E9%98%B2%E7%96%AB%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p align="center">    <img src="https://pic.imgdb.cn/item/63770c5416f2c2beb107d59f.png" width="200" height="200" alt="go-cqhttp"></p><div align="center">    <h1 id="智能防疫系统"><a href="#智能防疫系统" class="headerlink" title="智能防疫系统"></a>智能防疫系统</h1><p><em>✨ 基于 <a href>Python</a> + <a href>MysQL</a>  实现 ✨</em>  </p><p> AI epidemic prevention access control system - upper and lower computers include identification, health code detection, real-time monitoring, temperature monitoring, mask detection and other functions.</p></div><p>【 <strong>内容摘要</strong> 】：本项目主要是基于Python和MariaDB开发了一款低成本的智能防疫门禁系统，包含了三个部分：上位机监控管理软件、下位机检测实体机、人脸信息训练录入小助手。本项目该使用机器学习、视觉处理、爬虫技术来实现身份识别与健康数据检测，并使用网络通信技术通过上位机实时监控门禁签入签出人脸图像数据。本项目目的设计一款能够实现自助登记、自动比对、自动测温、无人值守且低成本的防疫快速登记智能门禁终端系统，最大限度避免交叉感染，并为疫情科学管理与精准决策提供数据支撑。</p><p><strong>【关键词】：</strong> 机器视觉 &nbsp;&nbsp; 机器学习 &nbsp;&nbsp; 物联网 &nbsp;&nbsp; 爬虫技术 &nbsp;&nbsp; 健康医疗</p><hr><p><a href="https://docs.ai-ep-system.panzer-jack.cn/">官方文档 | Document</a><br><a href="https://github.com/Panzer-Jack/QQRob_Izumi-Hiyori_For_SSPU-Lec-In-SCAndDailyReport">Github 开源地址 | Open source</a></p><h2 id="一、项目规划概览"><a href="#一、项目规划概览" class="headerlink" title="一、项目规划概览"></a>一、项目规划概览</h2><p>在项目制作分为了5个步骤：</p><p>首先，完成并实现人脸样本收集训练且识别、口罩识别以及健康码识别等功能。</p><p>其次，构建上位机软件的UI界面。</p><p>之后，将人脸识别等一系列机器视觉的功能封装入下位机并且利用MariaDB搭建人员管理数据库服务器并将之对接上位机后端实现实时网络传输监控。</p><p>然后，将人脸识别训练工具、上位机监控软件封装成图形化程序进行部署。</p><p>最后，完成项目的说明文档的编写。</p><h2 id="二-、调研报告"><a href="#二-、调研报告" class="headerlink" title="二 、调研报告"></a>二 、调研报告</h2><p>对于国内而言，目前国内研究此项目的人较少，山东威尔数据股份有限公司以”为用户提供身份识别整体解决方案及落地服务”的发展战略，聚焦校园及政企用户，主导产品有：智慧校园协同教育云平台、校园身份识别应用解决方案、智慧企业管理平台、身份识别智能终端，广泛应用于门禁、考勤、消费、班牌、会议、访客等需要验证人员身份的场所管理。在国外，意大利实施”绿色通行证”计划，要求12岁以上民众进入健身房、博物馆、电影院等室内活动场所或参加比赛、考试等公众活动时提供相关证明，教师和大学生进入教室时，以及人们在乘火车、飞机、轮船、城际长途汽车等长途交通工具时提供”绿色通行证”。澳大利亚数字疫苗证书政策，已经接种过两剂疫苗的澳大利亚人将自动获得一份疫苗接种证书，并可以下载到他们的手机上。两个国家目前实施的方式与国内大不相同，只有中国采取了健康码通行的方式，能有效且快速的完成健康证明。</p><h2 id="三、可行性分析"><a href="#三、可行性分析" class="headerlink" title="三、可行性分析"></a>三、可行性分析</h2><p>该产品有以下几个优点：</p><p>1.低投入：首先，我们要知道国内的大部分安全门禁和数字哨兵的费用是十分高昂的少</p><p><img src="https://pic.imgdb.cn/item/637704c416f2c2beb1f0a3a9.jpg"></p><p>则几千多则上万，大部分应该是接入的地区健康码的租用价格所致价格不一的问题。但该项目所使用的检测健康码的技术，使用OpenCV加爬虫技术通过读取健康码二维码地址在通过网络爬虫去分析JS源码和动态生成接口返回的数据来识别健康码的状态。这样就能不需要获取官方接口，也能有效识别扫描者的健康码实际状态了。加上硬件如一些micropython核心的单片机甚至一些微型X86主板Z3735F这种等都可直接移植Open CV环境，且价格远远在300元以下，有效降低了成本。</p><p><img src="https://pic.imgdb.cn/item/637704c416f2c2beb1f0a3af.png"></p><p>无接触：减少人员之间的接触机会，降低交叉感染的风险；可追溯：数据真实、清晰、不可作假，出现异常可及时预警、追本溯源；</p><p>大数据：所有数据可统一汇总、查询、分析，为决策提供依据，为责任界定提供参照； 超便利：产品使用方式灵活、操作简单、无需安装，为用户带来极大便利性；</p><p>能复用：终端硬件产品可移动、可固定，软件系统可升级，疫情结束后仍可作为员工考勤、人脸门禁、访客身份认证等功能使用，持续发挥价值。</p><h2 id="四、设计或实施报告"><a href="#四、设计或实施报告" class="headerlink" title="四、设计或实施报告"></a>四、设计或实施报告</h2><h3 id="4-1-人脸识别"><a href="#4-1-人脸识别" class="headerlink" title="4.1 人脸识别"></a>4.1 人脸识别</h3><p>提前准备：1，让每个人上交一段/或者直接站在系统面前拍摄一段高质量的正脸照视频。2，通过OpenCV自带的人脸分类器检测出人脸边框并截取 视频帧 成指定区域大小的图片按名字序号保存（将记录者信息保存本地/云端）。3，搭建学习环境，通过LBPH算法挨个对着名字Label监督训练并保存训练好的模型。</p><p>现场执行：通过训练好的模型设置置信度，对比数据库内的人名核实检测人员信息。</p><h3 id="4-2-口罩识别"><a href="#4-2-口罩识别" class="headerlink" title="4.2 口罩识别"></a>4.2 口罩识别</h3><p>方案1：通过OpenCV处理后 的人脸口罩覆盖度判别是否佩戴口罩（误检情况非常多，因为原理是通过处理图片后二值化后检测二值化后的颜色在整个脸部的覆盖度；因此比如手覆盖遮住嘴巴或者光线问题导致误检几率很大）</p><p>方案2：直接使用paddlehub库的预训练模型。</p><p>最终选择：方案2</p><h3 id="4-3-健康码识别"><a href="#4-3-健康码识别" class="headerlink" title="4.3 健康码识别"></a>4.3 健康码识别</h3><p>方案1：使用pyzbar库+requests库 通过二维码解码+爬虫形式对接Ajax异步加载的数据接口（页面动态生成没法直接爬HTML源码，需要专门写算法取地址对接到官方的xhr 接口上）然后解析官方API 的 JS源码返回的code状态值来判断健康状态。（可用性高，需要联网）</p><p>方案2：使用Open CV 库，通过通过适当滤波后 用HSV范围锁定健康码颜色区间然后 判别状态（安全性低 图片可伪造 但可脱机运行）</p><p>方案3：直接拿政府给的后台，但是需要钱租用。</p><p>最终选择：方案1</p><h3 id="4-4-网络通信-（上下位机）："><a href="#4-4-网络通信-（上下位机）：" class="headerlink" title="4.4 网络通信 （上下位机）："></a>4.4 网络通信 （上下位机）：</h3><p>方案1：使用socket通信技术让上下位机双方建立UDP/TCP连接，实现数据传输。（这里给的是UDP连接的测试图）</p><p>方案2：使用HC-05等蓝牙模块简单匹配好波特率后，可直接实现数据传输。(蓝牙传输距离有限，且非常容易烧坏）</p><p>方案3：固定设备可直接通过有线串口通信或者I2C通信 进行稳定的设备连接</p><p>最终选择：方案1的TCP协议。</p><h3 id="4-5-软件图形化设计："><a href="#4-5-软件图形化设计：" class="headerlink" title="4.5 软件图形化设计："></a>4.5 软件图形化设计：</h3><p>项目中，我选择了使用PyQT5进行软件图形化开发。在开发过程中需要特别注重软件的多线程信号量的设置，以防死锁问题。其次在软件进行可执行程序打包过程中，也出现了许多依赖库缺失问题。通过检查发现是因为开发时应用了自建的隔离虚拟环境，所以电脑并没有检查到依赖库的具体地址，解决方案：手动打包依赖库进根目录。</p><h3 id="4-6-人体测温："><a href="#4-6-人体测温：" class="headerlink" title="4.6 人体测温："></a>4.6 人体测温：</h3><p>在人体测温上，我们使用的是串口MLX90614人体测温模块，因此可在有效距离30cm处进行准确测温。然后通过串口返回给我们的下位机处理器，并实时录入进我们的人员管理数据库中。</p><h3 id="4-7-文档网站设计："><a href="#4-7-文档网站设计：" class="headerlink" title="4.7 文档网站设计："></a>4.7 文档网站设计：</h3><p>使用Github+docsify 进行搭建文档。通过markdown 来编写文档。这样不仅方便检查同时也有效减少了网站开发时间。</p><h2 id="五、发布或推广"><a href="#五、发布或推广" class="headerlink" title="五、发布或推广"></a>五、发布或推广</h2><p>官方文档地址：<a href="https://docs.ai-ep-system.panzer-jack.cn/">https://docs.ai-ep-system.panzer-jack.cn/</a></p><p>项目开源及其发布地址：<a href="https://github.com/Panzer-Jack/AI/_EP/_System">https://github.com/Panzer-Jack/AI\_EP\_System</a></p><h2 id="六、项目总体设计"><a href="#六、项目总体设计" class="headerlink" title="六、项目总体设计"></a>六、项目总体设计</h2><p>本项目总共分为3个部分：包含了三个部分：上位机监控管理软件、下位机检测实体机、人脸信息训练录入小助手。</p><h3 id="第一部分：上位机监控管理软件"><a href="#第一部分：上位机监控管理软件" class="headerlink" title="第一部分：上位机监控管理软件"></a>第一部分：上位机监控管理软件</h3><p>在第一部分上位机监控管理软件里，我使用了PyQT5 来进行软件的图形化开发设计，在上位机设计中，或者说整个项目中，比起人脸识别这种机器视觉训练的部分，如何实现不丢数据的实时二进制图片流的网络传输更是一个大坑，通过多次实验结论是需要提前发送一个统计好的字节流长度，然后以这个字节流长度为基础进行循环叠加直到数据接收完成。不然接收的数据流在解析后会出现明显的丢数据，并且在统计字节流长度时候也验证了这一点。</p><p>在上位机软件的开发过程中需要特别注重软件的多线程信号量的设置，以防死锁问题。</p><p>使用注意事项：</p><ol><li>你需要在上位机部分同时配置好服务端和客户端的IP地址端。并且你需要配置好远程的数据库连接。</li><li>上位机使用：开启main.exe后会开启服务器端口，然后打开建立连接后，即可对下位机数据库建立连接。这时候你打开下位机时，下位机就会搜寻上位机然后发现并建立TCP连接。</li></ol><p><img src="https://pic.imgdb.cn/item/637704c416f2c2beb1f0a3b9.png"></p><p><img src="https://pic.imgdb.cn/item/637704c416f2c2beb1f0a3bf.jpg"></p><p><img src="https://pic.imgdb.cn/item/637704c416f2c2beb1f0a39f.png"></p><h3 id="第二部分：下位机检测实体机"><a href="#第二部分：下位机检测实体机" class="headerlink" title="第二部分：下位机检测实体机"></a>第二部分：下位机检测实体机</h3><p>在第二部分下位机检测实体机里，我使用了Raspberry Pi 开发板作为下位机的处理器，并且使用了tjc3224t128_011 串口屏 和 H200S工业摄像头作为检测设备。人脸识别使用的是Open CV库内的LBPH算法模型进行监督训练。健康码解析使用的是pyzbar+requests使用爬虫对健康码二维码的动态接口返回值进行分析。在下位机中，搭建的数据库是MariaDB数据库，该数据库是MySQL数据库的一个分支，语法可以完美兼容后者。通信协议采用的是TCP协议。</p><p>使用注意事项：</p><ol><li>你需要在下位机部分配置好服务端的IP地址端。并且在当地的数据库内配置好连接 并且加入相应的人员信息，并且你需要配置好本地数据库连接。</li><li>注意请把训练好的人脸数据放到下位机项目相关的根目录地区，并且在相应的personData.py依次填入你之前挨个训练的人脸数据的人名。</li><li>请注意：人脸数据的人名一定要和数据库参数的name相等。</li><li>本项目已经在下位机部分分装好了人脸识别训练用的软件。因此，你可以直接使用本项目的人脸训练实测软件进行企业/学校等内部的人员人脸数据的录入。</li></ol><p><img src="https://pic.imgdb.cn/item/6377054f16f2c2beb1f36de6.jpg"></p><h3 id="第三部分：人脸信息训练录入小助手"><a href="#第三部分：人脸信息训练录入小助手" class="headerlink" title="第三部分：人脸信息训练录入小助手"></a>第三部分：人脸信息训练录入小助手</h3><p>在第三部分人脸信息训练录入小助手里，使用了PyQT5 开发图形化界面，将录制样本、训练模型以及实时检测效果三个功能封装进了该软件里头，方便非技术人员进行使用操作。不过唯一需要注意一点，如果用该软件训练多个人脸数据，需要手动用本项目提供的函数进行分割赋予标签来监督训练。然后就是阈值设定，这个需要多比对环境因素，特别是白天和夜晚的阈值差别相对而言会比较大。</p><p><img src="https://pic.imgdb.cn/item/6377054f16f2c2beb1f36dce.png"></p><h3 id="最后总结一下"><a href="#最后总结一下" class="headerlink" title="最后总结一下"></a>最后总结一下</h3><p>本项目总共包含了以下几个功能：1.身份识别。2.口罩识别。3.健康码识别。4.实时更新签入签出时间、健康信息数据。5.实时签入签出监控图像传输。6.检测体温。</p><p>软件使用需要注意以下几个问题：1.上下位机必须处于同一个网络中。2.先开启 下位机, 在打开 上位机。3.使用前一定要记住配置好上下位机的IP地址。4.注意！！！本软件使用的端口号为1919，如果没法使用，请优先考虑防火墙问题。最好使用前确保你的电脑已经开启了1919端口号的使用权。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我的大二十月物语果然有问题这档事</title>
      <link href="/2022/10/20/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E5%8D%81%E6%9C%88%E7%89%A9%E8%AF%AD%E6%9E%9C%E7%84%B6%E6%9C%89%E9%97%AE%E9%A2%98%E8%BF%99%E6%A1%A3%E4%BA%8B/"/>
      <url>/2022/10/20/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E5%8D%81%E6%9C%88%E7%89%A9%E8%AF%AD%E6%9E%9C%E7%84%B6%E6%9C%89%E9%97%AE%E9%A2%98%E8%BF%99%E6%A1%A3%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>曾记得一句来自国外的谚语：Proper pressure can make people full of power. 压能促力。那么。。。当遇到 improper 的时候呢？答：放空大脑。</p><p>关于我这个月月底到底有多少件活？</p><ol><li>高数下期末考试 （之前因疫情延考了）</li><li>计算机二级考</li><li>2个大创项目的结题答辩</li><li>一个关于AI-Rob的校内选拔赛</li><li>关于学校把408的三门都集中在一个学期然后布置一堆作业这档事。。</li><li><del>每天3小时的轻小说时间</del> 学习 线代+概率论</li></ol><p>那么问题来了，这个月还剩几天呢。。。(悲)</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于waline评论功能在 国内无法使用的解决方案 （vercel.app国内无法使用问题）</title>
      <link href="/2022/10/20/%E5%85%B3%E4%BA%8Ewaline%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%E5%9C%A8-%E5%9B%BD%E5%86%85%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%EF%BC%88vercel-app%E5%9B%BD%E5%86%85%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2022/10/20/%E5%85%B3%E4%BA%8Ewaline%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%E5%9C%A8-%E5%9B%BD%E5%86%85%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%EF%BC%88vercel-app%E5%9B%BD%E5%86%85%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><p>总结一下，如果直接使用Vercel搭建的waline评论系统，评论系统出现问题，多半是vercel.app域名在国内遭到污染无法访问。这里提供一个实用的解决方案：用你已有的博客域名去免费申请一个子域名来代替vercel.app那个被污染的域名。</p><hr><h1 id="你需要什么？"><a href="#你需要什么？" class="headerlink" title="你需要什么？"></a>你需要什么？</h1><ol><li>你拥有一个博客并且给它申请了域名。<br> 比如我的Blog： <code>www.panzer-jack.cn</code></li><li>按照步骤开通了waline所需的环境（leancloud、vercel那些）这里我就默认waline你已经搭建好了。</li></ol><h1 id="你需要做什么？"><a href="#你需要做什么？" class="headerlink" title="你需要做什么？"></a>你需要做什么？</h1><ol><li><p>打开你的域名管理控制台。<br> · 比如我的腾讯云：<br> <img src="https://img-blog.csdnimg.cn/41047ce4ec9448c2ab7403c194318de7.png#pic_center" alt="在这里插入图片描述"></p></li><li><p><strong>然后进去给你已有博客域名 添加一个 二级域名</strong>：<br> · 比如我 在腾讯云里的 <code>主机记录</code>里增加了一个叫做comment 并且 <code>CNAME</code> 解析记录指向了 cname.vercel-dns.com ， 如下图：<br> <img src="https://img-blog.csdnimg.cn/14f831afe4744176acd8a3b2634a244d.png#pic_center" alt="在这里插入图片描述"><br>这样我就拥有了一个 <code>comment.panzer-jack.cn</code> 的子域名了！</p></li><li><p>在setting里设置 让你原有的vercel上的waline地址指向你设置的子域名上：<br> ·<img src="https://img-blog.csdnimg.cn/98a86a56d4374678a38b14ad558b5f0e.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>最后<br>· 酱酱！ 问题解决了<img src="https://img-blog.csdnimg.cn/c51556e1121243fe82f01c1f4b5679c4.png#pic_center" alt="在这里插入图片描述"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一年总结】我的大一</title>
      <link href="/2022/10/18/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%A4%A7%E4%B8%80/"/>
      <url>/2022/10/18/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%A4%A7%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>说起来从决定踏入编程这个领域开始，已经2年了。虽然如今已经离最初那个学习的目的偏离了许多。不过——我可以很明确的说，我不后悔。纵然最初的“目标”很遗憾并没有成功完成。但是，它的“源头”是不变的。并且那种每学会一个技术时产生的至高无上的成就感（激动）, <del>就像早上醒来看到自己变成一个美少女</del> 就像打了兴奋剂似的。</p><p>从大学开始一年过去了，上海这里因为疫情其实并不能让人充分体会那种大学的氛围（毕竟从21年到现在，除了开头那几个月，大学一直都在线上度过的。。。）虽然是已经充分体会到了成人社会那种残酷性和无奈的社交关系。。</p><p>嘛。。先不谈那么多了，先总结一下大一整年的技术经历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-----------------</span><br><span class="line">Q: 大一你学了什么？</span><br><span class="line">A: 我什么都没学</span><br><span class="line">。。。</span><br><span class="line">( 啪! )</span><br><span class="line">Q: 大一你学了什么？</span><br><span class="line">A: 我什么都没学</span><br><span class="line">( 啪! )</span><br><span class="line">。。。</span><br><span class="line">。。。。</span><br><span class="line">Q: 大一你学了什么？</span><br><span class="line">A: 我</span><br><span class="line">Q: (-ω- )</span><br><span class="line">A: 我什么都 --</span><br><span class="line">Q: (-ω- #)</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure><p>咳咳。。<br>其实大一 一学年真要说我到底学懂了什么，我也不知该说什么。高中时, 因为想做galgame而去自学了Python, 所以在大学开学前的我一直在捣鼓那个Renpy引擎 和 搞一些业余板绘， 为了做游戏配乐还去学了电子钢琴，甚至在大一开学前我还为此写了一个完整的设定集和策划书。不过。。。最终，该项目也因为我那小学生都不如的场景图绘图水准 从而被我无限期的挂起了。。。但是至此也是正式启发了我对新技术的学习的动机。</p><p>大学开学后， 我陆续去学了C和Python爬虫技术，也找到真正意义上的一个志同道合的搭档（大学最大的成就）, 之后我们也顺理成章的进入了同一个实验室, 在里头用C51单片机 捣鼓出了一个用蓝牙APP操控的遥控小车。</p><p>不过，在那之后不久，我就遇到了在整个一年里甚至到现在而言对我最大的一个触动, 也同时是我在大学里第一次被迫面临的“现实”。其实，在大一的刚开始 我并不是一个计算机专业的学生，而是属于一个名叫自动化的 电子类专业生。在高中时，我打过许多人工智能机器人相关的竞赛，加上对未来的无数可能性的犹豫，我选择了一个软硬交叉方向。因此，在那时候我也面临了选择，我校的ACM俱乐部和智能车实验室在那时候同时在选拔招人，我因为专业方向而选择了后者。嗯，其实我去那边最大的原因，是因为我已经学过单片机和C语言了，因此对此不免也产生了许多盲目的自信。但。。那时我也没想到，就是这次机会，让我认识到了现实的残酷性并且也促成了之后我自学算法努力转到了我现在的计算机专业来。选拔赛的那次失败，其实是必然性的，我那盲目的“自信” 以及 本身具有的那种“大手大脚”、“粗心大意”的心态纵然不在那时，也会在之后砸到我的头上。我因为实验失误操作导致了焊接设备的电线的保护层被烧坏，最终不仅使我丧失了这次机会，同时也被智能车实验室负责的老师挨了一顿训。可以毫不夸张的说，我是在一只脚都没踏入门的前提下就被直接赶了出去。</p><p>在这次事后，我也不断地反思了许多，并且也不断思考什么才是我自己真正想要的。我最初是为了什么才会去不断的学习技术？结论是唯一的，我想要通过自己的手创造出新事物的梦想！这也是我最初一切的”源头”，不单单只是想自己做游戏，我更多的是想要自己创造，自己来做出东西。一个人宅在实验室、图书馆的小角落以及家中，不管在何处都能伸手可及的信息资源不就是这个时代最好的利器吗！Don’t always complain about anything around you. Just do what you want to do. 雄关漫道真如铁，而今迈步从头越！</p><p>很快，在不断的学习中，我和我的搭档成功接手了我们实验室一个学长留下了市级项目（省级）也以此迎来了我进入了大学以来第一个寒假。在寒假里我开始了学习算法的旅程，通过MOOC的浙大公开课，我学习并亲手编写了各种数据结构模型，并且在课后也开始刷各种算法题。同时也学习了Python的图形化技术，并且对爬虫技术进行更加深入的学习。</p><p>之后很快就得知了，并且也就是进入了与上海疫情的长期奋战，我们大一下决定全程线上教学。我认为这对我来说是一个机会，我可以充分利用课余时间去学习我想要学习的技术，<del>（和打galgame、看轻小说）</del> 利用课余 我学习了C++ 并且 利用已有的Python基础去学习了一些机器学习的入门知识，系统性的学习了并初步学会了计算机视觉入门技术。并且同时在此时我也正式决定好了转专业到计算机去，因此我也充分利用了课余把 计网+计组+数据库+操作系统 这几门专业课统统的粗略了解了一遍，同时也着手实现了一些简单的计算机视觉小项目。</p><p>很快，功夫不负有心人，我以转专业最终成绩第一名的身份成功进入了计算机专业。并且期末也保持了一个较高的成绩从而 获得了 校二等奖学金。并且也得到了机会和搭档被一起介绍给了学院的一位搞AI机器人的教授，并也得到了一个能在之后的大二参加一个稍有规模的AIRob相关的竞赛名额。</p><p>回过头来看，这一年的我经历了 来来回回，反反复复的成功和失败，养成了复盘总结的习惯，也陆陆续续学了各种技术，并且也在最后得到了一个理想的结果。但是，凭心而问，这一年我真的学懂了什么？我答不出来，纵然在这一年里我陆陆续续学了许多东西，但是这些东西却始终缺少着那个最关键的东西。在这一年里，花在确定学习方向的时间，甚至能拉平在学习中的时间。。在这一年里我学习的东西都是非固定的，基本知识网图是杂乱的，毫无体系可谈。。因此看似学了许多，花费了一堆时间，结果其实却啥都没学明白。同时在刚开始的大一上学期，因为一直忙碌在各种实验室的竞赛准备中 以及经常宅在图书馆和实验室里缘故，从而错失了许多与室友们加深关系的机会，从而也导致了在宿舍关系社交上的失败。因此，从整体角度上来说大一的一年并不是非常令人理想，它给我带来的更多是一种“教训”以及对现实的“考验”。</p><p>是的，我已经不再是高中生，那种固化的安稳的，只要努努力就能得到结果的日子已经是过去时了。未来，不！纵使是现在，这种类似的事情也依旧可能会随时发生在我身旁。嗯，Don’t always complain about anything around you. Just do what you want to do. 贯彻自我，继续前行，这个世界所带来的“考验”可不单单只有这种程度。</p><p>记录于2022年10月18日22点46分</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-10-18小破站更新日志</title>
      <link href="/2022/10/18/2022-10-18%E5%B0%8F%E7%A0%B4%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
      <url>/2022/10/18/2022-10-18%E5%B0%8F%E7%A0%B4%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="大更新"><a href="#大更新" class="headerlink" title="大更新"></a>大更新</h1><ol><li>全面更换了主题框架 –&gt; butterfly</li></ol>]]></content>
      
      
      <categories>
          
          <category> 更新日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 更新日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于树莓派 通过网线有线连接 笔记本的教训</title>
      <link href="/2022/10/18/%E5%85%B3%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE-%E9%80%9A%E8%BF%87%E7%BD%91%E7%BA%BF%E6%9C%89%E7%BA%BF%E8%BF%9E%E6%8E%A5-%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E6%95%99%E8%AE%AD/"/>
      <url>/2022/10/18/%E5%85%B3%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE-%E9%80%9A%E8%BF%87%E7%BD%91%E7%BA%BF%E6%9C%89%E7%BA%BF%E8%BF%9E%E6%8E%A5-%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E6%95%99%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<ul><li>Note:<br>  配了个静态IP后 发现树莓派完全断网了, 然后配置sd卡的无线wifi账号也依旧连不上，所以指好通过网线接上 笔记本 用以太网连接树莓派看看原因。<h1 id="1-有线连接"><a href="#1-有线连接" class="headerlink" title="1. 有线连接"></a>1. 有线连接</h1>试了网上很多方法，发现都没成功。这里写个实用的方式</li></ul><ol><li><p>一根网线连接笔记本</p></li><li><p>直接查找树莓派以太网的IPv6地址<br>可以在笔记本cmd中 用下面的方式 </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ping</span> raspberrypi.local</span><br></pre></td></tr></table></figure><p>这会直接返回ipv6 / ipv4的地址</p></li><li><p>直接使用Ipv6地址去 ssh pi@你的树莓派ipv6地址 即可</p></li></ol><h1 id="2-树莓派配置静态IP"><a href="#2-树莓派配置静态IP" class="headerlink" title="2. 树莓派配置静态IP"></a>2. 树莓派配置静态IP</h1><p>在配置 无线wifi的静态IP时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface wlan0</span><br><span class="line">static ip_address=192.168.1.114/24</span><br><span class="line">static routers=192.168.1.1</span><br><span class="line">static domain_name_servers=114.114.114.114</span><br></pre></td></tr></table></figure><p>一定要注意！！！！一定要注意！！！！一定要注意！！！！<br>static routers=192.168.1.1  &lt;—- 这里！！！ 一定要配置你自己家里的网关，别去瞎配, 这边配错了，树莓派WIFI直接没。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 go-cqhttp 开发的 SSPU的QQ机器人小助手</title>
      <link href="/2022/10/15/%E5%9F%BA%E4%BA%8E-go-cqhttp-%E5%BC%80%E5%8F%91%E7%9A%84-SSPU%E7%9A%84QQ%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%8F%E5%8A%A9%E6%89%8B/"/>
      <url>/2022/10/15/%E5%9F%BA%E4%BA%8E-go-cqhttp-%E5%BC%80%E5%8F%91%E7%9A%84-SSPU%E7%9A%84QQ%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%8F%E5%8A%A9%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p align="center">    <img src="https://pic1.imgdb.cn/item/634541a516f2c2beb15a911c.jpg" width="200" height="200" alt="go-cqhttp"></p><div align="center">    <h1 id="和泉妃爱QQ校园小助手"><a href="#和泉妃爱QQ校园小助手" class="headerlink" title="和泉妃爱QQ校园小助手"></a>和泉妃爱QQ校园小助手</h1><p><em>✨ 基于 <a href="https://github.com/mamoe/mirai">go-cqhttp</a> 以及 <a href>Python</a> + <a href>MysQL</a>  实现 ✨</em>  </p><p>Hiyori, a cute QQ Robot is used for SSPU Auto deportReport and the lecture infomation from the second class , developped by Python + MySQL( Based on go-cqhttp</p></div><p align="center">    <img src="https://img.shields.io/badge/Python-3.7+-blue" alt="license">    <img src="https://img.shields.io/badge/MySQL-MariaDB-green" alt="license"></p><p>Github 开源地址：<a href="https://github.com/Panzer-Jack/QQRob_Izumi-Hiyori_For_SSPU-Lec-In-SCAndDailyReport">和泉妃爱QQ小助手</a></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>上海第二工业大学 每日一报 自动打卡 （ 会自动汇报账号池内的用户, 并提供 在QQ内 每日定时自动汇报结果功能</li><li>上海第二工业大学 第二课堂讲座最新信息的 即时性监听 （ 只要有新讲座就会@你/全体成员 同时你也可以主动问她有多少个正在进行的讲座</li><li>日常看setu / HOMO图</li><li>食堂随机饭菜推荐</li><li>让你拥有一个随时可以和你互动的可爱伊抹多 陪你一起度过四年孤寡的校园生活</li><li>一个妃爱酱监管的小物联网系统 （如果你的HTTP服务器是搭建在树莓派或一些支持Python 环境的 嵌入式开发板上的话的话）</li></ul><h2 id="和泉·妃爱酱-的-指令-文档"><a href="#和泉·妃爱酱-的-指令-文档" class="headerlink" title="和泉·妃爱酱 的 指令-文档"></a>和泉·妃爱酱 的 指令-文档</h2><p>注：1. 命令是指 双引号内部那些，双引号不要加<br>2. 所有指令必须@和泉·妃爱酱 才能识别</p><blockquote><p>(一) 专有命令<br>语法： “cmd- “+ “指令”<br>命令指令集：</p><blockquote><ol><li>“健康打卡_查询指令”</li><li>“健康打卡_手动打卡”</li><li>“开启R18模式”(密码可以自行设置)</li><li>“涩图”</li><li>“HOMO图”</li><li>“劝学”</li><li>“添加权限用户”(关闭)</li></ol></blockquote><p>(二) 妃爱酱特性  (暗示：你可以问她)</p><blockquote><ol><li>和欧尼酱一样喜欢摆烂</li><li>有时候会去学校食堂里头吃些好吃的, 所以知道些好吃的菜</li><li>知道 所有 正在进行的 第二课堂讲座 的 消息 （快问她！</li><li>并且 只要有 新出来的 第二课堂讲座 她就会@全体</li><li>鉴于学校政策，每日一报凌晨自动打卡功能临时关闭了（ 虽然感觉马上又会要用到</li><li>有点 homo 和 小坏</li></ol></blockquote></blockquote><h3 id="使用前所需的运行环境："><a href="#使用前所需的运行环境：" class="headerlink" title="使用前所需的运行环境："></a>使用前所需的运行环境：</h3><blockquote><ol><li>你需要一个Python的开发环境 以及 MySQL云/本地数据库服务器</li><li>requirements 内的必要运行库</li><li>go-cqhttp: 用来监听QQ的HTTP服务器 (如果你想扩展更多功能的话，可以参照它的官方文档)</li><li>符合你自己谷歌游览器的驱动版本 –&gt; chromedriver ( 这里已经提供了一个适合Window系统的 谷歌游览器driver )</li></ol></blockquote><h5 id="还是不懂运行环境的安装？-—-gt-没关系-这里给你详细说明："><a href="#还是不懂运行环境的安装？-—-gt-没关系-这里给你详细说明：" class="headerlink" title="还是不懂运行环境的安装？ —-&gt; 没关系 这里给你详细说明："></a>还是不懂运行环境的安装？ —-&gt; 没关系 这里给你详细说明：</h5><ol><li><p>Python安装 和MySQL数据库搭建 —&gt; 不解释了</p></li><li><p>requirements内运行库安装：<br>打开你的cmd / Linux终端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure></li><li><p>go-cqhttp:<br>这里简要介绍一下 该项目是使用Python的 套接字/Requests 实现监听 <code>127.0.0.1:5701</code> 端口 来控制QQ机器人</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 基于go-cqhttp 的 Socket 通信</span><br><span class="line">ListenSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">ListenSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">ListenSocket.bind((&#x27;127.0.0.1&#x27;, 5701))</span><br><span class="line">ListenSocket.listen(100)</span><br></pre></td></tr></table></figure><p>go-cqhtt下载: <a href="https://docs.go-cqhttp.org/">https://docs.go-cqhttp.org/</a><br>如果你想扩展<code>妃爱酱</code>的功能，或者自定义更多的新花样的话 或者建立一个属于你自己的QQ机器人的话 可以具体用法参照文档：<a href="https://docs.go-cqhttp.org/api">go-cqhtt官方文档</a>  </p></li><li><p>chromedriver:<br>首先，你需要确认你的谷歌游览器版本-以及系统：</p><blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/e75628139e828d2990465e0a2d8ef892.jpeg"><br>然后去 <a href="https://registry.npmmirror.com/binary.html?path=chromedriver/">chromedriver国内镜像</a> 下载适合你系统 和 谷歌版本的 谷歌驱动</p></blockquote></li></ol><p><mark><strong><big><font face="courier New" color="#1E90FF">好！正式进入使用介绍：<big></big></font><strong></strong></big></strong></mark></p><h2 id="使用教程："><a href="#使用教程：" class="headerlink" title="使用教程："></a>使用教程：</h2><ol><li><p>在<code>API.py</code>内配置 校园账号-用户池 写入所有你想要自动打卡的用户信息（会自动汇报完账号池内所有的账号）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 二工大 用户池 ---------------&gt; 字面意思 那个 假期 / 在校 （其实都无所谓的）</span><br><span class="line">SSPU_AccountData_Holiday = [</span><br><span class="line">    &#123;&quot;账号&quot;: &quot;20211145140&quot;, &quot;密码&quot;: &quot;hengheng@1145141919810&quot;,</span><br><span class="line">     &quot;地址&quot;: [&quot;上海&quot;, &quot;上海市&quot;, &quot;浦东新区&quot;, &quot;金海路2360号上海第二工业大学&quot;]&#125;]</span><br><span class="line"></span><br><span class="line">SSPU_AccountData_SchoolDay = [</span><br><span class="line">    &#123;&quot;账号&quot;: &quot;20211145140&quot;, &quot;密码&quot;: &quot;hengheng@1145141919810&quot;,</span><br><span class="line">     &quot;地址&quot;: [&quot;上海&quot;, &quot;上海市&quot;, &quot;浦东新区&quot;, &quot;金海路2360号上海第二工业大学&quot;]&#125;]</span><br></pre></td></tr></table></figure></li><li><p>同样, 在<code>API.py</code>里头 指定QQ内 每日汇报的QQ群:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQ_Group = xxxxxxx</span><br></pre></td></tr></table></figure></li><li><p>在本地/服务器搭建好 MySQL数据库环境 —-&gt; 这里存储了 能够使用<code>妃爱酱</code>的使用权限 的 用户/群<br>这里使用的是MySQL语言，创建数据库结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table QQ_Num (number BIGINT, msg_type VARCHAR(20));</span><br></pre></td></tr></table></figure><p>然后 在 你的MySQL相关数据库的表内加入 你想要的QQ用户   </p><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p><code>number</code>: QQ群号/个人QQ号<br><code>msg_type</code>: <code>private</code> ( 个人QQ )/ <code>group</code> ( QQ群 )          </p></li></ol><p>然后在<code>AuthorityDB_mysql.py</code>内 配置你的数据库接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你的数据库和表名</span></span><br><span class="line">db = <span class="string">&quot;&quot;</span></span><br><span class="line">db_table = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>· 注：这里默认是使用本地数据库接口，若你使用的是云服务器的话可以自行配置 Host 成你的云数据库服务器的IP</p><ol start="4"><li><p>这时候 可以开启go-cqhttp服务器了。<br> 配置好go-cqhttp设置, 然后去你的终端</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-cqhttp</span><br></pre></td></tr></table></figure></li><li><p>设置凌晨自动打卡 + 每日早自动汇报签到结果<br> 如果你是Linux 或者 MacOS系统的话, 推荐使用<code>crontab</code>:<br> 在你的Linux终端：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p> 设置你的 crontab 任务：<code>SSPU_AutoCheck.py</code> 和 <code>report_Server.py</code> 和 <code>Lec_second_class.py</code><br> （crontab 语法）</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每五分钟执行   */5 * * * *</span><br><span class="line">每小时执行     0 * * * *</span><br><span class="line">每天执行       0 0 * * *</span><br><span class="line">每周执行       0 0 * * 0</span><br><span class="line">每月执行       0 0 1 * *</span><br><span class="line">每年执行       0 0 1 1 *</span><br></pre></td></tr></table></figure><p> 如果你不想自己设置的话，也可以用下面的：    </p><p> 进入 crontab 定时管理  设定一个log 重定向你的脚本到这个log上用于接收执行日志 (注：鉴于学校政策，每日一报凌晨自动打卡功能临时关闭了（ 虽然感觉马上又会要用到)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#2 1-10/1 * * * /usr/bin/python3 /home/pi/Python_Crawler/SSPU_AutoCheck.py &gt;&gt; ~/dailyReport.log</span><br><span class="line">#30 7 * * * /usr/bin/python3 /home/pi/Python_Crawler/SSPU_AutoCheck.py &gt;&gt; ~/dailyReport.log</span><br><span class="line">#30 4 * * * /usr/bin/python3 /home/pi/Python_Crawler/SSPU_AutoCheck.py &gt;&gt; ~/dailyReport.log</span><br><span class="line">#*/10 5 * * * /usr/bin/python3 /home/pi/Python_Crawler/SSPU_AutoCheck.py &gt;&gt; ~/dailyReport.log</span><br><span class="line">#*/10 6 * * * /usr/bin/python3 /home/pi/Python_Crawler/SSPU_AutoCheck.py &gt;&gt; ~/dailyReport.log</span><br><span class="line">#*/10 7 * * * /usr/bin/python3 /home/pi/Python_Crawler/SSPU_AutoCheck.py &gt;&gt; ~/dailyReport.log</span><br><span class="line">#0 7 * * * /usr/bin/python3 /home/pi/Python_Crawler/report_Server.py</span><br><span class="line">#15 7 * * * /usr/bin/python3 /home/pi/Python_Crawler/report_Server.py</span><br><span class="line">* */2 * * * /usr/bin/python3 /home/pi/Python_Crawler/Lec_second_class.py</span><br></pre></td></tr></table></figure><p> Q: 你问为什么 要设置那么多脚本执行？<br> A: 因为我用是树莓派啊。。。所以脚本执行有时候会卡死，为了安全起见当然多设几个 （ 反正学校又没有反爬</p></li><li><p>开启go-cqhttp 服务器，打开终端执行界面 cd 到该项目文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyhon3 main.py</span><br></pre></td></tr></table></figure></li></ol><h2 id="自定义你的功能"><a href="#自定义你的功能" class="headerlink" title="自定义你的功能"></a>自定义你的功能</h2><ol><li>图片API <code>API.py</code>  你可以在这里定义属于你自己的 se (HO) tu (MO) 连接</li><li>如果你不是二工大的学生 但是也想用这个的话  你可以在 <code>SSPU_AutoCheck.py</code>  里编写 你的自动打卡程序</li><li>如果你想给妃爱酱自定义更多的 talk 的话 你可以在 <code>continue_Server.py</code> 里的 <code>def talk(self, recv, num): </code>方法里加入 你想要的 感兴趣content</li><li><code>continue_Server.py</code> 也包含了现有的机器人的命令指令方法 你可以根据你自己的需求来增加或者修改，甚至可以完全自定义成属于你自己的QQ机器人</li><li>如果你觉得使用数据库来进行权限赋予 太麻烦， 你可以将 <code>self.QQ_num</code> 和 <code>self.QQ_numType</code> 直接改成你想要的 QQ和QQ类型，参数详见上方数据库建立的那两个</li><li>如果你是树莓派（或者其他嵌入式处理器）并且想通过QQ实现一些建议的物联网联动，你参考IO控制文件夹 和 已有的开灯关灯命令。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenCV】 在Pycharm + anaconda环境下使用摄像头进行人脸识别检测（训练识别出多个人脸） - 附完整Python代码</title>
      <link href="/2022/09/02/%E3%80%90OpenCV%E3%80%91-%E5%9C%A8Pycharm-anaconda%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E8%BF%9B%E8%A1%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8B%EF%BC%88%E8%AE%AD%E7%BB%83%E8%AF%86%E5%88%AB%E5%87%BA%E5%A4%9A%E4%B8%AA%E4%BA%BA%E8%84%B8%EF%BC%89-%E9%99%84%E5%AE%8C%E6%95%B4Python%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/09/02/%E3%80%90OpenCV%E3%80%91-%E5%9C%A8Pycharm-anaconda%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E8%BF%9B%E8%A1%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8B%EF%BC%88%E8%AE%AD%E7%BB%83%E8%AF%86%E5%88%AB%E5%87%BA%E5%A4%9A%E4%B8%AA%E4%BA%BA%E8%84%B8%EF%BC%89-%E9%99%84%E5%AE%8C%E6%95%B4Python%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><ol><li>步骤：<br>样本收集 —-&gt; 训练 —-&gt; 摄像头预测检验</li><li>准备模块：OpenCV ， Numpy</li></ol><hr><h1 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h1><p>将 Pycharm 接上 Anaconda 环境的解释器<br>（ 我这里是使用了 Anaconda 环境下 自建的 tensorflow 虚拟环境 ）<br><img src="https://img-blog.csdnimg.cn/27958cd9f4cf44b5943632879246065a.png#pic_center" alt="如图所示"></p><p>注：记得在 Anaconda Prompt (Anaconda3) 里 提前安装好 opencv 和 opencv-contrib 模块</p><p><br><br><br></p><hr><h1 id="2-样本收集"><a href="#2-样本收集" class="headerlink" title="2.样本收集"></a>2.样本收集</h1><p>使用电脑摄像头进行样本采集<br>我这里分别采集2个人的样本 （各1000张）</p><p>注：</p><ol><li>我这里是将样本数据采集到 “. ./03_DataSet/01_Grocery” 目录下，你可以根据需要自行更改路径</li><li>样本名称我这里统一使用了 image + 序号 .jpg 进行命名，方便后续训练时候进行遍历操作</li></ol><p>第一个人：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)  <span class="comment"># 打开摄像头0 / 若为“xxxx.mp4”则为视频文件</span></span><br><span class="line">isOpened = cap.isOpened()  <span class="comment"># 判断是否打开/ 为后续提供条件语句</span></span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">width = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">height = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line"><span class="built_in">print</span>(fps, width, height)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> isOpened:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1000</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    (flag, frame) = cap.read()  <span class="comment"># flag是否读取成功, frame为图片内容</span></span><br><span class="line">    fileName = <span class="string">&quot;image&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        cv2.imwrite(<span class="string">f&quot;../03_DataSet/01_Grocery/<span class="subst">&#123;fileName&#125;</span>&quot;</span>, frame, [cv2.IMWRITE_JPEG_QUALITY, <span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&quot;Hello!&quot;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;END&quot;</span>)</span><br></pre></td></tr></table></figure><p>第二个人：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)  <span class="comment"># 打开摄像头0 / 若为“xxxx.mp4”则为视频文件</span></span><br><span class="line">isOpened = cap.isOpened()  <span class="comment"># 判断是否打开/ 为后续提供条件语句</span></span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">width = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">height = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line"><span class="built_in">print</span>(fps, width, height)</span><br><span class="line"></span><br><span class="line">i = <span class="number">1000</span></span><br><span class="line"><span class="keyword">while</span> isOpened:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2000</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    (flag, frame) = cap.read()  <span class="comment"># flag是否读取成功, frame为图片内容</span></span><br><span class="line">    fileName = <span class="string">&quot;image&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        cv2.imwrite(<span class="string">f&quot;../03_DataSet/01_Grocery/<span class="subst">&#123;fileName&#125;</span>&quot;</span>, frame, [cv2.IMWRITE_JPEG_QUALITY, <span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&quot;Hello!&quot;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;END&quot;</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="3-训练"><a href="#3-训练" class="headerlink" title="3.训练"></a>3.训练</h1><p>简述步骤：</p><ol><li>载入OpenCV自带的 haarcascade_frontalface_default.xml 分类器方便检测出 人脸区域</li><li>samples_and_labels()函数：用于获取图像的像素数据 以及 给他们分别附上标签 方便后续进行监督学习（这里说明一下：1.path是根据上述的样本所在路径设立的，如果样本在别处，请在这里修改成你自己的路径；）</li><li>使用opencv相关库中的 face模块的 LBPH算法进行训练</li></ol><p>Notes：</p><ol><li>samples_and_labels()函数实现包含了：读取图片 —&gt; 灰度转换 —&gt; 用face_xml分类器框出人脸区域 —&gt; 在之中收集 图片像素数据 并分别附上 人名标签（1是一个人的图片数据，2是另一个人的图片数据。。。如此类推）—&gt; 返回人脸数据</li><li>我在1<del>1000 附上了 标签1   1001</del>2000 附上标签2  （ 2个人 ）</li><li>train函数： 参数1 为人脸像素数据  参数2 为对应人脸标签</li><li>将数据保存到本目录下的 jackData_trainner.yml 文件内<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">face_xml = cv2.CascadeClassifier(<span class="string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">samples_and_labels</span>():</span></span><br><span class="line">    faceData = []</span><br><span class="line">    ids = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2000</span>):</span><br><span class="line">        path = <span class="string">&quot;../03_DataSet/01_Grocery/image&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        img = cv2.imread(path)</span><br><span class="line">        imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        faces = face_xml.detectMultiScale(imgGray)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">            <span class="keyword">if</span> i &lt;= <span class="number">1000</span>:</span><br><span class="line">                ids.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ids.append(<span class="number">2</span>)</span><br><span class="line">            faceData.append(imgGray[y:y+h, x:x+w])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> faceData, ids</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(faces, ids) = samples_and_labels()</span><br><span class="line"><span class="built_in">print</span>(faces, ids)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Training...&quot;</span>)</span><br><span class="line">jackData = cv2.face.LBPHFaceRecognizer_create()  <span class="comment"># 创建LBPH</span></span><br><span class="line"></span><br><span class="line">jackData.train(faces, np.array(ids))  <span class="comment"># 参数1 为人脸像素数据  参数2 为对应人脸标签</span></span><br><span class="line">jackData.save(<span class="string">&quot;jackData_trainner.yml&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finish&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><p><br><br><br></p><hr><h1 id="4-摄像头人脸检测"><a href="#4-摄像头人脸检测" class="headerlink" title="4.摄像头人脸检测"></a>4.摄像头人脸检测</h1><p>说明一下：</p><ol><li>names收集的人名 对应着 训练模型中 ids-1</li><li>confidence变量的 数值越大 则置信度越低（就是越不像）</li><li>  if ord(“q”) == cv2.waitKey(1):<pre><code> break </code></pre>   这个代码 功能为 按下q 键 退出摄像头检测</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">recog = cv2.face.LBPHFaceRecognizer_create()</span><br><span class="line">recog.read(<span class="string">&quot;jackData_trainner.yml&quot;</span>)</span><br><span class="line">face_xml = cv2.CascadeClassifier(<span class="string">&quot;haarcascade_frontalface_default.xml&quot;</span>)</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;name2&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">isOpened = cap.isOpened()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(isOpened):</span><br><span class="line">    (flag, frame) = cap.read()</span><br><span class="line">    frameGray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    face = face_xml.detectMultiScale(frameGray, <span class="number">1.4</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x, y, w, h) <span class="keyword">in</span> face:</span><br><span class="line">        cv2.rectangle(frame, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>), <span class="number">2</span>, cv2.LINE_AA)</span><br><span class="line">        ids, confidence = recog.predict(frameGray[y:y+h, x:x+w])</span><br><span class="line">        <span class="built_in">print</span>(confidence)</span><br><span class="line">        <span class="keyword">if</span> confidence &gt; <span class="number">70</span>:</span><br><span class="line">            cv2.putText(frame, <span class="string">&quot;Who are you?&quot;</span>, (x, y-<span class="number">8</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cv2.putText(frame, names[ids-<span class="number">1</span>], (x, y-<span class="number">8</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&quot;test&quot;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>) == cv2.waitKey(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="最后附上效果图片："><a href="#最后附上效果图片：" class="headerlink" title="最后附上效果图片："></a>最后附上效果图片：</h1><p><img src="https://img-blog.csdnimg.cn/a2b469215dc34d6dad3b8f3a3ad6b6a8.png#pic_center" alt="在这里插入图片描述"></p><p>附：完整Python代码下载 <a href="https://download.csdn.net/download/Panzer_Jack/85609567">https://download.csdn.net/download/Panzer_Jack/85609567</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】3. 图[笔记]</title>
      <link href="/2022/08/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%913-%E5%9B%BE-%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%913-%E5%9B%BE-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><ol><li>数据结构：图 的操作集 C/C++代码实现</li></ol><hr><h1 id="1-图-邻接矩阵"><a href="#1-图-邻接矩阵" class="headerlink" title="1. 图 - 邻接矩阵"></a>1. 图 - 邻接矩阵</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define MaxVertexNum 100        // 最大顶点数</span></span><br><span class="line">typedef <span class="built_in">int</span> WeightType;         // 权值</span><br><span class="line">typedef <span class="built_in">int</span> Vertex;             // 顶点</span><br><span class="line">typedef <span class="built_in">int</span> DataType;           // 数据</span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;              // &lt; V1, V2 &gt; 有向边</span><br><span class="line">    WeightType Weight;          // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    <span class="built_in">int</span> Nv;                     // 顶点数</span><br><span class="line">    <span class="built_in">int</span> Ne;                     // 边数</span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum];   // 邻接矩阵</span><br><span class="line">    DataType Data[MaxVertexNum];                // 数据</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line">MGraph CreateGraph(<span class="built_in">int</span> VertexNum);          // 初始化图</span><br><span class="line">void InsertEdge(MGraph Graph, Edge E);      // 插入边</span><br><span class="line">MGraph BuildGraph();                        // 建图</span><br><span class="line"></span><br><span class="line">MGraph CreateGraph(<span class="built_in">int</span> VertexNum)</span><br><span class="line">&#123;</span><br><span class="line">    Vertex v, w;</span><br><span class="line">    MGraph Graph = new struct GNode;</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;VertexNum; v++)</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>; w&lt;VertexNum; w++)  Graph-&gt;G[v][w] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertEdge(MGraph Graph, Edge E)</span><br><span class="line">&#123;</span><br><span class="line">    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;</span><br><span class="line">    // 若为无向图，需要插入下面那行</span><br><span class="line">    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MGraph BuildGraph()</span><br><span class="line">&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="built_in">int</span> Nv;</span><br><span class="line">    cin &gt;&gt; Nv;</span><br><span class="line">    Graph = CreateGraph(Nv);</span><br><span class="line">    cin &gt;&gt; Graph-&gt;Ne;</span><br><span class="line">    <span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        E = new struct ENode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;Graph-&gt;Ne; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; E-&gt;V1 &gt;&gt; E-&gt;V2 &gt;&gt; E-&gt;Weight;</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="2-图-邻接表"><a href="#2-图-邻接表" class="headerlink" title="2. 图 - 邻接表"></a>2. 图 - 邻接表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define MaxVertexNum 100        // 最大顶点数</span></span><br><span class="line">typedef <span class="built_in">int</span> Vertex;             // 顶点</span><br><span class="line">typedef <span class="built_in">int</span> WeightType;         // 边的权值</span><br><span class="line">typedef <span class="built_in">int</span> DataType;           // 数据</span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;          // 有向边 &lt;V1, V2&gt;</span><br><span class="line">    WeightType Weight;      // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">// 邻接点</span><br><span class="line">typedef struct AdjVNode *PtrToAdjVNode; </span><br><span class="line">struct AdjVNode&#123;</span><br><span class="line">    Vertex ADjV;            // 邻接点下标</span><br><span class="line">    WeightType Weight;      // 边权重</span><br><span class="line">    PtrToAdjVNode Next;     // 指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 顶点表头结点</span><br><span class="line">typedef struct VNode&#123;</span><br><span class="line">    PtrToAdjVNode FirstEdge;    // 边表头结点</span><br><span class="line">    DataType Data;              // 数据</span><br><span class="line">&#125;AdjList[MaxVertexNum];         // 邻接表类型</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    <span class="built_in">int</span> Nv;                     // 顶点数</span><br><span class="line">    <span class="built_in">int</span> Ne;                     // 边数</span><br><span class="line">    AdjList G;                  // 邻接表</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode LGraph;      // 邻接表-图类型</span><br><span class="line"></span><br><span class="line">// 操作集</span><br><span class="line">LGraph CreateGraph(<span class="built_in">int</span> VertexNum);      // 初始化图</span><br><span class="line">void InsertEdge(LGraph Graph, Edge E);  // 插入边</span><br><span class="line">LGraph BuildGraph();                    // 建图</span><br><span class="line"></span><br><span class="line">// 操作集实现</span><br><span class="line">LGraph CreateGraph(<span class="built_in">int</span> VertexNum)</span><br><span class="line">&#123;</span><br><span class="line">    Vertex v, w;</span><br><span class="line">    LGraph Graph = new struct GNode;</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;Graph-&gt;Nv; v++)  Graph-&gt;G[v].FirstEdge = NULL;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertEdge(LGraph Graph, Edge E)</span><br><span class="line">&#123;</span><br><span class="line">    PtrToAdjVNode newNode;</span><br><span class="line">    newNode = new struct AdjVNode;</span><br><span class="line">    // 插入 &lt;V1, V2&gt;</span><br><span class="line">    newNode-&gt;ADjV = E-&gt;V2;</span><br><span class="line">    newNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">    newNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;  // 旧表头接在新结点的后面</span><br><span class="line">    Graph-&gt;G[E-&gt;V1].FirstEdge = newNode;        // 新结点成为新的表头</span><br><span class="line"></span><br><span class="line">    // 插入 &lt;V2, V1&gt;   &lt;---- 无向图</span><br><span class="line">    newNode = new struct AdjVNode;</span><br><span class="line">    newNode-&gt;ADjV = E-&gt;V1;</span><br><span class="line">    newNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">    newNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;  // 旧表头接在新结点的后面</span><br><span class="line">    Graph-&gt;G[E-&gt;V2].FirstEdge = newNode;        // 新结点成为新的表头</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LGraph BuildGraph()</span><br><span class="line">&#123;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="built_in">int</span> Nv;</span><br><span class="line">    cin &gt;&gt; Nv;</span><br><span class="line">    Graph = CreateGraph(Nv);</span><br><span class="line">    cin &gt;&gt; Graph-&gt;Ne;</span><br><span class="line">    <span class="keyword">if</span>(Graph-&gt;Ne)</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;Graph-&gt;Ne; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            E = new struct ENode;</span><br><span class="line">            cin &gt;&gt; E-&gt;V1 &gt;&gt; E-&gt;V2 &gt;&gt; E-&gt;Weight;</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="3-DFS-深度优先搜索"><a href="#3-DFS-深度优先搜索" class="headerlink" title="3. DFS - 深度优先搜索"></a>3. DFS - 深度优先搜索</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">// DFS 深度优先搜索 算法</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> Visited[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define MaxVertexNum 100        // 最大顶点数</span></span><br><span class="line">typedef <span class="built_in">int</span> Vertex;             // 顶点</span><br><span class="line">typedef <span class="built_in">int</span> WeightType;         // 边的权值</span><br><span class="line">typedef <span class="built_in">int</span> DataType;           // 数据</span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;          // 有向边 &lt;V1, V2&gt;</span><br><span class="line">    WeightType Weight;      // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">// 邻接点</span><br><span class="line">typedef struct AdjVNode *PtrToAdjVNode; </span><br><span class="line">struct AdjVNode&#123;</span><br><span class="line">    Vertex ADjV;            // 邻接点下标</span><br><span class="line">    WeightType Weight;      // 边权重</span><br><span class="line">    PtrToAdjVNode Next;     // 指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 顶点表头结点</span><br><span class="line">typedef struct VNode&#123;</span><br><span class="line">    PtrToAdjVNode FirstEdge;    // 边表头结点</span><br><span class="line">    DataType Data;              // 数据</span><br><span class="line">&#125;AdjList[MaxVertexNum];         // 邻接表类型</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    <span class="built_in">int</span> Nv;                     // 顶点数</span><br><span class="line">    <span class="built_in">int</span> Ne;                     // 边数</span><br><span class="line">    AdjList G;                  // 邻接表</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode LGraph;      // 邻接表-图类型</span><br><span class="line"></span><br><span class="line">// 操作集</span><br><span class="line">void Visit(Vertex V);</span><br><span class="line">void DFS(LGraph Graph, Vertex V);</span><br><span class="line"></span><br><span class="line">void Visit(Vertex V)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This Vertex is: &quot;</span> &lt;&lt; V &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(LGraph Graph, Vertex V, void (*Visit)(Vertex))</span><br><span class="line">&#123;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    Visit(V);</span><br><span class="line">    Visited[V] = true;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next)</span><br><span class="line">        <span class="keyword">if</span>(!Visited[W-&gt;ADjV])  DFS(Graph, W-&gt;ADjV, Visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="4-BFS-广度优先搜索"><a href="#4-BFS-广度优先搜索" class="headerlink" title="4. BFS - 广度优先搜索"></a>4. BFS - 广度优先搜索</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">// BFS 广度优先搜索 算法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define MaxVertexNum 100        // 最大顶点数</span></span><br><span class="line">typedef <span class="built_in">int</span> WeightType;         // 权值</span><br><span class="line">typedef <span class="built_in">int</span> Vertex;             // 顶点</span><br><span class="line">typedef <span class="built_in">int</span> DataType;           // 数据</span><br><span class="line"><span class="built_in">bool</span> Visited[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;              // &lt; V1, V2 &gt; 有向边</span><br><span class="line">    WeightType Weight;          // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    <span class="built_in">int</span> Nv;                     // 顶点数</span><br><span class="line">    <span class="built_in">int</span> Ne;                     // 边数</span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum];   // 邻接矩阵</span><br><span class="line">    DataType Data[MaxVertexNum];                // 数据</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line">// 操作集</span><br><span class="line"><span class="built_in">bool</span> IsEdge(MGraph Graph, Vertex V, Vertex W);</span><br><span class="line">void BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex));</span><br><span class="line">void Visit(Vertex V);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Visit(Vertex V)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This Vertex is: &quot;</span> &lt;&lt; V &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> IsEdge(MGraph Graph, Vertex V, Vertex W)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (Graph-&gt;G[V][W]&gt;<span class="number">0</span>?true:false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex))</span><br><span class="line">&#123;</span><br><span class="line">    queue &lt;Vertex&gt; Q;</span><br><span class="line">    Vertex V, W;</span><br><span class="line"></span><br><span class="line">    Visit(S);</span><br><span class="line">    Visited[S] = true;</span><br><span class="line">    Q.push(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        V = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++)</span><br><span class="line">            <span class="keyword">if</span>(!Visited[W] &amp;&amp; IsEdge(Graph, V, W))</span><br><span class="line">            &#123;</span><br><span class="line">                Visit(W);</span><br><span class="line">                Visited[W] = true;</span><br><span class="line">                Q.push(W);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="5-例题-六度空间-BFS算法邻接矩阵图"><a href="#5-例题-六度空间-BFS算法邻接矩阵图" class="headerlink" title="5. 例题 - 六度空间 ( BFS算法邻接矩阵图 )"></a>5. 例题 - 六度空间 ( BFS算法邻接矩阵图 )</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">// 例题：六度空间 ---&gt; BFS算法 - 邻接矩阵图</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> ENode[<span class="number">1001</span>][<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> Nv, Ne;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> BFS(<span class="built_in">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    queue &lt;<span class="built_in">int</span>&gt; Q;</span><br><span class="line">    <span class="built_in">bool</span> visited[<span class="number">1001</span>] = &#123;false&#125;;</span><br><span class="line">    Q.push(v);</span><br><span class="line">    <span class="built_in">int</span> cnt=<span class="number">0</span>, level=<span class="number">0</span>, last=v, tail=v;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        v = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> w=<span class="number">1</span>; w&lt;=Nv; w++)</span><br><span class="line">            <span class="keyword">if</span>(!visited[w] &amp;&amp; ENode[v][w])  Q.push(w), cnt++, tail = w, visited[w] = true;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        // cout &lt;&lt; <span class="string">&quot;V: &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;Level:&quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; tail &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(v == last)  level++, last = tail;</span><br><span class="line">        <span class="keyword">if</span>(level == <span class="number">6</span>)  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; Nv &gt;&gt; Ne;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=Ne; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        ENode[v][w] = <span class="number">1</span>;</span><br><span class="line">        ENode[w][v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> v=<span class="number">1</span>; v&lt;=Nv; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> tmp = BFS(v)/(Nv*<span class="number">1.0</span>)*<span class="number">100</span>;</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        printf(<span class="string">&quot;%.2f%\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="6-无权图的最短路径问题"><a href="#6-无权图的最短路径问题" class="headerlink" title="6. 无权图的最短路径问题"></a>6. 无权图的最短路径问题</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 邻接矩阵 - 无权图的单源最短路算法</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> MaxVertexNum <span class="number">100</span>        // 最大顶点数</span><br><span class="line">typedef int WeightType;         // 权值</span><br><span class="line">typedef int Vertex;             // 顶点</span><br><span class="line">typedef int DataType;           // 数据</span><br><span class="line"></span><br><span class="line">vector &lt;int&gt; dist(MaxVertexNum, -<span class="number">1</span>);     // 存储路径, 并初始化为 -<span class="number">1</span>      </span><br><span class="line">vector &lt;int&gt; path(MaxVertexNum);         // 存储路径长度</span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;              // &lt; V1, V2 &gt; 有向边</span><br><span class="line">    WeightType Weight;          // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    int Nv;                     // 顶点数</span><br><span class="line">    int Ne;                     // 边数</span><br><span class="line">    WeightType G<span class="selector-attr">[MaxVertexNum]</span><span class="selector-attr">[MaxVertexNum]</span>;   // 邻接矩阵</span><br><span class="line">    DataType Data<span class="selector-attr">[MaxVertexNum]</span>;                // 数据</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接矩阵 - 无权图的单源最短路算法 */</span></span><br><span class="line">void Unweighted(MGraph Graph, Vertex V);</span><br><span class="line"></span><br><span class="line">void Unweighted(MGraph Graph, Vertex V)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;Vertex&gt; <span class="selector-tag">Q</span>;</span><br><span class="line">    dist<span class="selector-attr">[V]</span> = <span class="number">0</span>, path<span class="selector-attr">[V]</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="selector-tag">Q</span><span class="selector-class">.push</span>(V);</span><br><span class="line">    while(!<span class="selector-tag">Q</span><span class="selector-class">.empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        V = <span class="selector-tag">Q</span><span class="selector-class">.front</span>();</span><br><span class="line">        <span class="selector-tag">Q</span><span class="selector-class">.pop</span>();</span><br><span class="line">        for(Vertex W=<span class="number">0</span>; W &lt; Graph-&gt;Nv; W++)</span><br><span class="line">            if(Graph-&gt;G<span class="selector-attr">[V]</span><span class="selector-attr">[W]</span> &amp;&amp; dist<span class="selector-attr">[W]</span> == -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist<span class="selector-attr">[W]</span> = dist<span class="selector-attr">[V]</span> + <span class="number">1</span>;</span><br><span class="line">                path<span class="selector-attr">[W]</span> = V;</span><br><span class="line">                <span class="selector-tag">Q</span><span class="selector-class">.push</span>(W);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="7-邻接矩阵-有权图的单源最短路算法-Dijkstra算法"><a href="#7-邻接矩阵-有权图的单源最短路算法-Dijkstra算法" class="headerlink" title="7. 邻接矩阵 - 有权图的单源最短路算法 - Dijkstra算法"></a>7. 邻接矩阵 - 有权图的单源最短路算法 - Dijkstra算法</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 邻接矩阵 - 有权图的单源最短路算法 - Dijkstra算法</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> MaxVertexNum <span class="number">100</span>        // 最大顶点数</span><br><span class="line"><span class="selector-id">#define</span> Maxdist <span class="number">100000000</span>        // 最大顶点数</span><br><span class="line">typedef int WeightType;         // 权值</span><br><span class="line">typedef int Vertex;             // 顶点</span><br><span class="line">typedef int DataType;           // 数据</span><br><span class="line"></span><br><span class="line">vector &lt;int&gt; dist(MaxVertexNum, -<span class="number">1</span>);              // 存储路径, 并初始化为 -<span class="number">1</span>      </span><br><span class="line">vector &lt;int&gt; path(MaxVertexNum, Maxdist);         // 存储路径长度, 并初始化为 Maxdist</span><br><span class="line">vector &lt;bool&gt; collected(MaxVertexNum, false);     // 判断该Vertex是否收集, 并初始化为 false</span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;              // &lt; V1, V2 &gt; 有向边</span><br><span class="line">    WeightType Weight;          // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    int Nv;                     // 顶点数</span><br><span class="line">    int Ne;                     // 边数</span><br><span class="line">    WeightType G<span class="selector-attr">[MaxVertexNum]</span><span class="selector-attr">[MaxVertexNum]</span>;   // 邻接矩阵</span><br><span class="line">    DataType Data<span class="selector-attr">[MaxVertexNum]</span>;                // 数据</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接矩阵 - Dijkstra算法 */</span></span><br><span class="line">void Dijkstra(MGraph Graph, Vertex V);</span><br><span class="line"></span><br><span class="line">void Dijkstra(MGraph Graph, Vertex V)</span><br><span class="line">&#123;</span><br><span class="line">    dist<span class="selector-attr">[V]</span> = <span class="number">0</span>, path<span class="selector-attr">[V]</span> = -<span class="number">1</span>;</span><br><span class="line">    collected<span class="selector-attr">[V]</span> = true;</span><br><span class="line">    for(Vertex W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++)</span><br><span class="line">        if(Graph-&gt;G<span class="selector-attr">[V]</span><span class="selector-attr">[W]</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist<span class="selector-attr">[W]</span> = dist<span class="selector-attr">[V]</span> + Graph-&gt;G<span class="selector-attr">[V]</span><span class="selector-attr">[W]</span>;</span><br><span class="line">            path<span class="selector-attr">[W]</span> = V;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    while(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for(Vertex W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++)</span><br><span class="line">            if(V != W &amp;&amp; !collected<span class="selector-attr">[W]</span>)  V = min(dist<span class="selector-attr">[W]</span>, Maxdist);</span><br><span class="line">            else  V = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        if(!V)  break;</span><br><span class="line">        </span><br><span class="line">        collected<span class="selector-attr">[V]</span> = true;</span><br><span class="line">        </span><br><span class="line">        for(Vertex W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++)</span><br><span class="line">            if(Graph-&gt;G<span class="selector-attr">[V]</span><span class="selector-attr">[W]</span> &amp;&amp; !collected<span class="selector-attr">[W]</span>)</span><br><span class="line">                if(dist<span class="selector-attr">[V]</span> + Graph-&gt;G<span class="selector-attr">[V]</span><span class="selector-attr">[W]</span> &lt; dist<span class="selector-attr">[W]</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dist<span class="selector-attr">[W]</span> = dist<span class="selector-attr">[V]</span> + Graph-&gt;G<span class="selector-attr">[V]</span><span class="selector-attr">[W]</span>;</span><br><span class="line">                    path<span class="selector-attr">[W]</span> = V;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="8-邻接矩阵-有权图的多源最短路算法-Floyd算法"><a href="#8-邻接矩阵-有权图的多源最短路算法-Floyd算法" class="headerlink" title="8. 邻接矩阵 - 有权图的多源最短路算法 - Floyd算法"></a>8. 邻接矩阵 - 有权图的多源最短路算法 - Floyd算法</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 邻接矩阵 - 有权图的多源最短路算法 - Floyd算法</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> MaxVertexNum <span class="number">100</span>        // 最大顶点数</span><br><span class="line"><span class="selector-id">#define</span> Maxdist <span class="number">100000000</span>        // 最大顶点数</span><br><span class="line">typedef int WeightType;         // 权值</span><br><span class="line">typedef int Vertex;             // 顶点</span><br><span class="line">typedef int DataType;           // 数据</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; dist(MaxVertexNum, vector&lt;int&gt;(MaxVertexNum, <span class="number">0</span>));          // 存储路径长度, 并初始化为 <span class="number">0</span>      </span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; path(MaxVertexNum, vector&lt;int&gt;(MaxVertexNum, -<span class="number">1</span>));         // 存储路径, 并初始化为 -<span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;              // &lt; V1, V2 &gt; 有向边</span><br><span class="line">    WeightType Weight;          // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    int Nv;                     // 顶点数</span><br><span class="line">    int Ne;                     // 边数</span><br><span class="line">    WeightType G<span class="selector-attr">[MaxVertexNum]</span><span class="selector-attr">[MaxVertexNum]</span>;   // 邻接矩阵</span><br><span class="line">    DataType Data<span class="selector-attr">[MaxVertexNum]</span>;                // 数据</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接矩阵 - Floyd算法 */</span></span><br><span class="line">void Floyd(MGraph Graph, Vertex V);</span><br><span class="line"></span><br><span class="line">void Floyd(MGraph Graph, Vertex V)</span><br><span class="line">&#123;</span><br><span class="line">    Vertex <span class="selector-tag">i</span>, j, k;</span><br><span class="line">    for(<span class="selector-tag">i</span>=<span class="number">0</span>; <span class="selector-tag">i</span>&lt;Graph-&gt;Nv; <span class="selector-tag">i</span>++)</span><br><span class="line">        for(j=<span class="number">0</span>; j&lt;Graph-&gt;Nv; j++)</span><br><span class="line">            if(<span class="selector-tag">i</span>!=j)                                                // dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> 初始化为 <span class="number">0</span>, 所以 <span class="selector-tag">i</span>=j对角 均跳过(为默认值<span class="number">0</span>)</span><br><span class="line">                if(Graph-&gt;G<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span>)  dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> = Graph-&gt;G<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span>;    // 若Graph-&gt;G<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> 为 <span class="number">0</span>, 则判定为 无边，因此初始化为Maxdist;</span><br><span class="line">                else  dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> = Maxdist;</span><br><span class="line"></span><br><span class="line">    for(k=<span class="number">0</span>; k&lt;Graph-&gt;Nv; k++)</span><br><span class="line">        for(<span class="selector-tag">i</span>=<span class="number">0</span>; <span class="selector-tag">i</span>&lt;Graph-&gt;Nv; <span class="selector-tag">i</span>++)</span><br><span class="line">            for(j=<span class="number">0</span>; j&lt;Graph-&gt;Nv; j++)</span><br><span class="line">                if(dist<span class="selector-attr">[i]</span><span class="selector-attr">[k]</span> + dist<span class="selector-attr">[k]</span><span class="selector-attr">[j]</span> &lt; dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span>)  dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> = dist<span class="selector-attr">[i]</span><span class="selector-attr">[k]</span> + dist<span class="selector-attr">[k]</span><span class="selector-attr">[j]</span>, path<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="9-例题-哈利·波特的考试-BFS-Floyd-算法"><a href="#9-例题-哈利·波特的考试-BFS-Floyd-算法" class="headerlink" title="9. 例题 - 哈利·波特的考试 ( BFS + Floyd 算法 )"></a>9. 例题 - 哈利·波特的考试 ( BFS + Floyd 算法 )</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 邻接矩阵 - BFS + Floyd 算法</span><br><span class="line"></span><br><span class="line">struct animalTra&#123;</span><br><span class="line">    int Ne;</span><br><span class="line">    int Nv;</span><br><span class="line">    int Weight<span class="selector-attr">[102]</span><span class="selector-attr">[102]</span> = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct animalTra AniTran;</span><br><span class="line"></span><br><span class="line">bool BFS_LT(AniTran Graph)</span><br><span class="line">&#123;</span><br><span class="line">    queue &lt;int&gt; <span class="selector-tag">Q</span>;</span><br><span class="line">    <span class="selector-tag">Q</span><span class="selector-class">.push</span>(<span class="number">1</span>);</span><br><span class="line">    int v;</span><br><span class="line">    bool res = true;</span><br><span class="line">    int checked<span class="selector-attr">[102]</span> = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    checked<span class="selector-attr">[1]</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    while(!<span class="selector-tag">Q</span><span class="selector-class">.empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        v = <span class="selector-tag">Q</span><span class="selector-class">.front</span>();</span><br><span class="line">        <span class="selector-tag">Q</span><span class="selector-class">.pop</span>();</span><br><span class="line">        for(int w=<span class="number">2</span>; w&lt;=Graph<span class="selector-class">.Nv</span>; w++)</span><br><span class="line">            if(Graph<span class="selector-class">.Weight</span><span class="selector-attr">[v]</span><span class="selector-attr">[w]</span> &amp;&amp; !checked<span class="selector-attr">[w]</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="selector-tag">Q</span><span class="selector-class">.push</span>(w);</span><br><span class="line">                checked<span class="selector-attr">[w]</span> = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int w=<span class="number">1</span>; w&lt;=Graph<span class="selector-class">.Nv</span>; w++)</span><br><span class="line">        if(checked<span class="selector-attr">[w]</span> == <span class="number">0</span>)  res = false;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Floyd(AniTran Graph)</span><br><span class="line">&#123;</span><br><span class="line">    vector &lt;vector &lt;int&gt;&gt; dist(<span class="number">102</span>, vector&lt;int&gt;(<span class="number">102</span>, <span class="number">0</span>));</span><br><span class="line">    int res<span class="selector-attr">[102]</span> = &#123;<span class="number">0</span>&#125;, resMin = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">    for(int <span class="selector-tag">i</span>=<span class="number">1</span>; <span class="selector-tag">i</span>&lt;=Graph<span class="selector-class">.Nv</span>; <span class="selector-tag">i</span>++)</span><br><span class="line">        for(int j=<span class="number">1</span>; j&lt;=Graph<span class="selector-class">.Nv</span>; j++)</span><br><span class="line">            if(<span class="selector-tag">i</span>!=j)</span><br><span class="line">                if(Graph<span class="selector-class">.Weight</span><span class="selector-attr">[i]</span><span class="selector-attr">[j]</span>)  dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> = Graph<span class="selector-class">.Weight</span><span class="selector-attr">[i]</span><span class="selector-attr">[j]</span>;</span><br><span class="line">                else dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> = <span class="number">102</span>;</span><br><span class="line">    </span><br><span class="line">    for(int k=<span class="number">1</span>; k&lt;=Graph<span class="selector-class">.Nv</span>; k++)</span><br><span class="line">        for(int <span class="selector-tag">i</span>=<span class="number">1</span>; <span class="selector-tag">i</span>&lt;=Graph<span class="selector-class">.Nv</span>; <span class="selector-tag">i</span>++)</span><br><span class="line">            for(int j=<span class="number">1</span>; j&lt;=Graph<span class="selector-class">.Nv</span>; j++)</span><br><span class="line">                    if(dist<span class="selector-attr">[i]</span><span class="selector-attr">[k]</span> + dist<span class="selector-attr">[k]</span><span class="selector-attr">[j]</span> &lt; dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span>)  dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span> = dist<span class="selector-attr">[i]</span><span class="selector-attr">[k]</span> + dist<span class="selector-attr">[k]</span><span class="selector-attr">[j]</span>;</span><br><span class="line"></span><br><span class="line">    for(int <span class="selector-tag">i</span>=<span class="number">1</span>; <span class="selector-tag">i</span>&lt;=Graph<span class="selector-class">.Nv</span>; <span class="selector-tag">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=<span class="number">1</span>; j&lt;=Graph<span class="selector-class">.Nv</span>; j++)</span><br><span class="line">            res<span class="selector-attr">[i]</span> = max(res<span class="selector-attr">[i]</span>, dist<span class="selector-attr">[i]</span><span class="selector-attr">[j]</span>);</span><br><span class="line">        resMin = min(resMin, res<span class="selector-attr">[i]</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int <span class="selector-tag">i</span>=<span class="number">1</span>; <span class="selector-tag">i</span>&lt;=Graph<span class="selector-class">.Nv</span>; <span class="selector-tag">i</span>++)</span><br><span class="line">        if(resMin == res<span class="selector-attr">[i]</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            cout &lt;&lt; <span class="selector-tag">i</span> &lt;&lt; &#x27; &#x27; &lt;&lt; res<span class="selector-attr">[i]</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="selector-tag">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    AniTran AniGraph;</span><br><span class="line">    cin &gt;&gt; AniGraph<span class="selector-class">.Nv</span> &gt;&gt; AniGraph<span class="selector-class">.Ne</span>;</span><br><span class="line">    for(int <span class="selector-tag">i</span>=<span class="number">1</span>; <span class="selector-tag">i</span>&lt;=AniGraph<span class="selector-class">.Ne</span>; <span class="selector-tag">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        int v, w, weight;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">        AniGraph<span class="selector-class">.Weight</span><span class="selector-attr">[v]</span><span class="selector-attr">[w]</span> = weight;</span><br><span class="line">        AniGraph<span class="selector-class">.Weight</span><span class="selector-attr">[w]</span><span class="selector-attr">[v]</span> = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    if(BFS_LT(AniGraph))  Floyd(AniGraph);</span><br><span class="line">    else cout &lt;&lt; BFS_LT(AniGraph);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="10-邻接矩阵-最小生成树-Prim算法"><a href="#10-邻接矩阵-最小生成树-Prim算法" class="headerlink" title="10. 邻接矩阵 - 最小生成树 - Prim算法"></a>10. 邻接矩阵 - 最小生成树 - Prim算法</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 邻接矩阵 - 最小生成树 - Prim算法</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> Maxdist <span class="number">10000000</span></span><br><span class="line"><span class="selector-id">#define</span> MaxVertexNum <span class="number">100</span>        // 最大顶点数</span><br><span class="line">typedef int WeightType;         // 权值</span><br><span class="line">typedef int Vertex;             // 顶点</span><br><span class="line">typedef int DataType;           // 数据</span><br><span class="line"></span><br><span class="line">vector &lt;int&gt; dist(MaxVertexNum, Maxdist);   // 存储距离, 并初始化为 Maxdist</span><br><span class="line">vector &lt;Vertex&gt; parent(MaxVertexNum, -<span class="number">1</span>);      // 储存父节点, 并初始化为 -<span class="number">1</span></span><br><span class="line">vector &lt;Vertex&gt; MST;                           // 最小生成树</span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;              // &lt; V1, V2 &gt; 有向边</span><br><span class="line">    WeightType Weight;          // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    int Nv;                     // 顶点数</span><br><span class="line">    int Ne;                     // 边数</span><br><span class="line">    WeightType G<span class="selector-attr">[MaxVertexNum]</span><span class="selector-attr">[MaxVertexNum]</span>;   // 邻接矩阵</span><br><span class="line">    DataType Data<span class="selector-attr">[MaxVertexNum]</span>;                // 数据</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line">// 操作集</span><br><span class="line">void initPrim(Vertex s);                         // 初始化 Prim</span><br><span class="line">int FindMinVertex(MGraph Graph, Vertex v);      // 找出dist最小值</span><br><span class="line">void Prim(MGraph Graph, Vertex s);               // Prim算法</span><br><span class="line"></span><br><span class="line">void initPrim(MGraph Graph, Vertex s)</span><br><span class="line">&#123;</span><br><span class="line">    MST<span class="selector-class">.push_back</span>(s), dist<span class="selector-attr">[s]</span> = <span class="number">0</span>;</span><br><span class="line">    for(Vertex w=<span class="number">0</span>; w&lt;Graph-&gt;Nv; w++)</span><br><span class="line">        if(Graph-&gt;G<span class="selector-attr">[s]</span><span class="selector-attr">[w]</span>)  dist<span class="selector-attr">[w]</span> = Graph-&gt;G<span class="selector-attr">[s]</span><span class="selector-attr">[w]</span>, parent<span class="selector-attr">[w]</span> = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindMinVertex(MGraph Graph, Vertex v)</span><br><span class="line">&#123;</span><br><span class="line">    Vertex vMin = -<span class="number">1</span>;</span><br><span class="line">    int minV = Maxdist;</span><br><span class="line">    for(Vertex w=<span class="number">0</span>; w&lt;Graph-&gt;Nv; w++)</span><br><span class="line">        if(dist<span class="selector-attr">[w]</span> &amp;&amp; dist<span class="selector-attr">[w]</span> &lt; minV)  minV = dist<span class="selector-attr">[w]</span>, vMin = w;</span><br><span class="line">    return vMin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Prim(MGraph Graph, Vertex s)</span><br><span class="line">&#123;</span><br><span class="line">    initPrim(Graph, s);</span><br><span class="line">    Vertex v;</span><br><span class="line">    int cnt=<span class="number">1</span>;</span><br><span class="line">    while(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v = FindMinVertex(Graph, v);</span><br><span class="line">        if(v==-<span class="number">1</span>)  break;</span><br><span class="line">        MST<span class="selector-class">.push_back</span>(v), dist<span class="selector-attr">[v]</span> = <span class="number">0</span>, cnt++;</span><br><span class="line"></span><br><span class="line">        for(Vertex w=<span class="number">0</span>; w&lt;Graph-&gt;Nv; w++)</span><br><span class="line">            if(dist<span class="selector-attr">[w]</span> &amp;&amp; Graph-&gt;G<span class="selector-attr">[v]</span><span class="selector-attr">[w]</span>)</span><br><span class="line">                if(Graph-&gt;G<span class="selector-attr">[v]</span><span class="selector-attr">[w]</span> &lt; dist<span class="selector-attr">[w]</span>)  dist<span class="selector-attr">[w]</span> = Graph-&gt;G<span class="selector-attr">[v]</span><span class="selector-attr">[w]</span>, parent<span class="selector-attr">[w]</span> = v;</span><br><span class="line"></span><br><span class="line">        if(cnt &lt; Graph-&gt;Nv)  cout &lt;&lt; &quot;Bu Lian Tong !&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="11-邻接矩阵-最小生成树-Kruskal算法"><a href="#11-邻接矩阵-最小生成树-Kruskal算法" class="headerlink" title="11. 邻接矩阵 - 最小生成树 - Kruskal算法"></a>11. 邻接矩阵 - 最小生成树 - Kruskal算法</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 邻接矩阵 - 最小生成树 - Kruskal算法</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> Maxdist <span class="number">10000000</span></span><br><span class="line"><span class="selector-id">#define</span> MaxVertexNum <span class="number">100</span>        // 最大顶点数</span><br><span class="line">typedef int WeightType;         // 权值</span><br><span class="line">typedef int Vertex;             // 顶点</span><br><span class="line">typedef int DataType;           // 数据</span><br><span class="line"></span><br><span class="line">vector &lt;int&gt; dist(MaxVertexNum, Maxdist);   // 存储距离, 并初始化为 Maxdist</span><br><span class="line">vector &lt;int&gt; parent(MaxVertexNum, -<span class="number">1</span>);      // 储存父节点, 并初始化为 -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;              // &lt; V1, V2 &gt; 有向边</span><br><span class="line">    WeightType Weight;          // 权重</span><br><span class="line">    bool operator&lt; (const ENode &amp;<span class="selector-tag">b</span>) const       // 重载运算符</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;Weight&gt;<span class="selector-tag">b</span><span class="selector-class">.Weight</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line">priority_queue &lt;Edge&gt; MinHeap;     // 最小堆 &lt;优先队列&gt; 需存入边集合</span><br><span class="line">vector &lt;Edge&gt; MST;                 // 最小生成树</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    int Nv;                     // 顶点数</span><br><span class="line">    int Ne;                     // 边数</span><br><span class="line">    WeightType G<span class="selector-attr">[MaxVertexNum]</span><span class="selector-attr">[MaxVertexNum]</span>;   // 邻接矩阵</span><br><span class="line">    DataType Data<span class="selector-attr">[MaxVertexNum]</span>;                // 数据</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode MGraph;</span><br><span class="line"></span><br><span class="line">// 操作集</span><br><span class="line">int Kruskal(MGraph Graph);</span><br><span class="line">void Union(Vertex v, Vertex w);</span><br><span class="line">bool Union_HL(MGraph Graph, Edge E);        // 判断回路</span><br><span class="line"></span><br><span class="line">bool Union_HL(MGraph Graph, Edge E)</span><br><span class="line">&#123;</span><br><span class="line">    Vertex v = E-&gt;V1, w = E-&gt;V2;</span><br><span class="line">    for(; parent<span class="selector-attr">[v]</span>&gt;=<span class="number">0</span>; v=parent<span class="selector-attr">[v]</span>);</span><br><span class="line">    for(; parent<span class="selector-attr">[w]</span>&gt;=<span class="number">0</span>; w=parent<span class="selector-attr">[w]</span>);</span><br><span class="line">    </span><br><span class="line">    if(v==w) return true;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Union(v, w);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Union(Vertex v, Vertex w)</span><br><span class="line">&#123;</span><br><span class="line">    if(parent<span class="selector-attr">[v]</span>&lt;parent<span class="selector-attr">[w]</span>)  </span><br><span class="line">        parent<span class="selector-attr">[v]</span>+=parent<span class="selector-attr">[w]</span>, parent<span class="selector-attr">[w]</span>=v;</span><br><span class="line">    else  </span><br><span class="line">        parent<span class="selector-attr">[w]</span>+=parent<span class="selector-attr">[v]</span>, parent<span class="selector-attr">[v]</span>=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Kruskal(MGraph Graph)</span><br><span class="line">&#123;</span><br><span class="line">    WeightType weight = <span class="number">0</span>;</span><br><span class="line">    while(MST<span class="selector-class">.size</span>()&lt;(Graph-&gt;Nv-<span class="number">1</span>) &amp;&amp; !MinHeap<span class="selector-class">.empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Edge E = MinHeap<span class="selector-class">.top</span>();</span><br><span class="line">        MinHeap<span class="selector-class">.pop</span>();</span><br><span class="line">        if(!Union_HL(Graph, E))  weight+=E-&gt;Weight, MST<span class="selector-class">.push_back</span>(E);</span><br><span class="line">    &#125;</span><br><span class="line">    if(MST<span class="selector-class">.size</span>()&lt;(Graph-&gt;Nv-<span class="number">1</span>))  cout &lt;&lt; &quot;Bu Lian Tong !!!&quot; &lt;&lt; endl;</span><br><span class="line">    return weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="12-邻接表-拓扑排序"><a href="#12-邻接表-拓扑排序" class="headerlink" title="12. 邻接表 - 拓扑排序"></a>12. 邻接表 - 拓扑排序</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 邻接表 - 拓扑排序</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> MaxVertexNum <span class="number">100</span>        // 最大顶点数</span><br><span class="line">typedef int Vertex;             // 顶点</span><br><span class="line">typedef int WeightType;         // 边的权值</span><br><span class="line">typedef int DataType;           // 数据</span><br><span class="line"></span><br><span class="line">vector &lt;Vertex&gt; TopOrder(MaxVertexNum);          // 拓扑排序后的下标顺序</span><br><span class="line"></span><br><span class="line">// 边</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode&#123;</span><br><span class="line">    Vertex V1, V2;          // 有向边 &lt;V1, V2&gt;</span><br><span class="line">    WeightType Weight;      // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">// 邻接点</span><br><span class="line">typedef struct AdjVNode *PtrToAdjVNode; </span><br><span class="line">struct AdjVNode&#123;</span><br><span class="line">    Vertex ADjV;            // 邻接点下标</span><br><span class="line">    WeightType Weight;      // 边权重</span><br><span class="line">    PtrToAdjVNode Next;     // 指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 顶点表头结点</span><br><span class="line">typedef struct VNode&#123;</span><br><span class="line">    PtrToAdjVNode FirstEdge;    // 边表头结点</span><br><span class="line">    DataType Data;              // 数据</span><br><span class="line">&#125;AdjList<span class="selector-attr">[MaxVertexNum]</span>;         // 邻接表类型</span><br><span class="line"></span><br><span class="line">// 图</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode&#123;</span><br><span class="line">    int Nv;                     // 顶点数</span><br><span class="line">    int Ne;                     // 边数</span><br><span class="line">    AdjList G;                  // 邻接表</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode LGraph;      // 邻接表-图类型</span><br><span class="line"></span><br><span class="line">// 操作集</span><br><span class="line">bool TopSort(LGraph Graph, Vertex *TopOrder);   // 拓扑排序</span><br><span class="line"></span><br><span class="line">bool TopSort(LGraph Graph, Vertex *TopOrder)</span><br><span class="line">&#123;</span><br><span class="line">    queue &lt;Vertex&gt; zeroDegree;  // <span class="number">0</span> 度 队列</span><br><span class="line">    int Indegree<span class="selector-attr">[MaxVertexNum]</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    for(Vertex V=<span class="number">0</span>; V&lt;Graph-&gt;Nv; V++)  Indegree<span class="selector-attr">[V]</span> = <span class="number">0</span>;</span><br><span class="line">    for(Vertex V=<span class="number">0</span>; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        for(PtrToAdjVNode W=Graph-&gt;G<span class="selector-attr">[V]</span><span class="selector-class">.FirstEdge</span>; W; W=W-&gt;Next)</span><br><span class="line">            Indegree<span class="selector-attr">[W-&gt;ADjV]</span>++;</span><br><span class="line">    </span><br><span class="line">    for(Vertex V=<span class="number">0</span>; V&lt;Graph-&gt;Ne; V++)</span><br><span class="line">        if(!Indegree<span class="selector-attr">[V]</span>)  zeroDegree<span class="selector-class">.push</span>(V);</span><br><span class="line">    </span><br><span class="line">    while(!zeroDegree<span class="selector-class">.empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex V = zeroDegree<span class="selector-class">.front</span>();</span><br><span class="line">        TopOrder<span class="selector-attr">[cnt++]</span> = V;</span><br><span class="line">        zeroDegree<span class="selector-class">.pop</span>();</span><br><span class="line">        for(PtrToAdjVNode W=Graph-&gt;G<span class="selector-attr">[V]</span><span class="selector-class">.FirstEdge</span>; W; W-&gt;Next)</span><br><span class="line">            if(--Indegree<span class="selector-attr">[W-&gt;ADjV]</span> == <span class="number">0</span>)  zeroDegree<span class="selector-class">.push</span>(W-&gt;ADjV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cnt &lt; Graph-&gt;Nv)  return false;      // 存在回路</span><br><span class="line">    else  return true;                      // 排序成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】2. 树[笔记]</title>
      <link href="/2022/08/02/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%912-%E6%A0%91-%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/02/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%912-%E6%A0%91-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ol><li>数据结构：树 的操作集 C/C++代码实现</li></ol><h1 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找:"></a>1. 二分查找:</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> Binary_Search(<span class="built_in">int</span> *<span class="type">List</span>, <span class="built_in">int</span> num, <span class="built_in">int</span> length)   // <span class="type">List</span>：列表， num：差找目标数，length：数组长度</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> left=<span class="number">0</span>, right=length-<span class="number">1</span>, mid = length/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">List</span>[mid] == num)  <span class="keyword">return</span> mid;</span><br><span class="line">        // <span class="keyword">else</span> <span class="keyword">if</span>(mid == (left+right)/<span class="number">2</span>)  <span class="keyword">return</span> -<span class="number">1</span>;   // 个人方法：判定未找到</span><br><span class="line">        // mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">List</span>[mid] &gt; num)  left = left, right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">List</span>[mid] &lt; num)  left = mid + <span class="number">1</span>, right = right;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="2-二叉树-链表结构"><a href="#2-二叉树-链表结构" class="headerlink" title="2. 二叉树 ( 链表结构 ) :"></a>2. 二叉树 ( 链表结构 ) :</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stack&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">// 二叉树_链表结构实现</span><br><span class="line"></span><br><span class="line">typedef struct TreeNode *BinTree;   // 二叉树</span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    <span class="built_in">int</span> Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line">stack &lt;BinTree&gt; Stack;</span><br><span class="line"></span><br><span class="line">// 二叉树标准操作</span><br><span class="line">BinTree CreateBinTree();               // 创建二叉树</span><br><span class="line">BinTree Insert(<span class="built_in">int</span> Data);              // 插入数据</span><br><span class="line">void PreOrderTraversal(BinTree BT);    // 先序遍历，根--&gt;左--&gt;右</span><br><span class="line">void InOrderTraversal(BinTree BT);     // 中序遍历，左--&gt;根--&gt;右</span><br><span class="line">void PostOrderTraversal(BinTree BT);   // 后序遍历，左--&gt;右--&gt;梗</span><br><span class="line">void LevelOrderTraversal(BinTree BT);  // 层次遍历，1st层-&gt; 2st层。。。。</span><br><span class="line">void FindLeaves(BinTree BT);           // 输出叶结点</span><br><span class="line"><span class="built_in">int</span> GetHeight(BinTree BT);             // 输出树高</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BinTree Insert(<span class="built_in">int</span> Data)</span><br><span class="line">&#123;</span><br><span class="line">    BinTree BT = new struct TreeNode;</span><br><span class="line">    BT-&gt;Data = Data;</span><br><span class="line">    BT-&gt;Left = BT-&gt;Right = NULL;</span><br><span class="line">    <span class="keyword">return</span> BT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree CreateBinTree()</span><br><span class="line">&#123;</span><br><span class="line">    BinTree BT = new struct TreeNode;</span><br><span class="line">    BT-&gt;Data = <span class="number">1</span>;</span><br><span class="line">    BT-&gt;Left = Insert(<span class="number">2</span>);</span><br><span class="line">    BT-&gt;Right = Insert(<span class="number">3</span>);</span><br><span class="line">    BT-&gt;Left-&gt;Left = Insert(<span class="number">4</span>);</span><br><span class="line">    BT-&gt;Left-&gt;Right = Insert(<span class="number">6</span>);</span><br><span class="line">    BT-&gt;Left-&gt;Right-&gt;Left = Insert(<span class="number">5</span>);</span><br><span class="line">    BT-&gt;Right-&gt;Left = Insert(<span class="number">7</span>);</span><br><span class="line">    BT-&gt;Right-&gt;Right = Insert(<span class="number">9</span>);</span><br><span class="line">    BT-&gt;Right-&gt;Left-&gt;Right = Insert(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> BT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrderTraversal(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;PreOrderTraversal: &quot;</span> &lt;&lt; BT-&gt;Data &lt;&lt; endl;</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrderTraversal(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;InOrderTraversal: &quot;</span> &lt;&lt; BT-&gt;Data &lt;&lt; endl;</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PostOrderTraversal(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;PostOrderTraversal: &quot;</span> &lt;&lt; BT-&gt;Data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LevelOrderTraversal(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    queue &lt;BinTree&gt; BT_q;</span><br><span class="line">    BinTree temp;</span><br><span class="line">    BT_q.push(BT);</span><br><span class="line">    <span class="keyword">while</span>(!BT_q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp = BT_q.front();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LevelOrderTraversal: &quot;</span> &lt;&lt; BT_q.front()-&gt;Data &lt;&lt; endl;</span><br><span class="line">        BT_q.pop();</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;Left)   BT_q.push(temp-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;Right)  BT_q.push(temp-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FindLeaves(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!BT-&gt;Left &amp;&amp; !BT-&gt;Right)  cout &lt;&lt; <span class="string">&quot;FindLeaves: &quot;</span> &lt;&lt; BT-&gt;Data &lt;&lt; endl;</span><br><span class="line">        FindLeaves(BT-&gt;Left);</span><br><span class="line">        FindLeaves(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> GetHeight(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> heightLeft, heightRight;</span><br><span class="line">    <span class="keyword">if</span>(BT)</span><br><span class="line">    &#123;</span><br><span class="line">        heightLeft = GetHeight(BT-&gt;Left);</span><br><span class="line">        heightRight = GetHeight(BT-&gt;Right);</span><br><span class="line">        <span class="keyword">return</span> (heightLeft&gt;heightRight?heightLeft:heightRight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试程序</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    BinTree BT = CreateBinTree();</span><br><span class="line">    PreOrderTraversal(BT);</span><br><span class="line">    InOrderTraversal(BT);</span><br><span class="line">    PostOrderTraversal(BT);</span><br><span class="line">    LevelOrderTraversal(BT);</span><br><span class="line">    FindLeaves(BT);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;GetHeight: &quot;</span> &lt;&lt; GetHeight(BT) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树 :"></a>3. 二叉搜索树 :</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">// 二叉搜索树</span><br><span class="line"></span><br><span class="line">typedef struct TreeNode *BinTree;</span><br><span class="line">struct TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 二叉搜索树操作集</span><br><span class="line">BinTree Find(<span class="built_in">int</span> X, BinTree BST);       // 递归查找</span><br><span class="line">BinTree IterFind(<span class="built_in">int</span> X, BinTree BST);   // 非递归查找</span><br><span class="line">BinTree FindMin(BinTree BST);           // 递归查找最小值</span><br><span class="line">BinTree FindMax(BinTree BST);           // 非递归差找最大值</span><br><span class="line">BinTree Insert(<span class="built_in">int</span> X, BinTree BST);     // 递归插入</span><br><span class="line">BinTree Delete(<span class="built_in">int</span> X, BinTree BST);     // 递归删除</span><br><span class="line">void InOrderTraversal(BinTree BT);      // 中序遍历</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BinTree Find(<span class="built_in">int</span> X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)</span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)  <span class="keyword">return</span> Find(X, BST-&gt;Right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)  <span class="keyword">return</span> Find(X, BST-&gt;Left);</span><br><span class="line">        <span class="keyword">else</span>   <span class="keyword">return</span> BST;</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree IterFind(<span class="built_in">int</span> X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)</span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)  BST = BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)  BST = BST-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> BST;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree FindMin(BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)  <span class="keyword">return</span> NULL;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Left)  <span class="keyword">return</span> FindMin(BST-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree FindMax(BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)  <span class="keyword">return</span> NULL;</span><br><span class="line">    <span class="keyword">while</span>(BST-&gt;Right)  BST = BST-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">BinTree Insert(<span class="built_in">int</span> X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)</span><br><span class="line">    &#123;</span><br><span class="line">        BST = new struct TreeNode;</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &lt; BST-&gt;Data)  BST-&gt;Left = Insert(X, BST-&gt;Left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data)  BST-&gt;Right = Insert(X, BST-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree Delete(<span class="built_in">int</span> X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    BinTree Tmp;</span><br><span class="line">    <span class="keyword">if</span>(!BST)  cout &lt;&lt; <span class="string">&quot;Fall To Find: X in BinTree: BST !!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)  BST-&gt;Left = Delete(X, BST-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data)  BST-&gt;Right = Delete(X, BST-&gt;Right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)  </span><br><span class="line">        &#123;</span><br><span class="line">            Tmp = FindMin(BST-&gt;Right);</span><br><span class="line">            BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">            BST-&gt;Right = Delete(Tmp-&gt;Data, BST-&gt;Right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Tmp = BST;</span><br><span class="line">            <span class="keyword">if</span>(!BST-&gt;Left)  BST = BST-&gt;Left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)  BST = BST-&gt;Right;</span><br><span class="line">            delete Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrderTraversal(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        cout &lt;&lt; BT-&gt;Data;</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆 :"></a>4. 堆 :</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define MaxData 10000;</span></span><br><span class="line"></span><br><span class="line">typedef struct HeapStruct *MaxHeap;</span><br><span class="line">struct HeapStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> *Data;      // 数组</span><br><span class="line">    <span class="built_in">int</span> Size;       // 存储当前Size大小</span><br><span class="line">    <span class="built_in">int</span> Capacity;   // Heap的最大容积</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MaxHeap CreateHeap(<span class="built_in">int</span> MaxSize);        // 创建堆</span><br><span class="line"><span class="built_in">bool</span> IsFull(MaxHeap H);                 // 判定堆是否为满</span><br><span class="line"><span class="built_in">bool</span> Insert(MaxHeap H, <span class="built_in">int</span> item);       // 插入一个item</span><br><span class="line"><span class="built_in">bool</span> IsEmpty(MaxHeap H);                // 判定堆是否为空</span><br><span class="line"><span class="built_in">int</span> DeleteMax(MaxHeap H);               // 删除堆中最大值</span><br><span class="line">void LevelOrderTraversal(MaxHeap H);    // 层序遍历  </span><br><span class="line"></span><br><span class="line">MaxHeap CreateHeap(<span class="built_in">int</span> MaxSize)</span><br><span class="line">&#123;</span><br><span class="line">    MaxHeap Heap = new struct HeapStruct;</span><br><span class="line">    Heap-&gt;Data = new <span class="built_in">int</span>[MaxSize+<span class="number">1</span>];</span><br><span class="line">    Heap-&gt;Data[<span class="number">0</span>] = MaxData;            // 建立哨兵</span><br><span class="line">    Heap-&gt;Capacity = MaxSize;</span><br><span class="line">    Heap-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> IsFull(MaxHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == H-&gt;Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> IsEmpty(MaxHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (!H-&gt;Size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> Insert(MaxHeap H, <span class="built_in">int</span> item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(H))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This Heap is full !!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = ++H-&gt;Size; H-&gt;Data[i/<span class="number">2</span>] &lt; item; i /= <span class="number">2</span>)  H-&gt;Data[i] = H-&gt;Data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;Data[i] = item;</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> DeleteMax(MaxHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> parent, child;</span><br><span class="line">    <span class="built_in">int</span> MaxItem = H-&gt;Data[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span> LastItem = H-&gt;Data[H-&gt;Size--];</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(H))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This Heap is Empty !!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(parent = <span class="number">1</span>; parent*<span class="number">2</span> &lt;= H-&gt;Size; parent = child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = parent*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(child!=H-&gt;Size &amp;&amp; H-&gt;Data[child] &lt; H-&gt;Data[child+<span class="number">1</span>])  child++;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;Data[child] &lt;= LastItem)  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>  H-&gt;Data[parent] = H-&gt;Data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[parent] = LastItem;</span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LevelOrderTraversal(MaxHeap H)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i&lt;=H-&gt;Size;i++)  cout &lt;&lt; H-&gt;Data[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">MaxHeap H;</span><br><span class="line"><span class="built_in">int</span> MaxSize = <span class="number">100</span>;</span><br><span class="line">H = CreateHeap(MaxSize);</span><br><span class="line">Insert(H,<span class="number">55</span>);</span><br><span class="line">Insert(H,<span class="number">66</span>);</span><br><span class="line">Insert(H,<span class="number">44</span>);</span><br><span class="line">Insert(H,<span class="number">33</span>);</span><br><span class="line">Insert(H,<span class="number">11</span>);</span><br><span class="line">Insert(H,<span class="number">22</span>);</span><br><span class="line">Insert(H,<span class="number">88</span>);</span><br><span class="line">Insert(H,<span class="number">99</span>);</span><br><span class="line">/*</span><br><span class="line"> <span class="number">99</span></span><br><span class="line">/  \</span><br><span class="line">   <span class="number">88</span>  <span class="number">66</span></span><br><span class="line">  / \  / \</span><br><span class="line"> <span class="number">55</span> <span class="number">11</span> <span class="number">22</span> <span class="number">44</span></span><br><span class="line">/ </span><br><span class="line">   <span class="number">33</span>  </span><br><span class="line">*/</span><br><span class="line">LevelOrderTraversal(H);</span><br><span class="line">DeleteMax(H);</span><br><span class="line">LevelOrderTraversal(H);</span><br><span class="line">DeleteMax(H);</span><br><span class="line">LevelOrderTraversal(H);</span><br><span class="line">DeleteMax(H);</span><br><span class="line">LevelOrderTraversal(H);</span><br><span class="line">DeleteMax(H);</span><br><span class="line">LevelOrderTraversal(H);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="5-哈夫曼树"><a href="#5-哈夫曼树" class="headerlink" title="5. 哈夫曼树 :"></a>5. 哈夫曼树 :</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define MaxSize 1000</span></span><br><span class="line"><span class="comment">#define MinData -1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> w1[<span class="number">11</span>] = &#123;<span class="number">13</span>,<span class="number">1</span>,<span class="number">45</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">13</span>,<span class="number">40</span>,<span class="number">33</span>,<span class="number">38</span>&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">typedef struct HeapStruct *MinHeap;</span><br><span class="line">struct HeapStruct</span><br><span class="line">&#123;</span><br><span class="line">    HuffmanTree *Data;</span><br><span class="line">    <span class="built_in">int</span> Size;</span><br><span class="line">    <span class="built_in">int</span> Capacity;</span><br><span class="line">&#125;;</span><br><span class="line">struct TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Weight;</span><br><span class="line">    HuffmanTree Left;</span><br><span class="line">    HuffmanTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MinHeap CreateHeap();                           // 初始化堆</span><br><span class="line">HuffmanTree Create();                           // 初始化哈夫曼树</span><br><span class="line">void sort(MinHeap H, <span class="built_in">int</span> i);                    // 调整子最小堆</span><br><span class="line">void adjust(MinHeap H);                         // 调整最小堆</span><br><span class="line">void BuildMinHeap(MinHeap H);                   // 建堆</span><br><span class="line">HuffmanTree Delete(MinHeap H);                  // 删除最小堆元素</span><br><span class="line">void Insert(MinHeap H, HuffmanTree Huff);       // 插入最小堆元素</span><br><span class="line">void PreOrderTraversal(HuffmanTree Huff);       // 先序遍历</span><br><span class="line">HuffmanTree Huffman(MinHeap H);                 // 哈夫曼树的构建</span><br><span class="line"></span><br><span class="line">MinHeap CreateHeap()</span><br><span class="line">&#123;</span><br><span class="line">MinHeap H = new struct HeapStruct;</span><br><span class="line">    H-&gt;Data = new struct TreeNode*[MaxSize+<span class="number">1</span>];</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    // 哨兵</span><br><span class="line">    HuffmanTree Huff = Create();</span><br><span class="line">    Huff-&gt;Weight = MinData;</span><br><span class="line">    H-&gt;Data[<span class="number">0</span>] = Huff;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuffmanTree Create()</span><br><span class="line">&#123;</span><br><span class="line">    HuffmanTree Huff = new struct TreeNode;</span><br><span class="line">    Huff-&gt;Weight = <span class="number">0</span>;</span><br><span class="line">    Huff-&gt;Left = Huff-&gt;Right = NULL;</span><br><span class="line">    <span class="keyword">return</span> Huff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sort(MinHeap H, <span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> parent, child;</span><br><span class="line">    <span class="built_in">int</span> tmp = H-&gt;Data[i]-&gt;Weight;</span><br><span class="line">    <span class="keyword">for</span>(parent = i; parent*<span class="number">2</span> &lt;= H-&gt;Size; parent = child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = <span class="number">2</span>*parent;</span><br><span class="line">        <span class="keyword">if</span>(child!=H-&gt;Size &amp;&amp; H-&gt;Data[child+<span class="number">1</span>]-&gt;Weight &lt; H-&gt;Data[child]-&gt;Weight)  child++;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;Data[child]-&gt;Weight &gt;= tmp)  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>  H-&gt;Data[parent] = H-&gt;Data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[parent]-&gt;Weight = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void adjust(MinHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=H-&gt;Size/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)  sort(H, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BuildMinHeap(MinHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    HuffmanTree Huff;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;sizeof(w1)/sizeof(<span class="built_in">int</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Huff = Create();</span><br><span class="line">        Huff-&gt;Weight = w1[i];</span><br><span class="line">        H-&gt;Data[++H-&gt;Size] = Huff;</span><br><span class="line">    &#125;</span><br><span class="line">    adjust(H);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuffmanTree Delete(MinHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> parent, child;</span><br><span class="line">    HuffmanTree T = H-&gt;Data[<span class="number">1</span>];</span><br><span class="line">    HuffmanTree tmp = H-&gt;Data[H-&gt;Size--];</span><br><span class="line">    <span class="keyword">for</span>(parent = <span class="number">1</span>; parent*<span class="number">2</span> &lt;= H-&gt;Size; parent = child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = <span class="number">2</span>*parent;</span><br><span class="line">        <span class="keyword">if</span>(child!=H-&gt;Size &amp;&amp; H-&gt;Data[child+<span class="number">1</span>]-&gt;Weight &lt; H-&gt;Data[child]-&gt;Weight)  child++;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;Data[child]-&gt;Weight &gt;= tmp-&gt;Weight)  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>  H-&gt;Data[parent] = H-&gt;Data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[parent] = tmp;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(MinHeap H, HuffmanTree Huff)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Weight = Huff-&gt;Weight;</span><br><span class="line">    <span class="built_in">int</span> i = ++H-&gt;Size;</span><br><span class="line">    <span class="keyword">for</span>(; H-&gt;Data[i/<span class="number">2</span>]-&gt;Weight &gt; Weight; i/=<span class="number">2</span>)  H-&gt;Data[i] = H-&gt;Data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;Data[i] = Huff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrderTraversal(HuffmanTree Huff)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Huff)</span><br><span class="line">    &#123;</span><br><span class="line">cout &lt;&lt; Huff-&gt;Weight &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">PreOrderTraversal(Huff-&gt;Left);</span><br><span class="line">PreOrderTraversal(Huff-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line">    // cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuffmanTree Huffman(MinHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;H-&gt;Size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        T = new struct TreeNode;</span><br><span class="line">        T-&gt;Left = Delete(H);</span><br><span class="line">        T-&gt;Right = Delete(H);</span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class="line">        Insert(H, T);</span><br><span class="line">    &#125;</span><br><span class="line">    T = Delete(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="6-并查集"><a href="#6-并查集" class="headerlink" title="6. 并查集 :"></a>6. 并查集 :</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define MaxSize 1000</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    <span class="built_in">int</span> Data;</span><br><span class="line">    <span class="built_in">int</span> Parent;</span><br><span class="line">&#125;SetType;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> Find(SetType *s, <span class="built_in">int</span> x1);                                 // 查</span><br><span class="line">void <span class="type">Union</span>(SetType *s, <span class="built_in">int</span> x1, <span class="built_in">int</span> x2);     // 并</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> Find(SetType *s, <span class="built_in">int</span> x1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MaxSize &amp;&amp; s[i].Data != x1; i++);</span><br><span class="line">    <span class="keyword">if</span>(MaxSize &lt;= i)  <span class="keyword">return</span> false;</span><br><span class="line">    <span class="keyword">for</span>(; s[i].Parent&gt;=<span class="number">0</span>; i = s[i].Parent);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="type">Union</span>(SetType *s, <span class="built_in">int</span> x1, <span class="built_in">int</span> x2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> root1 = Find(s, x1), root2 = Find(s, x2);</span><br><span class="line">    <span class="keyword">if</span>(root1 != root2)  s[root1].Parent = root2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构与算法】1. 线性结构[笔记]</title>
      <link href="/2022/07/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%911-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%911-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1. 线性表:"></a>1. 线性表:</h1><ul><li>多项式表示问题的启示：<ol><li>同一个问题可以有不同的表示（存储）方法</li><li>有一类共性问题：有序线性序列的组织和管理</li></ol></li></ul><p>“线性表(Linear List)”：由同类型数据元素构成有序序列的线性结构</p><ol><li>表中元素个数称为线性表的长度</li><li>线性表没有元素时，称为空表</li><li>表起始位置称表头，表结束位置称表尾</li></ol><hr><h2 id="线性表的抽象数据类型描述"><a href="#线性表的抽象数据类型描述" class="headerlink" title="线性表的抽象数据类型描述"></a>线性表的抽象数据类型描述</h2><h4 id="类型名称：线性表（List）"><a href="#类型名称：线性表（List）" class="headerlink" title="类型名称：线性表（List）"></a>类型名称：线性表（List）</h4><h4 id="数据对象集：线性表是-n-≥0-个元素构成的有序序列-a1-a2-…-an"><a href="#数据对象集：线性表是-n-≥0-个元素构成的有序序列-a1-a2-…-an" class="headerlink" title="数据对象集：线性表是 n (≥0)个元素构成的有序序列( a1, a2, … ,an )"></a>数据对象集：线性表是 n (≥0)个元素构成的有序序列( a1, a2, … ,an )</h4><h4 id="操作集：线性表L-属于-List，整数i表示位置，元素X-属于-ElementType，"><a href="#操作集：线性表L-属于-List，整数i表示位置，元素X-属于-ElementType，" class="headerlink" title="操作集：线性表L 属于 List，整数i表示位置，元素X 属于 ElementType，"></a>操作集：线性表L 属于 List，整数i表示位置，元素X 属于 ElementType，</h4><p>线性表基本操作主要有：</p><ol><li>List MakeEmpty()：初始化一个空线性表L； </li><li>ElementType FindKth( int K, List L )：根据位序K，返回相应元素 ； </li><li>int Find( ElementType X, List L )：在线性表L中查找X的第一次出现位置；</li><li>void Insert( ElementType X, int i, List L)：在位序i前插入一个新元素X；</li><li>void Delete( int i, List L )：删除指定位序i的元素；</li><li>int Length( List L )：返回线性表L的长度n。</li></ol><hr><h2 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现:"></a>线性表的顺序存储实现:</h2><h3 id="1-gt-数组线性表-线性结构"><a href="#1-gt-数组线性表-线性结构" class="headerlink" title="1&gt; 数组线性表[线性结构]"></a>1&gt; 数组线性表[线性结构]</h3><ul><li>利用数组的连续存储空间顺序存放线性表的各元素</li></ul><hr><br><p>主要操作的实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#define MAXSIZE 100  // MAXSIZE 定义为 Data 数组的大小</span></span><br><span class="line">typedef <span class="built_in">int</span> ElementType;  // ElementType 可定义为任意类型</span><br><span class="line">typedef struct LNode *<span class="type">List</span>; </span><br><span class="line">struct LNode&#123;</span><br><span class="line">ElementType Data[MAXSIZE]; </span><br><span class="line"><span class="built_in">int</span> Last;  // Last 定义线性表的最后一个元素</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> MakeEmpty(); //初始化顺序表 </span><br><span class="line"><span class="built_in">int</span> Find(ElementType X,<span class="type">List</span> L); //查找 X 第一次出现的下标 </span><br><span class="line">void Insert(ElementType X,<span class="built_in">int</span> i,<span class="type">List</span> L); //在下标为 i 的地方插入 X </span><br><span class="line">void Delete(<span class="built_in">int</span> i,<span class="type">List</span> L);   //删除下标为 i 的当前值 </span><br><span class="line">ElementType FindKth(<span class="built_in">int</span> K,<span class="type">List</span> L);  //返回下标为 K 的当前值</span><br><span class="line"><span class="built_in">int</span> Length(<span class="type">List</span> L);  //返回顺序表的长度 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line"><span class="type">List</span> MakeEmpty()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">List</span> L;</span><br><span class="line">    L = (<span class="type">List</span>)malloc(sizeof(struct LNode));</span><br><span class="line">    L-&gt;Last = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按值差找</span><br><span class="line"><span class="built_in">int</span> Find(ElementType X, <span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[cnt] != X)  cnt++;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; L-&gt;Last)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入</span><br><span class="line">void Insert(ElementType X, <span class="built_in">int</span> i, <span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Last == MAXSIZE-<span class="number">1</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;表已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;位置不合法&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j=L-&gt;Last; j&gt;=i; j--)  L-&gt;Data[j+<span class="number">1</span>] = L-&gt;Data[j];</span><br><span class="line">    L-&gt;Data[i] = X;</span><br><span class="line">    L-&gt;Last++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">void Delete(<span class="built_in">int</span> i, <span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;L-&gt;Last)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;位置不合法&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j=i; j&lt;L-&gt;Last; j++)  L-&gt;Data[j] = L-&gt;Data[j+<span class="number">1</span>];</span><br><span class="line">    L-&gt;Data[L-&gt;Last] = NULL;</span><br><span class="line">    L-&gt;Last--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按序差找</span><br><span class="line">ElementType FindKth(<span class="built_in">int</span> K,<span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(K&lt;<span class="number">0</span> || K&gt;L-&gt;Last)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;位置不合法&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;Data[K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 表长</span><br><span class="line"><span class="built_in">int</span> Length(<span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;Last+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-gt-链表线性表-线性结构"><a href="#2-gt-链表线性表-线性结构" class="headerlink" title="2&gt; 链表线性表[线性结构]:"></a>2&gt; 链表线性表[线性结构]:</h3><ul><li>不要求逻辑上相邻的两个元素物理上也相邻；通过“链”建立起数据元素之间的逻辑关系。</li></ul><hr><br><p>主要操作的实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">int</span> ElementType; // ElementType 可定义为任意类型</span><br><span class="line">typedef struct LNode *<span class="type">List</span>;</span><br><span class="line"></span><br><span class="line">struct LNode&#123;</span><br><span class="line">    ElementType Data;   //数据域 </span><br><span class="line">    <span class="type">List</span> Next;   // 下一个链表的地址 </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">List</span> L;</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> MakeEmpty(); //初始化链表 </span><br><span class="line"><span class="built_in">int</span> Length(<span class="type">List</span> L);  // 以遍历链表的方法求链表长度 </span><br><span class="line"><span class="type">List</span> FindKth(<span class="built_in">int</span> K,<span class="type">List</span> L);  // 按序号查找 </span><br><span class="line"><span class="type">List</span> Find(ElementType X,<span class="type">List</span> L);  // 按值查找 </span><br><span class="line"><span class="type">List</span> Insert(ElementType X,<span class="built_in">int</span> i,<span class="type">List</span> L);  //将 X 插入到第 i-<span class="number">1</span>(i&gt;<span class="number">0</span>) 个结点之后 </span><br><span class="line"><span class="type">List</span> Delete(<span class="built_in">int</span> i,<span class="type">List</span> L); // 删除第 i(i&gt;<span class="number">0</span>) 个结点 </span><br><span class="line">void Print(<span class="type">List</span> L); // 输出链表元素 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化链表</span><br><span class="line"><span class="type">List</span> MakeEmpty()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">List</span> L = new struct LNode;</span><br><span class="line">    L = NULL;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 表长</span><br><span class="line"><span class="built_in">int</span> Length(<span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">List</span> p = L;</span><br><span class="line">    <span class="built_in">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按序差找</span><br><span class="line"><span class="type">List</span> FindKth(<span class="built_in">int</span> K, <span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">List</span> p = L;</span><br><span class="line">    <span class="built_in">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; cnt&lt;K)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == K)  <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按值差找</span><br><span class="line"><span class="type">List</span> Find(ElementType X, <span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">List</span> p = L;</span><br><span class="line">    <span class="built_in">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;Data!=X)  p = p-&gt;Next;</span><br><span class="line">    <span class="keyword">return</span> p; // 若没有找到 则返回最后一个链表的Next，即NULL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 插入</span><br><span class="line"><span class="number">1.</span> 用 s 指向一个新的结点</span><br><span class="line"><span class="number">2.</span> 用 p 指向链表的第 i-<span class="number">1</span> 个结点 </span><br><span class="line"><span class="number">3.</span> s-&gt;Next = p-&gt;Next，将 s 的下一个结点指向 p 的下一个结点 </span><br><span class="line"><span class="number">4.</span> p-&gt;Next = s，将 p 的下一结点改为 s   */</span><br><span class="line"><span class="type">List</span> Insert(ElementType X, <span class="built_in">int</span> i, <span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">List</span> p, s;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = new struct LNode;</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = L;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i-<span class="number">1</span>, L);</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = new struct LNode;</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 删除</span><br><span class="line"><span class="number">1.</span> 用 p 指向链表的第 i-<span class="number">1</span> 个结点 </span><br><span class="line"><span class="number">2.</span> 用 s 指向要被删除的的第 i 个结点</span><br><span class="line"><span class="number">3.</span> p-&gt;Next = s-&gt;Next，p 指针指向 s 后面</span><br><span class="line"><span class="number">4.</span> free(s)，释放空间 */</span><br><span class="line"><span class="type">List</span> Delete(<span class="built_in">int</span> i, <span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">List</span> p, s;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = L;</span><br><span class="line">        <span class="keyword">if</span>(L)  L = L-&gt;Next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> NULL;</span><br><span class="line">        delete s;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i-<span class="number">1</span>, L);</span><br><span class="line">    <span class="keyword">if</span>(!p || !(p-&gt;Next))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = p-&gt;Next;</span><br><span class="line">        p-&gt;Next=s-&gt;Next;</span><br><span class="line">        delete s;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出链表元素</span><br><span class="line">void Print(<span class="type">List</span> L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">List</span> t;</span><br><span class="line">    <span class="built_in">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Present List is: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(t = L; t; t=t-&gt;Next)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; t-&gt;Data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)  cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="2-堆栈"><a href="#2-堆栈" class="headerlink" title="2.堆栈:"></a>2.堆栈:</h1><h2 id="1-gt-栈的顺序储存-线性结构"><a href="#1-gt-栈的顺序储存-线性结构" class="headerlink" title="1&gt; 栈的顺序储存[线性结构]"></a>1&gt; 栈的顺序储存[线性结构]</h2><ul><li>栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成</li></ul><hr><br><p>主要操作的实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define MAXSIZE 100   // 堆栈元素的最大个数</span></span><br><span class="line">typedef <span class="built_in">int</span> ElementType; // ElementType 暂时定义为 <span class="built_in">int</span> 类型 </span><br><span class="line">typedef struct SNode *Stack;</span><br><span class="line">struct SNode&#123;</span><br><span class="line">    ElementType Data[MAXSIZE];   // 存储堆栈元素</span><br><span class="line">    <span class="built_in">int</span> Top;  // 记录栈顶元素下标 </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Stack CreateStack();  // 初始化堆栈 </span><br><span class="line"><span class="built_in">int</span> IsFull(Stack S); // 判断堆栈是否已满 </span><br><span class="line"><span class="built_in">int</span> IsEmpty(Stack S);   // 判断堆栈是否为空 </span><br><span class="line">void Push(Stack S,ElementType item);   // 入栈 </span><br><span class="line">ElementType Pop(Stack S);   // 出栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化堆栈</span><br><span class="line">Stack CreateStack()</span><br><span class="line">&#123;</span><br><span class="line">    Stack S = new struct SNode;</span><br><span class="line">    S-&gt;Top = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 是否已满</span><br><span class="line"><span class="built_in">int</span> IsFull(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (S-&gt;Top == MAXSIZE-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 是否为空</span><br><span class="line"><span class="built_in">int</span> IsEmpty(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (S-&gt;Top == -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入栈</span><br><span class="line">void Push(Stack S, ElementType item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;IsFull !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;Top++;</span><br><span class="line">        S-&gt;Data[S-&gt;Top] = item;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">ElementType Pop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;IsEmpty !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ElementType val = S-&gt;Data[S-&gt;Top];</span><br><span class="line">        S-&gt;Top--;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><br><h2 id="2-gt-栈的链表储存-线性结构"><a href="#2-gt-栈的链表储存-线性结构" class="headerlink" title="2&gt; 栈的链表储存[线性结构]"></a>2&gt; 栈的链表储存[线性结构]</h2><ul><li>栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。</li></ul><hr><br>主要操作的实现:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define MAXSIZE 100   // 堆栈元素的最大个数</span></span><br><span class="line">typedef <span class="built_in">int</span> ElementType; // ElementType 暂时定义为 <span class="built_in">int</span> 类型 </span><br><span class="line">typedef struct SNode *Stack;</span><br><span class="line">struct SNode&#123;</span><br><span class="line">    ElementType Data;   // 存储堆栈元素</span><br><span class="line">    Stack Next;  // 记录栈顶元素下标 </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Stack CreateStack();  // 初始化链栈 </span><br><span class="line"><span class="built_in">int</span> IsEmpty(Stack S);  // 判断链栈是否为空 </span><br><span class="line">void Push(Stack S,ElementType item);  // 入栈 </span><br><span class="line">ElementType Pop(Stack S);  // 出栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">Stack CreateStack()</span><br><span class="line">&#123;</span><br><span class="line">    Stack S = new struct SNode;</span><br><span class="line">    Stack Next = NULL;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 是否为空</span><br><span class="line"><span class="built_in">int</span> IsEmpty(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(S-&gt;Next == NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入栈</span><br><span class="line">void Push(Stack S, ElementType item)</span><br><span class="line">&#123;</span><br><span class="line">    Stack temp = new struct SNode;</span><br><span class="line">    temp-&gt;Data = item;</span><br><span class="line">    temp-&gt;Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">ElementType Pop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    Stack First = S-&gt;Next;</span><br><span class="line">    ElementType TopVal;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;IsEmpty !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        TopVal = First-&gt;Data;</span><br><span class="line">        S-&gt;Next = First-&gt;Next;</span><br><span class="line">        delete First;</span><br><span class="line">        <span class="keyword">return</span> TopVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列:"></a>2.队列:</h1><h2 id="1-gt-循环队列的顺序储存-线性结构"><a href="#1-gt-循环队列的顺序储存-线性结构" class="headerlink" title="1&gt; 循环队列的顺序储存[线性结构]"></a>1&gt; 循环队列的顺序储存[线性结构]</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define MAXSIZE 12</span></span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line">struct QNode</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> front;</span><br><span class="line"><span class="built_in">int</span> rear;</span><br><span class="line"><span class="built_in">int</span> Data[MAXSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue CreateQueue();   // 初始化队列 </span><br><span class="line">void AddQ(Queue Q, <span class="built_in">int</span> item);  //  入队</span><br><span class="line"><span class="built_in">int</span> IsFull(Queue Q);   // 判断队列是否已满 </span><br><span class="line"><span class="built_in">int</span> DeleteQ(Queue Q);  // 出队 </span><br><span class="line"><span class="built_in">int</span> IsEmpty(Queue Q);  // 判断队列是否为空 </span><br><span class="line"></span><br><span class="line">Queue CreateQueue()</span><br><span class="line">&#123;</span><br><span class="line">Queue Q = new struct QNode;</span><br><span class="line">Q-&gt;front = -<span class="number">1</span>, Q-&gt;rear = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> IsFull(Queue Q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Q-&gt;rear+<span class="number">1</span>) % MAXSIZE == Q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> IsEmpty(Queue Q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Q-&gt;rear == Q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AddQ(Queue Q, <span class="built_in">int</span> item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(IsFull(Q))  cout &lt;&lt; <span class="string">&quot;Queue is full!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>) % MAXSIZE;</span><br><span class="line">Q-&gt;Data[Q-&gt;rear] = item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> DeleteQ(Queue Q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(Q))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Queue is empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front = (Q-&gt;front+<span class="number">1</span>) % MAXSIZE;</span><br><span class="line"><span class="keyword">return</span> Q-&gt;Data[Q-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试程序</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">Queue Q = CreateQueue();</span><br><span class="line">AddQ(Q,<span class="number">3</span>);</span><br><span class="line">printf(<span class="string">&quot;3 in\n&quot;</span>);</span><br><span class="line">AddQ(Q,<span class="number">5</span>);</span><br><span class="line">printf(<span class="string">&quot;5 in\n&quot;</span>);</span><br><span class="line">AddQ(Q,<span class="number">11</span>);</span><br><span class="line">printf(<span class="string">&quot;11 out\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;%d out\n&quot;</span>,DeleteQ(Q));</span><br><span class="line">printf(<span class="string">&quot;%d out\n&quot;</span>,DeleteQ(Q));</span><br><span class="line">printf(<span class="string">&quot;%d out\n&quot;</span>,DeleteQ(Q));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><br><h2 id="2-gt-队列的链表储存-线性结构"><a href="#2-gt-队列的链表储存-线性结构" class="headerlink" title="2&gt; 队列的链表储存[线性结构]"></a>2&gt; 队列的链表储存[线性结构]</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line">struct Node&#123;</span><br><span class="line"><span class="built_in">int</span> Data;</span><br><span class="line">struct Node *Next;</span><br><span class="line">&#125;;</span><br><span class="line">struct QNode&#123;</span><br><span class="line">struct Node *rear;</span><br><span class="line">struct Node *front;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue CreateQueue();</span><br><span class="line">void AddQ(Queue Q, <span class="built_in">int</span> Data);</span><br><span class="line"><span class="built_in">int</span> DeleteQ(Queue Q);</span><br><span class="line"><span class="built_in">int</span> IsEmpty(Queue Q);</span><br><span class="line"></span><br><span class="line">Queue CreateQueue()</span><br><span class="line">&#123;</span><br><span class="line">Queue Q = new struct QNode;</span><br><span class="line">Q-&gt;front = NULL;</span><br><span class="line">Q-&gt;rear = NULL;</span><br><span class="line"><span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> IsEmpty(Queue Q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Q-&gt;front == NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AddQ(Queue Q, <span class="built_in">int</span> Data)</span><br><span class="line">&#123;</span><br><span class="line">struct Node *node;</span><br><span class="line">node = new struct Node;</span><br><span class="line">node-&gt;Data = Data;</span><br><span class="line">node-&gt;Next = NULL;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;rear == NULL)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;rear = node;</span><br><span class="line">Q-&gt;front = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;rear-&gt;Next = node;</span><br><span class="line">Q-&gt;rear = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> DeleteQ(Queue Q)</span><br><span class="line">&#123;</span><br><span class="line">struct Node *FrontCell;</span><br><span class="line"><span class="built_in">int</span> FrontElem;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(Q))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Queue is empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">FrontCell = Q-&gt;front;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)  Q-&gt;front = Q-&gt;rear = NULL;</span><br><span class="line"><span class="keyword">else</span>  Q-&gt;front = Q-&gt;front-&gt;Next;</span><br><span class="line">FrontElem = FrontCell-&gt;Data;</span><br><span class="line">delete FrontCell;</span><br><span class="line"><span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试程序</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">Queue Q;</span><br><span class="line">Q = CreateQueue();</span><br><span class="line">AddQ(Q,<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; Q-&gt;rear-&gt;Data &lt;&lt; endl;</span><br><span class="line">AddQ(Q,<span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; Q-&gt;rear-&gt;Data &lt;&lt; endl;</span><br><span class="line">AddQ(Q,<span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; Q-&gt;rear-&gt;Data &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">printf(<span class="string">&quot;out:%d\n&quot;</span>,DeleteQ(Q));</span><br><span class="line">printf(<span class="string">&quot;out:%d\n&quot;</span>,DeleteQ(Q));</span><br><span class="line">printf(<span class="string">&quot;out:%d\n&quot;</span>,DeleteQ(Q));</span><br><span class="line">printf(<span class="string">&quot;%d\n&quot;</span>,DeleteQ(Q));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于OpenCV与爬虫读取分析官方的动态接口来实现的健康码识别</title>
      <link href="/2022/06/26/%E5%9F%BA%E4%BA%8EOpenCV%E4%B8%8E%E7%88%AC%E8%99%AB%E8%AF%BB%E5%8F%96%E5%88%86%E6%9E%90%E5%AE%98%E6%96%B9%E7%9A%84%E5%8A%A8%E6%80%81%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%81%A5%E5%BA%B7%E7%A0%81%E8%AF%86%E5%88%AB/"/>
      <url>/2022/06/26/%E5%9F%BA%E4%BA%8EOpenCV%E4%B8%8E%E7%88%AC%E8%99%AB%E8%AF%BB%E5%8F%96%E5%88%86%E6%9E%90%E5%AE%98%E6%96%B9%E7%9A%84%E5%8A%A8%E6%80%81%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%81%A5%E5%BA%B7%E7%A0%81%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>Notes:</strong></p><p>看到 CSDN上 健康码识别 基本都是通过 OpenCV 色块检测 + OCR AI文字识别检测时间 的 方式 来进行 健康码状态的识别。嗯，我感觉…这个好像不是很靠谱….. 毕竟健康码和图片文字是可以伪造的。或者说 如果你用 不久前的 截图 不就可以萌混过关了嘛 。。。<br>ο(=• ω &lt;=)づ☆.。欸嘿~~~<br>所以 我想试试 能不能 通过获取二维码的实际数据来判断 健康码是否是真的健康</p><p>所以这里 使用 上海的 随申码 来做样例。</p><ol><li>整体步骤：二维码识别 —-&gt; 爬虫获取健康码状态数据 —-&gt; Json 解析成 人看的 </li></ol><hr><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h1><ol><li>所需Python模块：<pre><code> &lt;1&gt; pyzbar ----&gt; 二维码解析 &lt;2&gt; requests ----&gt; 爬虫 &lt;3&gt; OpenCV ----&gt; 获取图像 &lt;4&gt; ast ----&gt; 字符串 转 字典 </code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyzbar <span class="keyword">import</span> pyzbar</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> ast</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="2-二维码识别-部分"><a href="#2-二维码识别-部分" class="headerlink" title="2. 二维码识别 部分"></a>2. 二维码识别 部分</h1><p><strong>这里我使用了 电脑摄像头来进行 识别。</strong></p><h3 id="1-gt-OpenCV-代码框架："><a href="#1-gt-OpenCV-代码框架：" class="headerlink" title="1&gt; OpenCV 代码框架："></a>1&gt; OpenCV 代码框架：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>) <span class="comment"># 参数 = 0 为开启电脑摄像头, 若填路径则为开启视频文件</span></span><br><span class="line">isOpened = cap.isOpened() <span class="comment"># 判断摄像头是否正常开启</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> isOpened:</span><br><span class="line">    flag, frame = cap.read()</span><br><span class="line">    <span class="comment"># 二维码解析 部分</span></span><br><span class="line"><span class="comment"># 爬虫 程序</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>这里简要解释一下 OpenCV 这里的代码含义：</p><ul><li>通过 cap = cv2.VideoCapture(0) 开启摄像头 并套入循环 从而 通过 cap.read 不断获取摄像头每帧的图片，这里的 frame 即为图片数据，flag 为 是否成功读取到 图片。 </li><li> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>   这串代码 功能 为 按 q 键 停止运行摄像头 </li></ul><h3 id="2-gt-pyzbar-二维码解析："><a href="#2-gt-pyzbar-二维码解析：" class="headerlink" title="2&gt; pyzbar 二维码解析："></a>2&gt; pyzbar 二维码解析：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bacodes = pyzbar.decode(frame, symbols=[pyzbar.ZBarSymbol.QRCODE])</span><br><span class="line"><span class="keyword">for</span> bacode <span class="keyword">in</span> bacodes:</span><br><span class="line">    url = bacode.data.decode(<span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure><p>解释一下 这里的代码含义：</p><p>通过之前 OpenCV 摄像头 获取的图片数据 frame 传入给  pyzbar.decode()函数 来解析，在这里我们可以获取到 二维码 所指向的 目标地址 data 以及 二维码坐标 和 长宽大小，我们这里 直接取 data  指向的 网址 通过<br>    for bacode in bacodes:<br>    &nbsp;&nbsp;&nbsp;&nbsp;url = bacode.data.decode(“UTF-8”)<br>   来获取到 目标网址 url （这里要 声明是 UTF-8 编码的）</p><blockquote><p>url =  ‘<a href="https://s.sh.gov.cn/XXXXXXXXXXXXXXXXXXXXXXX&#39;">https://s.sh.gov.cn/XXXXXXXXXXXXXXXXXXXXXXX&#39;</a></p></blockquote><p>如果 你打开这里网址 你会发现  这里会直接给出 你的 健康码状态<br>嗯，非常好！那么 我们如果直接  获取其html数据 不就能准确判定 了嘛。。<br><img src="https://img-blog.csdnimg.cn/7c79adfd2023446196c152cb6c451334.png" alt="结果"></p><hr><h1 id="3-爬虫-部分"><a href="#3-爬虫-部分" class="headerlink" title="3. 爬虫 部分"></a>3. 爬虫 部分</h1><p>好！优势在我<br>这就动手，先在上面那个网页中 F12 凑一眼 定位一下这个 “绿色”<br><img src="https://img-blog.csdnimg.cn/820761806cfb457790efa50b6314611e.png" alt="在这里插入图片描述"><br>搜噶 搜噶 ，原来 在这个 id = “app” 的 div里头啊</p><p>好！ 导入requests模块来获取url地址下的整体数据凑一眼试试</p><h3 id="1-gt-试手1："><a href="#1-gt-试手1：" class="headerlink" title="1&gt; 试手1："></a>1&gt; 试手1：</h3><p>（这里还是 需要声明是 UTF-8 编码的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar_req = requests.get(tar_url, <span class="string">&#x27;lxml&#x27;</span>)  <span class="comment"># 使用 lxml 来解析</span></span><br><span class="line">tar_req.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(tar_req.text)</span><br></pre></td></tr></table></figure><p>嗯嗯。。嗯？。。嗯？？？？<br>内容呢？？？<br><img src="https://img-blog.csdnimg.cn/6e9f16754f0a4dce9fb8e70fb8d45c3c.png" alt="在这里插入图片描述"><br>wait。。wait，stay cool<br>先看看 html源码</p><p><img src="https://img-blog.csdnimg.cn/bb5e93b460f2446db6f9d3895529a6fa.png" alt="在这里插入图片描述"><br>emm…. 好像这里官方用了 Ajax 异步加载，通过JavaScript 动态生成了网页内容</p><h3 id="2-gt-试手2："><a href="#2-gt-试手2：" class="headerlink" title="2&gt; 试手2："></a>2&gt; 试手2：</h3><h4 id="理论部分："><a href="#理论部分：" class="headerlink" title="理论部分："></a>理论部分：</h4><p>既然它 通过 js 动态渲染了，那么 这里我们需要去 找到 对应的 JS文件所实时返回的 数据接口。接下来就是 愉快的解密环节</p><p>老方法，游览器中 F12 一下 </p><ol><li>首先打开网页调试工具 </li><li>进入network 选项卡</li><li>选择xhr类型</li><li>刷新一下网页页面</li><li>找到xhr类的文件<br><img src="https://img-blog.csdnimg.cn/0a2308406f28488dbba1a25fbed2da78.png" alt="在这里插入图片描述"><br>嗯 这里就存在唯一 一个文件，我们点击它打开 就能如图所示<br>这里我们 可以看到 三个数据类别：code , data , message<br>其中只有 code 和 data 存在 有用信息，那么这两个哪个是我们需要的信息呢？</li></ol><p>啊。。。好像二维码过期了<br>（所以这里申明一下，健康码好像是每分钟都会重新刷新一次）<br><img src="https://img-blog.csdnimg.cn/9826b6e9506540a7a8bb609f15a42f67.png" alt="在这里插入图片描述"><br>看来我们得 重新识别一下二维码了。。<br>等等！wait！这里 code ：“1” 了<br>看来我们可以确定一点 code 是用来 判断 二维码是否有效的参数<br><img src="https://img-blog.csdnimg.cn/842db491b603490e99d7554c83cc25e2.png#pic_center" alt="在这里插入图片描述"><br>那么 我们可以锁定 我们所需要的数据 应该是 在 data 里面<br>data里包含了 2个数据  “type”:”00” 和 “usertype”:”1<br>因为 我没有 红码的小伙伴帮忙做对比，那么只能通过查询JS 源码 来 确认数据了<br>之前 我们看 html源码 可以知道 我们数据 是 藏在 id = “app” 的 div 里头<br>所以 这里 我们 还是将 刚刚 的 xhr类 换成 all 可以看到 有个 app.xxx.js的文件在实时数据里面，我们点开它<br><img src="https://img-blog.csdnimg.cn/1b4da4a9988d4f5498996aed205b8ff9.png" alt="在这里插入图片描述"><br>ctrl + F 打开代码搜索，我们搜索一下 type的值 “00”</p><p>啊！ 一步到位, 这里我们 获取到了 三个 高度相关数据<br>好 type = 高度嫌疑犯<br><img src="https://img-blog.csdnimg.cn/6c9f624610a645708b9971a3cfd0ef3e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ba9346dfbfaa442e8d1f00d398577d2e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/13e40107559a4a96bc87ba0d1b27a841.png" alt="在这里插入图片描述"><br>另一个 “usertype”:”1” 我也试了下，发现查出来的数据 好像 并没有多少相关性<br>那么 我们先暂定 这个 type 的值 应该就是 判定黄码 绿码 红码 的 关键值<br>之后，先找找有没有相关的 官方API 说明<br><img src="https://img-blog.csdnimg.cn/dee4cb8860874cbbb447d73de96c2b44.png" alt="在这里插入图片描述"><br>啊！  还真有个。。。 结合 上面我们自己解析的JS源码数据，我们可以定位 这个 type值 就是 判定信息的关键。</p><p>既然是Ajax 异步加载 ， 那么我们需要通过 获取实时的 xhr 数据 来得到我们想要的type值。因此 这里我们需要得到动态数据接口，还是老位置xhr，我们打开 它的Headers数据<br><img src="https://img-blog.csdnimg.cn/85b2dd86e2b841898457143bf6f3a4fc.png" alt="在这里插入图片描述"><br>得到了 Request URL地址，那么我们只需要使用爬虫直接访问到这个URL 就能得到我们想要的 JSON数据了。但是 Wait！我们刚刚提到过 一个很关键的一点：健康码是动态变化的，每分钟 他都会重新刷新一遍，因此 又到解密环境了。<br><img src="https://img-blog.csdnimg.cn/adcbb04ba6b942568d76754f91377207.png" alt="在这里插入图片描述"><br>通过几次健康码刷新后的对比 可以得出  它的这个uid 的值 是变化的，那么我们只需要得到这个uid的值即可<br>得到这个uid 其实也很简单，我们可以通过访问健康码二维码的data指向网址就可以观察出了（这里可以回到上文二维码识别的 2&gt; pyzbar 二维码解析部分去看看）<br>url = ‘<a href="https://s.sh.gov.cn/XXXXXXXXXXXXXXXXXXXXXXX%E2%80%99">https://s.sh.gov.cn/XXXXXXXXXXXXXXXXXXXXXXX’</a><br>通过观察 二维码所指向的网址 中 XXXXXXXXXXX 部分 和 uid = xxxxxxxxxxx 是相同的<br>那么我们只需要写个 算法 来分割字符串 取出其中的 xxxx 就行了</p><h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><p>通过字符串切割 取出 uid 的值，构建 实时数据地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uid = url[<span class="built_in">str</span>(url).find(<span class="string">&quot;.cn/&quot;</span>) + <span class="number">4</span>:]</span><br><span class="line">tar_url = <span class="string">f&quot;https://suishenmafront1.sh.gov.cn/smzy/yqfkewm/ssm/ewmcheck?uid=<span class="subst">&#123;uid&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>访问目标地址 并print出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar_req = requests.get(tar_url, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">tar_req.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(tar_req.text)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4744fa32cf31494f91c4a28e5d038c1d.png" alt="在这里插入图片描述"><br>ok 了！ 不过。。这个反斜杠。。。可真丑！</p><p>那么 我们需要将这个 翻译成 人看的 （json转python）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar_json = tar_req.json()</span><br><span class="line"><span class="built_in">print</span>(tar_json)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/bf990b4ba4274a6e90273913758333ae.png" alt="在这里插入图片描述"></p><p>好，到这里 我们终于达成了 我们的目的。不过这里有个需要说明的 我们所需要的type 被 usertype 一起混进了一个字符串里头了, 所以如果这里我们光光通过 tar_json = tar_req.json()[“data”][“type”]来取出 我们需要的元素是不可能的  ———-&gt; “TypeError” ，因此在这里我们就需要使用到 ast 模块 来将 字符串 转成 字典再取出type</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar_json = ast.literal_eval(tar_req.json()[<span class="string">&quot;data&quot;</span>])[<span class="string">&quot;type&quot;</span>]</span><br></pre></td></tr></table></figure><p>到这里 我们终于得到了我们所想要得到的 健康码判定值了</p><h1 id="4-源码"><a href="#4-源码" class="headerlink" title="4. 源码"></a>4. 源码</h1><p>源码开源到 我的 Github 上了 ： </p><blockquote><p><a href="https://github.com/Panzer-Jack/Health-QRcode-Detect">https://github.com/Panzer-Jack/Health-QRcode-Detect</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-边缘检测</title>
      <link href="/2022/06/01/OpenCV-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
      <url>/2022/06/01/OpenCV-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h1><ol><li>sobel算子模板  2.图片卷积  3.阈值判定</li></ol><hr><hr><h1 id="2-源码实现"><a href="#2-源码实现" class="headerlink" title="2.源码实现"></a>2.源码实现</h1><pre><code>import mathimport cv2import numpy as npimg = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)imgInfo = img.shapeyu = 100gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)dst = np.zeros((imgInfo[0], imgInfo[1], 1), np.uint8)for i in range(0, imgInfo[0]-2):    for j in range(0, imgInfo[1]-2):        gy = gray[i, j]*1 + gray[i, j+1]*2 + gray[i, j+2]*1 - gray[i+2, j]*1 - gray[i+2, j+1]*2 - gray[i+2, j+2]*1        gx = gray[i, j]*1 - gray[i, j+2]*1 + gray[i+1, j]*2 - gray[i+1, j+2]*2 + gray[i+2, j]*1 - gray[i+2, j+2]*1        grad = math.sqrt(math.pow(gy, 2) + math.pow(gx, 2))        if grad &gt; yu:            dst[i, j] = 255        else:            dst[i, j] = 0cv2.imshow(&quot;dst&quot;, dst)cv2.waitKey(0)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> OpenCV </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-毛玻璃算法</title>
      <link href="/2022/06/01/OpenCV-%E6%AF%9B%E7%8E%BB%E7%92%83%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/01/OpenCV-%E6%AF%9B%E7%8E%BB%E7%92%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h5 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h5><ol><li>首先让 目标图像 获取 一遍原图像所有像素点的BGR, 因为 该算法实现会导致最外围的 maoRange 为 黑点</li><li>其次使 目标图像 使用随机数算法获取 maoRange 内随机一个像素点</li><li>maoRange 为 规定的毛玻璃效果范围</li></ol><hr><h1 id="1-马赛克算法"><a href="#1-马赛克算法" class="headerlink" title="1. 马赛克算法"></a>1. 马赛克算法</h1><pre><code>import randomimport cv2import numpy as npimg = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)imgInfo = img.shapedst = np.zeros((imgInfo[0], imgInfo[1], imgInfo[2]), np.uint8)maoRange = 8for m in range(0, imgInfo[0]):    for n in range(0, imgInfo[1]):            dst[m, n] = img[m, n]for m in range(0, imgInfo[0]-maoRange):    for n in range(0, imgInfo[1]-maoRange):            dst[m, n] = img[m+int(random.uniform(0, maoRange)), n+int(random.uniform(0, maoRange))]cv2.imshow(&quot;dst&quot;, dst)cv2.waitKey(0)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> OpenCV </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-马赛克算法</title>
      <link href="/2022/06/01/OpenCV-%E9%A9%AC%E8%B5%9B%E5%85%8B%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/01/OpenCV-%E9%A9%AC%E8%B5%9B%E5%85%8B%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h5 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h5><p>m,n 变量为所取马赛克范围</p><hr><h1 id="1-马赛克算法"><a href="#1-马赛克算法" class="headerlink" title="1. 马赛克算法"></a>1. 马赛克算法</h1><pre><code>import cv2import numpy as npimg = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)imgInfo = img.shapefor m in range(100, 150):    for n in range(100, 150):        if m%10 == 0 and n%10 == 0:            for i in range(0, 10):                for j in range(0, 10):                    (b, g, r) = img[m, n]                    img[i+m, j+n] = (b, g, r)cv2.imshow(&quot;dst&quot;, img)cv2.waitKey(0)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> OpenCV </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-颜色反转算法</title>
      <link href="/2022/06/01/OpenCV-%E9%A2%9C%E8%89%B2%E5%8F%8D%E8%BD%AC%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/01/OpenCV-%E9%A2%9C%E8%89%B2%E5%8F%8D%E8%BD%AC%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h5 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h5><ol><li>灰度图像颜色反转</li><li>彩色图像颜色反转</li></ol><hr><h1 id="1-灰度图像颜色反转"><a href="#1-灰度图像颜色反转" class="headerlink" title="1. 灰度图像颜色反转"></a>1. 灰度图像颜色反转</h1><pre><code>import cv2import numpy as npimg = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)imgInfo = img.shapedst = np.zeros((imgInfo[0], imgInfo[1], 1), np.uint8)for i in range(0, imgInfo[0]):    for j in range(0, imgInfo[1]):        dst[i, j] = 255-imgGray[i, j]cv2.imshow(&quot;&quot;, dst)cv2.waitKey(0)</code></pre><hr><h1 id="2-彩色图像颜色反转"><a href="#2-彩色图像颜色反转" class="headerlink" title="2. 彩色图像颜色反转"></a>2. 彩色图像颜色反转</h1><pre><code>import cv2import numpy as npimg = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)imgInfo = img.shapedst = np.zeros((imgInfo[0], imgInfo[1], 3), np.uint8)for i in range(0, imgInfo[0]):    for j in range(0, imgInfo[1]):        dst[i, j] = 255-img[i, j]cv2.imshow(&quot;&quot;, dst)cv2.waitKey(0)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> OpenCV </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-灰度算法[API与源码实现]</title>
      <link href="/2022/06/01/OpenCV-%E7%81%B0%E5%BA%A6%E8%BD%AC%E6%8D%A2-API%E4%B8%8E%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/06/01/OpenCV-%E7%81%B0%E5%BA%A6%E8%BD%AC%E6%8D%A2-API%E4%B8%8E%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h5 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h5><ol><li>API调用（2个方法）</li><li>源码实现法（2个方法）</li></ol><hr><h1 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h1><h2 id="API调用法1-—-gt-imread-改参"><a href="#API调用法1-—-gt-imread-改参" class="headerlink" title="API调用法1 —-&gt; imread 改参"></a>API调用法1 —-&gt; imread 改参</h2><pre><code>import cv2import numpy as npimg = cv2.imread(&quot;../01_Img/01.jpg&quot;, 0)cv2.imshow(&quot;&quot;, img)cv2.waitKey(0)</code></pre><h2 id="API调用法2-—-gt-cvtColor-函数"><a href="#API调用法2-—-gt-cvtColor-函数" class="headerlink" title="API调用法2 —-&gt; cvtColor 函数"></a>API调用法2 —-&gt; cvtColor 函数</h2><pre><code>import cv2import numpy as np# 方法2 ----&gt; cvtColor 函数img = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)dst = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)cv2.imshow(&quot;&quot;, dst)cv2.waitKey(0)</code></pre><hr><h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h1><h2 id="源码实现法1-—-gt-均值法"><a href="#源码实现法1-—-gt-均值法" class="headerlink" title="源码实现法1 —-&gt; 均值法"></a>源码实现法1 —-&gt; 均值法</h2><pre><code>import cv2import numpy as npimg = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)imgInfo = img.shapedst = np.zeros((imgInfo[0], imgInfo[1], imgInfo[2]), np.uint8)for i in range(0, imgInfo[0]):    for j in range(0, imgInfo[1]):        (b, g, r) = img[i, j]        gray = (int(b)+int(g)+int(r))/3        dst[i, j] = (gray, gray, gray)cv2.imshow(&quot;&quot;, dst)cv2.waitKey(0)</code></pre><h2 id="源码实现法2-—-gt-心理学法"><a href="#源码实现法2-—-gt-心理学法" class="headerlink" title="源码实现法2 —-&gt;  心理学法"></a>源码实现法2 —-&gt;  心理学法</h2><pre><code>import cv2import numpy as np# 心理学法：gray = r*0.299+g*0.587+b*0.114img = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)imgInfo = img.shapedst = np.zeros((imgInfo[0], imgInfo[1], imgInfo[2]), np.uint8)for i in range(0, imgInfo[0]):    for j in range(0, imgInfo[1]):        (b, g, r) = img[i, j]        gray = r * 0.299 + g * 0.587 + b * 0.114        dst[i, j] = (gray, gray, gray)cv2.imshow(&quot;&quot;, dst)cv2.waitKey(0)</code></pre><hr><h1 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h1><ol><li><p>整型 速度快于 浮点型</p></li><li><p>+-运算 速度快于 */运算</p><pre><code> import cv2 import numpy as np</code></pre></li></ol><pre><code>    img = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)    imgInfo = img.shape    dst = np.zeros((imgInfo[0], imgInfo[1], imgInfo[2]), np.uint8)    for i in range(0, imgInfo[0]):        for j in range(0, imgInfo[1]):            (b, g, r) = img[i, j]            # gray = (r * 1 + g * 2 + b * 1)/4            gray = (r + (g&lt;&lt;1) + b) &gt;&gt; 2            dst[i, j] = (gray, gray, gray)    cv2.imshow(&quot;&quot;, dst)    cv2.waitKey(0)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> OpenCV </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-图片缩放算法[双线性插值法]</title>
      <link href="/2022/05/31/OpenCV-%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E6%B3%95/"/>
      <url>/2022/05/31/OpenCV-%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="双线性插值法"><a href="#双线性插值法" class="headerlink" title="双线性插值法"></a>双线性插值法</h1><p>举例：<img src="/2022/05/31/OpenCV-%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E6%B3%95/1.png"><br>Note: 百分之多少看小数点<br>A1 = 20% * 上方的点 + 80% * 下方的点<br>A2 同上<br>B1 = 30% * 左边的点 + 70% * 右边的点<br>B2 同上<br>最终点 = A1 * 30% + A2 * 70%<br>最终点 = B1 * 20% + B2 * 80%</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> OpenCV </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-图片缩放算法[最近领域插值法]</title>
      <link href="/2022/05/31/OpenCV-%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE-%E6%9C%80%E8%BF%91%E9%A2%86%E5%9F%9F%E6%8F%92%E5%80%BC%E6%B3%95/"/>
      <url>/2022/05/31/OpenCV-%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE-%E6%9C%80%E8%BF%91%E9%A2%86%E5%9F%9F%E6%8F%92%E5%80%BC%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="最近领域插值法"><a href="#最近领域插值法" class="headerlink" title="最近领域插值法"></a>最近领域插值法</h1><p>img.jpg = 10<em>20  —-&gt;  dst_img.jpg = 5</em>10<br>功能：图片缩放<br>案例：<br>    dst_img(1, 2) &lt;—- img(2, 4)<br>    dst_img的x=1 来自 img的x=2<br>    原图像的 x = 目标图像的 x*(原图像的行/目标图像的行)  —-&gt;  原图像的 2 = 目标图像的 1*(10/5)<br>    原图像的 y = 目标图像的 y*(原图像的列/目标图像的列)  —-&gt;  原图像的 4 = 目标图像的 2*(20/10)<br>    如果 x 或 y = 浮点型, 则结果化为整型 —-&gt;  原图像的 x = 114.514 = 目标图像的 x = 114</p><p>Python 源码实现:</p><pre><code>import cv2import numpy as npimg = cv2.imread(&quot;../01_Img/01.jpg&quot;, 1)imgInfo = img.shapeimg_height, img_width, img_mode = imgInfodst_height = int(img_height/2)dst_width = int(img_width/2)dstImage = np.zeros((dst_height, dst_width, 3), np.uint8)  # 0 ~ 255for i in range(0, dst_height):  # 行信息    for j in range(0, dst_width):  # 列信息        iNew = int(i*(img_height*1.0/dst_height))        jNew = int(j*(img_width*1.0/dst_width))        dstImage[i, j] = img[iNew, jNew]cv2.imshow(&quot;dstImage&quot;, dstImage)cv2.waitKey(0)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> OpenCV </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术栈学习-自我规划书（#TODO）</title>
      <link href="/2022/05/10/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AD%A6%E4%B9%A0-%E8%87%AA%E6%88%91%E8%A7%84%E5%88%92%E4%B9%A6/"/>
      <url>/2022/05/10/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AD%A6%E4%B9%A0-%E8%87%AA%E6%88%91%E8%A7%84%E5%88%92%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="344b1251ded8231b47d36111d5c0e1d62c658bd767d12a0ef8e3928c8959116a">aa38e56d6d2959f7204b7609163f2e36c7346fcd595e2ac9c0b1aa59519f81e24d33ef1c31e2f54814816c64c78760f71992f0711a3d8e7831d47c1b22b30af8b675ccf6e8f72362c8a74cc143f0aa308a4808242f711b63b603e30c8ee44bb40a54baf9bd52f398e68704b6d066c2bca43a7483f8462f420aec27ba0c478f30cd11542ceca0bfee7d76e4121b3efa8bfc1845c7e74f725ac71182713c3794572ab99e96997ebb8370212cb2efa5b96bf4e8030b33c236d1eba5f97e7df41ef64601203bf0104e2a7acd39d4935bd5c7a4b78d384602ab2847189bdd76a264eb567c8bb22630f97391c0f3f8f84a65f2df1cdec1ba8e4104e890d486b0eb5c6ad2b4b626f4260ee5f51fa59faafca288be4da66c27399aa5c8d7f5335ba1484ec7125093e98152c89af2aef78603b2ff617895a60da2c6ba477eb377e3927be0c27ee84e6ddd4a3eb8bd4d7912d318970e2449b04eca29e1f623b077be3ce3a427396be523c39dde81bf091d341f9393140607b00ee8cac2d0b53b2a174e5b238d1b123864ad6a80f7465ab04c14f9af792f75ac1785ac3cd2f980734ea47c463d0160807b612362e79cef342def3b0b5641efae8dbe7f8f96036751814e212f015aa157a0b677998a9961a4ba69ed27b85c679d25894fe7968cfa7253f6b91a1103aa5c82e272f24f8ae2e75403b1f5d0b33992d7ca8275c141819b24f360dde74fdca40884d4196d6bad159c9ec5d575fe6ef36d3cbda9852aabbc59e2efb21823696f9b0bf2e98f268100c6a7f72ad3e216caaa36b43ad804ab81c7654b55413a894395f8f838448982a92a478564df531f43980414f381eee33f5469b3aa01f214e3b6c73f3c51538f0616f8f1bb9419c6fd5f7a50b88f7f4b945c82a226b68ee06e5988aca4d572030207c002d3f5ea26ab2100340508b2be4f0d57545395b76b42972f2d2f653eb475b8584bc29830157264ac13a33596c4767927bf84099f0e90bca469994ba70822b24a6f29dad396e95dd44b4adf1b80a5cebcca61edc4ffb13b7c3f5115e478092485e8b85fece93c37831a9f4969604341f21aa548209d08ec88ab7ef33c202fc582471e03a01eb1bb2079c56e41e394143cd89d3025a214b927bf92caba322e808ecf85d44b28bf7314e2adff7dfe10e9d93f2dbaadcbbdf339bd7ef1b673d08f8be3a23982fdaeb74f54125ee4066715a4b6f6594efb506ebc8db956989346c60b3b715932b28b3889f00f18a6d7eea4bc2e73c01c36b4174cfc9513a6c7ffcbb471129b774542ff90c0161c4c24133b6f2618573f376811054f7d3c18eb95d47e93afb66b4b55552ba5607e2f36b93210ebf80d8634685f6f171f6093e85e1c6530b4159b7e478ae195db536e880b8d636b6621baac7baf98fd08e3179e4e52d8d363174a6c492e96267387612869b19649022a15dfa1cebe2963c195b28ff4626985ce9164616b8c73880ea5a910a5fa03f4c261fa9c860e9b759ae90ef471ea8a22c8c01064efa3b62908712440b359f179f9f210f8166cf0d606f115602b915e12ab2e7acd7bb6ac35ccb334aa1fb7521588434a2e1f670fbf3c86011705f953039e7fb61f7fed002fa8a48ac4f9948af53f7a8abc9c3e742624432723fa9b49bbe884ccb93bbf4cc6f43d10b3902c4790f4a70c83d1b145cf4b34af4f82a449bfc0e32110bbc843639a0f8af323cd73f9a434ef850eb122609f3074c8d87087ba7a1bcd880d1906f25c5f597ae33888f1a27838734acd8bde6b621a535702340310767593dba7fcc3a76b043d4449ad224ec5bd7624b935d2e6fffc7b99463f42bf7d6657cef63532901c14d8dc346c28ce9513b72102d75b826c116bf6605f38445ebc1a09e4f29a0c0bcc49c4e63010fc4502add038cfbcb37221cae74650682b126250c1c3eaca4b3a4d8a5ddfad1297562b4d7735e245c9df684bc1ed1edf07487fecc75a310a46209c005bd727db2135728ae4f8e5b2aa5340dff36ab4f803718b79f63e31dc8b581adebc194cd3eeff313b56b2161a1f3a668e2bdd21584e5dada605380afa2a32783549630cadcaefaa8be4a914a5427c7bf2f6567d54be7ef538715bd1d2225c1397a389e4e8053e97af07609fce76a3c4bb63b5732bfe701072f1b367a96a1310293908deb2b2ee334b4777952efe3aa94248b487836c2d87219933b7410f1d6c54a0f51c8bc062a36665ec44002e69fdabce90799be640cb0fe53ec0400405923755bbc3e644ac7052202164c3ba0acf661e8867c7bfa970bfdf9e463acaba10eb1be81942340cd390653b5cac22980af133f3f540427134867a6c0ba357fe8b4a8ccfda27307fbf9f54986bcb837823695eb8d3aba146ee55630c2f8d4ce04c978a9fc57fd395af396dd8366e47824cb037e0f9d2fb01cc5cb699d6761a19f8e48a32895e1d907be93eeb231073fcf4cc1b15124bc90c9483cd9b5507c2482805144f40995ac407c2609559e65db3b2debef21a1382b207f767abb0b8dd30b9e643ff899dedb3c223e80a08afc7e884a824266043b547d530c950fc5081a04a563ed2111d8ce37dc556a95c70ed22718113e1f17e3289974108b20828bee240c5684b5b8d34fe116a21843bf9b7680d6e4c727bca37ccef497e94129c831add77afc510b8a0e34fd76861a032b713fde2ec41535b1479254afd83017e9403c17cb8cfbfc309ac820ef36b156fb0a3c5fa88d05f47f7e042114d4237df280c2b06645ced5e61c67fb49bedae774790345022e09b71ca1f79da24cfe5fdc2122e8584e50ea0dc6ddc5af9035ff46176504d4b7ac3f53211d04b6cdd2d3a962516d75973965bcc7bbe71b35f138aad56e899f6b3e65d1deeb4560d4e344ad7b3afdc94c9175445f02125b6e8780788d5bfd86e01516fb3950b31656dc42fa0a07dc702b804d0188c11ccba7bd15911974cd99a0216a3e742d5375bfa31f31b89fb59db0b1645b75867807b2ee9c5f8529d25af719e570154c59892c1037a5eaaef407f2019e4ca697ccc8ea1e8829fa375ddf1237efc3de4510f8373ea465aa9e43a14029575f804727b82a7065516ce8a8fc46708a3d06ef50fdf7a1daf93323791054030c38230d03f68cdb97a5619190cc8e7e4ef9f2e85fb6ea99254bcd22595d0ff3e10a51c82691368f40926e2305c827c27bc7af5cb0089bc0841f679db0300be466c88d088ea703219607478c1b88d82c43271de396349651b7f7f9f5b226026d505056848687a996605fde306c803be51a694764d6f5d86d1496e7d221ece5c9dcd05337c53d12135f11de09f2ad9a6fed6a481d72a7d0d33b71c5268d4024d265f6980886741ba25f0a391958febb033150d2d65731bfe792ba1e18511263064e0558524e8f93082054c94e2f56a19935dd8cd8877ac78138e2d3a1870a753417ca32962f05b8318e0473dfffa98543f5d0e72d9ef12418df10c215c32b270a5bc1f6da69f5ea2ae3cc580121e91a8c8e8889f395b8b9b222b22a1bd416186b782443d210871654d7c17ab25d444e98718495a22354b38649d517d258208dfa4f6098a1f9c82fb10ff2beaf8f71a1d9428d653c4cf851ed19f4948cf2189d5c575eb0b332b83d6f0f1faa5aa5b35c7ae024d6dfcc87b14afff5ca0bc4f1195e04e53dcaeb1482e6f2c2e5fdf3655d3ac71fb30507a943555f58c50c21212f6a473b22d2f75fb4dc1d8f83f0ee80b145c165a8ef6ca5774f6a944b6f53a8a719c5a100cb798af98b94d52280eaf0953c34b81d4bf5b108066895a1ae81676cb02c7d9ed4a7ce5ea013b0a532fce32c589bdd77562d91ce5ecfd36b36db611b8ce74dc6c0633a213cf317d6d0acb9e2f09a1e5fbcbd95f265e919716d07a9ec2b2f71ff625c9811af3499cd4ea1c94bfadae07f5b9e9bab69c4a88e3c76d9aa4d1df85711cca09dbf3b17c516c84c631cfea1be6c316adc6039e2fbf248e10f6d5c179e58bbb0c69e7feceedf1f38b054cd67c351453f54c5b5f4fb5591a144952b53b4f9bbd0e2844d6e7f6f1fe208da2d5b7e2ed96f39d949fd0d85b03eb1948a78bba4cf94e065199845cec736de7d1661bf3483921f9f0f546284bc37242e1220ab2f0ce683ffc70da6120f679e886a111e531e469cc357c8b1764ba8237f66a8b718e0009fccaccfbfab5b8f74f13e2b64c7a6459f5b10a5a9609f598a1468cb024bb316e29c909c47942ef85b622ddd2cd68c53719b348db298b75329e2e8c6d8f1e6c3e7286c4d437e4fbbe0843c7978bd6b60d99c901c5468fa7a9d6342a36d3b742d18bd7fe46a41b4a49f1c455dadef6aca983d755192ca42a85fc9dcd6ae07b0613c04ce87afe0a12c6898167100a39f70168185581fcb6fb36d3e77fd76fcc527a418d7a4519cac9fbd922e867232b258796f00b0ad4d6a5c4065cad226b90a586361edd33b29684df4fdfc64328d10b647f95d2be2a59bdf5d0ae2efc6e4f4ae8dbd81a99b606c445d18008ee95537195c83ab170dfa6188f542a0060e2d0b4eff6733931857afbf9ed990fb83d91e470f3ab931802dc0089e4fa02916e1dd26391a32b9f305ff0ceff4026a0b1d8c308424098a00dfdda7ce2fcd42a2144ea35869e62f0a9a00cb504bd8f4a205d0265abfc6c8c037efd058f261135aa32b6db62190d1bf90c51281fa1cc90fb2f31238eb0decc7e50426537ddcd1986e06540f0e1a56277775381b07f6ec2b330163b9d37084c646cee2d3760b9d3a085f220df26b007306ed2dc6eb47d21d438a716fae8b597dce07d4124f43d04e4c163d04d63cfa953db68afac91ac9aa133fbdcdc187105541ebd2c7f4831b0e234ed31c7e34ace0028f5edc653b7d1c4919853feaaa6d5b236e7c7836f4a296c32851a52c334351aa244813d76998d9218705b7c89ad75ec80dcb058e4ca19499693ec103735a593f7c37e568180b3b0e969ca0b313ab6f9b4e1b35ce4224bc50c1bc532fde5bbde598f70b1826fa9efec5f928305711815833164f463be835f3201826dbce6daf3e27ff88557ba0aff95af8b3588952193a5398f927f2612a3cde357cadb6a94d744e355394666a73006cb8580de4eccd3547f7bffa88dd08630443d5ed2d7b541007a8d32ea9e51da970a61834a32c0e3a3125d8996ffec9c293789d8ba7ab3c2571c3c502e7bbdb021e585633190a396d56e7155dc32c9d0532cea7e1bd974b31a8177b76650baa48f39fe03e103c863f42783159b85c454dd8871a1f993c592e10ba29241ea5bab847dcb26752f8edcc305a9d704882c2293c4b3ffb7c6a8dd768e0f34324456c9600ed2889a808d97bf7879da23a0127aa2b51fe21e8552f97752a7d95f8cd3292a7018b4c25eff12c8ca39e8de57db83fb35f0f3ccfcc8cc41e0ebd335aa9039b7997ab61385599443cd3c768fe49b1a3087fe666f25617a8356989076a9d0f696783b0dadef577f15270d92cd3e947d07fa8af8e312fb4e58a88e8f570b3877055bd4b9e118b28953c10623a2b93cd05d320c9ca182649b3e43d3c1e10caa18ffede736f3e55b08814ef25387ece0e62472575945f99ae0e5a56428f2ace11e4fcfeaa5bf5b015406cfa4db911a7664e1d566c4b74fce466ee3a3efd38ca7dec1c5320d4437c02a7ac3170e3499c1055c7e95de9c2dc31dc564d7a8ec307e9f22f31dd09300f46f869628b4d258f760e177bc9f9b99d9aaf5e1d8c09468102fef941d0d113f73e186d699275e0f3e6ae4824d721d5ec1a61a32ac15e0d527fc875d08db1f9d7b361856ff694a055ba3316c64f62f2f59e433f926539ebb1173ca0408de791ba5dae6cbbc894b111438e0759378da03f497836843df4cbb7d833427334545a474b5f4b97a59c705f4cb73a13663a297a4c2c03e63272b2605e494f574876ad651615bc89721215dfcea69699646ee33906cab31f72e956931e249d1b81b17a7e934728445fec006213bcb078669247e93450862d8f867c818c39aba087362e838770bc63f28dc21f2e16905dc3c40e4eb7f491df28738d5ed858e73fc7d5e5e8312914d6f3c0ec5f7d6613ec1431c8e00d3773e670a947207ae35c332266cb9c5b5d1d2ef3aec59aa73bea6c1731dd8f184a4044d79f16cc7bae4ebbf15bd4127db708f4d032f95a4d49db284778539a144e67583f2b7fec1205cb5a3cbbd50732b51f35346cd8793ead21619a77ae44ca1eeb777434c4e34777166221d481fad1986a91caabdc234753938ef7e36da89815e14b8f4599bf5b8f648951d23bdfea98196ec95c5afe9c8a44b92fe542035b9ecb0af736deb9a31ad25e56fe4e8832b89739621d1dd676bf81844532382b8ffbcbf219920ce350709e8a92a94c5f4523ffe2f79a9c10d2d68942f288a4dcabb54e5da8497bcc0c815a883601028ea9c39823439817071c511103d3bc50884e55a7c16090953f9da7e1be16629fd71685de37e81054b635a99048d3d8ab06b1098903d8c2f3b398e89ce4967672857cbb1c215e25a22c1e030e47343effde634f7e2d30e289fb41894b9865299e8e0cfb2090de60b52a986c19ecf2aa9bf157ebb60196018ca8390b09aa8f7e64bc82b8a439f46ad531a1b8b867ef585c7340c0554cadad0b552c1d0a965de41801bf587e3354cf4cc7e2e816aedff083c3ca2ec17b2a683ded993d77cadfcf85094d3bcfd8a87ce4162e8f75bbebd0718443ea03f11f24fe8a3169c05ede4a70045f5d6813ef30f7ad85f069642c4c2cef75122d64112feb535e6aba0bb4c8097f7d5243c82a1e9c339b0d564c0fa11a61e92dcf56e4fe87a11c85a2d340c7324c96122b192c7353ee21714a1127e5311ba02a3d475af7e8104952afb7f709cb6c49313b55115f14b510cfe7cf7942189d7b3adc4c2d7254695a0330db95cac07f367ac7cf25eb71773bd690fb3a357a3eaf79ed11dfccf366a29f790b9fb61c33a1c22fc98650ff8af526b728794f77fc6a13f8d6391f090fb432f0f71bbb1024fc773f7655647f136918dbba12bd334a8fb02f9ec46ae2aaf9269d4c6aa8bf4eba55f95bba94b2aa0474d419bdd451b9e41b66bb8ba06a930638200e934eee4ad953d28ff10503eee253fdfa2dfab83b2bc17fd3bdf4ec88ba71bb4c3fd3bb1116ee418f4408fb0818be4817d257b6ec78c829e00ede50e0217e54ceef8581eb846e8e7aee2ed095978a8a4482df07a019b45e4d54f556e7af5d0ddcac44109cbdfe30cc89e1573ad676fbbea69e80e27f6d44761eeb8df60bbb43f1c352a9eba2a2c5f577b5af9b50255b8d0ac547965eb16eddf173b00ca8057b5fc28fb1c522648f4711ebf769d69ea8edd6835cca7bb44aab8e8c7327ed7b9c136a79704814496fb123e007ec5367d1116dd21508150928fc5a1068890921be042c5e591fa9c7f2f25d1425df1027e432a07e99d0afc8c3c908ad7f1e2ed45e2492d0a7a268917bc47549d8cd92122fa259ad2084ca7f4e8afeb6441439667f51a3b38aa66be0591ec10e37aae4744b2dd656f14abe58e12fea552cf6a6319ee964d83f35bfba38585a3c477cf3ea1f23b9653666ab05364354c6c2afc0079f3e4e0b4040f85c558b9cb01777647b3e24f161e84062824ead37302d11cda66d5fa3d643ffdb675d95f1896f7ab275d8fc5bffde036ef9825bddb9b3d3a6daa823515d879d1801e5cb561c01639a9082170f1395fcdde322b634568b0b40a2f462d889476b3ad7f988de4a23b42af7a2d3dc504c20dd837e414cbdd9be47fea9edcaee9cd9022172032d6282ad067d732106bf6bc26af0cbed25ff1bda99e1100058cea2f1303d9925ece24bc52f158e2e95cfb3ecb3ce38d2109a610b86922384bcf472ccc52780dd55e3abeda10158fd198e2825fb9be7e07344d54f9646c9446b93dcbd8c40b3c37d9c5306981c96d6c68edfd28b284c66fc717489dc758e33e60a66e3ff07725e50b103f0eb89e263766c93d0ef86b82a7fdfb45926d8740d7cabc8672d905d8856511ea00935b7581542bfc8f6fea9d90f42f7909215afd613f414b67a98f2abb903adc0a19cb2aef9d4a5f2f4327e65532752cb3396a130d647bf640c4fed70e31160878ac1ee3e3f703cd286e29e24b45a48ddab93432203a291730b1e9d50177e5869797e2997750e76bf3b9e0839c652cbed002ad40aa10e09137ea319b3534b12a185762a49ba6b2fda56dcb11327d84f923b1f2d31cb19654daea068da67045f7b5f39da96c0b686f161843b2cb2bb974c09e42aac8382a01c2bc9d95c2aecf8f55073b039dbfa74c2d5134a09599ec1f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">既然加密了！！。。。。。想看吗？ο(=• ω <=)づ☆.。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习规划书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;浙大&gt;数据结构·1.4栈的链表储存[线性结构]</title>
      <link href="/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-4%E6%A0%88%E7%9A%84%E9%93%BE%E8%A1%A8%E5%82%A8%E5%AD%98-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-4%E6%A0%88%E7%9A%84%E9%93%BE%E8%A1%A8%E5%82%A8%E5%AD%98-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-4栈的链表储存-线性结构"><a href="#1-4栈的链表储存-线性结构" class="headerlink" title="1.4栈的链表储存[线性结构]"></a>1.4栈的链表储存[线性结构]</h1><ul><li>栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。</li></ul><hr><p><br><br><br></p><h2 id="主要操作的实现"><a href="#主要操作的实现" class="headerlink" title="主要操作的实现:"></a>主要操作的实现:</h2><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;// 1.4栈的链表储存[线性结构]#define MAXSIZE 100   // 堆栈元素的最大个数typedef int ElementType; // ElementType 暂时定义为 int 类型 typedef struct SNode *Stack;struct SNode&#123;    ElementType Data;   // 存储堆栈元素    Stack Next;  // 记录栈顶元素下标 &#125;; Stack CreateStack();  // 初始化链栈 int IsEmpty(Stack S);  // 判断链栈是否为空 void Push(Stack S,ElementType item);  // 入栈 ElementType Pop(Stack S);  // 出栈// 初始化Stack CreateStack()&#123;    Stack S = new struct SNode;    Stack Next = NULL;    return S;&#125;// 是否为空int IsEmpty(Stack S)&#123;    return(S-&gt;Next == NULL);&#125;// 入栈void Push(Stack S, ElementType item)&#123;    Stack temp = new struct SNode;    temp-&gt;Data = item;    temp-&gt;Next = S-&gt;Next;    S-&gt;Next = temp;&#125;// 出栈ElementType Pop(Stack S)&#123;    Stack First = S-&gt;Next;    ElementType TopVal;    if(IsEmpty(S))    &#123;        cout &lt;&lt; &quot;IsEmpty !&quot; &lt;&lt; endl;        return 0;    &#125;    else    &#123;        TopVal = First-&gt;Data;        S-&gt;Next = First-&gt;Next;        delete First;        return TopVal;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;浙大&gt;数据结构·1.3栈的顺序储存[线性结构]</title>
      <link href="/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-3%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-3%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-3栈的顺序储存-线性结构"><a href="#1-3栈的顺序储存-线性结构" class="headerlink" title="1.3栈的顺序储存[线性结构]"></a>1.3栈的顺序储存[线性结构]</h1><ul><li>栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成</li></ul><hr><p><br><br><br></p><h2 id="主要操作的实现"><a href="#主要操作的实现" class="headerlink" title="主要操作的实现:"></a>主要操作的实现:</h2><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;// 1.3栈的顺序储存[线性结构]#define MAXSIZE 100   // 堆栈元素的最大个数typedef int ElementType; // ElementType 暂时定义为 int 类型 typedef struct SNode *Stack;struct SNode&#123;    ElementType Data[MAXSIZE];   // 存储堆栈元素    int Top;  // 记录栈顶元素下标 &#125;; Stack CreateStack();  // 初始化堆栈 int IsFull(Stack S); // 判断堆栈是否已满 int IsEmpty(Stack S);   // 判断堆栈是否为空 void Push(Stack S,ElementType item);   // 入栈 ElementType Pop(Stack S);   // 出栈// 初始化堆栈Stack CreateStack()&#123;    Stack S = new struct SNode;    S-&gt;Top = -1;    return S;&#125;// 是否已满int IsFull(Stack S)&#123;    return (S-&gt;Top == MAXSIZE-1);&#125;// 是否为空int IsEmpty(Stack S)&#123;    return (S-&gt;Top == -1);&#125;// 入栈void Push(Stack S, ElementType item)&#123;    if(IsFull(S))    &#123;        cout &lt;&lt; &quot;IsFull !&quot; &lt;&lt; endl;        return;    &#125;    else    &#123;        S-&gt;Top++;        S-&gt;Data[S-&gt;Top] = item;        return;    &#125;&#125;// 出栈ElementType Pop(Stack S)&#123;    if(IsEmpty(S))    &#123;        cout &lt;&lt; &quot;IsEmpty !&quot; &lt;&lt; endl;        return 0;    &#125;    else    &#123;        ElementType val = S-&gt;Data[S-&gt;Top];        S-&gt;Top--;        return val;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;浙大&gt;数据结构·1.2链表线性表[线性结构]</title>
      <link href="/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-2%E9%93%BE%E8%A1%A8%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-2%E9%93%BE%E8%A1%A8%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-2链表线性表-线性结构"><a href="#1-2链表线性表-线性结构" class="headerlink" title="1.2链表线性表[线性结构]"></a>1.2链表线性表[线性结构]</h1><ul><li>不要求逻辑上相邻的两个元素物理上也相邻；通过“链”建立起数据元素之间的逻辑关系。</li></ul><hr><p><br><br><br></p><h2 id="主要操作的实现"><a href="#主要操作的实现" class="headerlink" title="主要操作的实现:"></a>主要操作的实现:</h2><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;// 1.2链表线性表[线性结构]typedef int ElementType; // ElementType 可定义为任意类型typedef struct LNode *List;struct LNode&#123;    ElementType Data;   //数据域     List Next;   // 下一个链表的地址 &#125;; List L;List MakeEmpty(); //初始化链表 int Length(List L);  // 以遍历链表的方法求链表长度 List FindKth(int K,List L);  // 按序号查找 List Find(ElementType X,List L);  // 按值查找 List Insert(ElementType X,int i,List L);  //将 X 插入到第 i-1(i&gt;0) 个结点之后 List Delete(int i,List L); // 删除第 i(i&gt;0) 个结点 void Print(List L); // 输出链表元素 // 初始化链表List MakeEmpty()&#123;    List L = new struct LNode;    L = NULL;    return L;&#125;// 表长int Length(List L)&#123;    List p = L;    int cnt = 0;    while(p)    &#123;        p = p-&gt;Next;        cnt++;    &#125;    return cnt;&#125;// 按序差找List FindKth(int K, List L)&#123;    List p = L;    int cnt = 1;    while(p &amp;&amp; cnt&lt;K)    &#123;        p = p-&gt;Next;        cnt++;    &#125;    if(cnt == K)  return p;    else  return NULL;&#125;// 按值差找List Find(ElementType X, List L)&#123;    List p = L;    int cnt;    while(p &amp;&amp; p-&gt;Data!=X)  p = p-&gt;Next;    return p; // 若没有找到 则返回最后一个链表的Next，即NULL&#125;/* 插入1. 用 s 指向一个新的结点2. 用 p 指向链表的第 i-1 个结点 3. s-&gt;Next = p-&gt;Next，将 s 的下一个结点指向 p 的下一个结点 4. p-&gt;Next = s，将 p 的下一结点改为 s   */List Insert(ElementType X, int i, List L)&#123;    List p, s;    if(i == 1)    &#123;        s = new struct LNode;        s-&gt;Data = X;        s-&gt;Next = L;        return s;    &#125;    p = FindKth(i-1, L);    if(!p)    &#123;        cout &lt;&lt; &quot;Error&quot; &lt;&lt; endl;        return NULL;    &#125;    else    &#123;        s = new struct LNode;        s-&gt;Data = X;        s-&gt;Next = p-&gt;Next;        p-&gt;Next = s;        return L;    &#125;&#125;/* 删除1. 用 p 指向链表的第 i-1 个结点 2. 用 s 指向要被删除的的第 i 个结点3. p-&gt;Next = s-&gt;Next，p 指针指向 s 后面4. free(s)，释放空间 */List Delete(int i, List L)&#123;    List p, s;    if(i == 1)    &#123;        s = L;        if(L)  L = L-&gt;Next;        else return NULL;        delete s;        return L;    &#125;    p = FindKth(i-1, L);    if(!p || !(p-&gt;Next))    &#123;        cout &lt;&lt; &quot;ERROR!&quot; &lt;&lt; endl;        return NULL;    &#125;    else    &#123;        s = p-&gt;Next;        p-&gt;Next=s-&gt;Next;        delete s;        return L;    &#125;&#125;// 输出链表元素void Print(List L)&#123;    List t;    int flag = 1;    cout &lt;&lt; &quot;Present List is: &quot;;    for(t = L; t; t=t-&gt;Next)    &#123;        cout &lt;&lt; t-&gt;Data &lt;&lt; &#39; &#39;;        flag = 0;    &#125;    if(flag)  cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;浙大&gt;数据结构·1.1数组线性表[线性结构]</title>
      <link href="/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-1%E6%95%B0%E7%BB%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-1%E6%95%B0%E7%BB%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1数组线性表-线性结构"><a href="#1-1数组线性表-线性结构" class="headerlink" title="1.1数组线性表[线性结构]"></a>1.1数组线性表[线性结构]</h1><ul><li>利用数组的连续存储空间顺序存放线性表的各元素</li></ul><hr><p><br><br><br></p><h2 id="主要操作的实现"><a href="#主要操作的实现" class="headerlink" title="主要操作的实现:"></a>主要操作的实现:</h2><pre><code>// 1.1数组线性表[线性结构]#define MAXSIZE 100  // MAXSIZE 定义为 Data 数组的大小typedef int ElementType;  // ElementType 可定义为任意类型typedef struct LNode *List; struct LNode&#123;ElementType Data[MAXSIZE]; int Last;  // Last 定义线性表的最后一个元素&#125;;List MakeEmpty(); //初始化顺序表 int Find(ElementType X,List L); //查找 X 第一次出现的下标 void Insert(ElementType X,int i,List L); //在下标为 i 的地方插入 X void Delete(int i,List L);   //删除下标为 i 的当前值 ElementType FindKth(int K,List L);  //返回下标为 K 的当前值int Length(List L);  //返回顺序表的长度 // 初始化List MakeEmpty()&#123;    List L;    L = (List)malloc(sizeof(struct LNode));    L-&gt;Last = -1;    return L;&#125;// 按值差找int Find(ElementType X, List L)&#123;    int cnt=0;    while(cnt &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[cnt] != X)  cnt++;    if(cnt &gt; L-&gt;Last)  return -1;    else return cnt;    return 0;&#125;// 插入void Insert(ElementType X, int i, List L)&#123;    int j;    if(L-&gt;Last == MAXSIZE-1)      &#123;        cout &lt;&lt; &quot;表已满&quot; &lt;&lt; endl;        return;    &#125;    else if(i&lt;0)    &#123;        cout &lt;&lt; &quot;位置不合法&quot; &lt;&lt; endl;        return;    &#125;    for(int j=L-&gt;Last; j&gt;=i; j--)  L-&gt;Data[j+1] = L-&gt;Data[j];    L-&gt;Data[i] = X;    L-&gt;Last++;    return;&#125;// 删除void Delete(int i, List L)&#123;    int j;    if(i&lt;0 || i&gt;L-&gt;Last)    &#123;        cout &lt;&lt; &quot;位置不合法&quot; &lt;&lt; endl;        return;    &#125;    for(int j=i; j&lt;L-&gt;Last; j++)  L-&gt;Data[j] = L-&gt;Data[j+1];    L-&gt;Data[L-&gt;Last] = NULL;    L-&gt;Last--;    return;&#125;// 按序差找ElementType FindKth(int K,List L)&#123;    if(K&lt;0 || K&gt;L-&gt;Last)    &#123;        cout &lt;&lt; &quot;位置不合法&quot; &lt;&lt; endl;        return NULL;    &#125;    return L-&gt;Data[K];&#125;// 表长int Length(List L)&#123;    return L-&gt;Last+1;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;浙大&gt;数据结构·1.0线性表[线性结构]</title>
      <link href="/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-0%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>/2022/05/04/%E6%B5%99%E5%A4%A7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B71-0%E7%BA%BF%E6%80%A7%E8%A1%A8-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表?"></a>什么是线性表?</h1><ul><li>多项式表示问题的启示：<ol><li>同一个问题可以有不同的表示（存储）方法</li><li>有一类共性问题：有序线性序列的组织和管理</li></ol></li></ul><p>“线性表(Linear List)”：由同类型数据元素构成有序序列的线性结构</p><ol><li>表中元素个数称为线性表的长度</li><li>线性表没有元素时，称为空表</li><li>表起始位置称表头，表结束位置称表尾</li></ol><hr><h2 id="线性表的抽象数据类型描述"><a href="#线性表的抽象数据类型描述" class="headerlink" title="线性表的抽象数据类型描述"></a>线性表的抽象数据类型描述</h2><h4 id="类型名称：线性表（List）"><a href="#类型名称：线性表（List）" class="headerlink" title="类型名称：线性表（List）"></a>类型名称：线性表（List）</h4><h4 id="数据对象集：线性表是-n-≥0-个元素构成的有序序列-a1-a2-…-an"><a href="#数据对象集：线性表是-n-≥0-个元素构成的有序序列-a1-a2-…-an" class="headerlink" title="数据对象集：线性表是 n (≥0)个元素构成的有序序列( a1, a2, … ,an )"></a>数据对象集：线性表是 n (≥0)个元素构成的有序序列( a1, a2, … ,an )</h4><h4 id="操作集：线性表L-属于-List，整数i表示位置，元素X-属于-ElementType，"><a href="#操作集：线性表L-属于-List，整数i表示位置，元素X-属于-ElementType，" class="headerlink" title="操作集：线性表L 属于 List，整数i表示位置，元素X 属于 ElementType，"></a>操作集：线性表L 属于 List，整数i表示位置，元素X 属于 ElementType，</h4><p>线性表基本操作主要有：</p><ol><li>List MakeEmpty()：初始化一个空线性表L； </li><li>ElementType FindKth( int K, List L )：根据位序K，返回相应元素 ； </li><li>int Find( ElementType X, List L )：在线性表L中查找X的第一次出现位置；</li><li>void Insert( ElementType X, int i, List L)：在位序i前插入一个新元素X；</li><li>void Delete( int i, List L )：删除指定位序i的元素；</li><li>int Length( List L )：返回线性表L的长度n。</li></ol><hr><h2 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h2><ol><li>利用数组的连续存储空间顺序存放线性表的各元素</li><li>线性表的链式存储实现</li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;数据库系统概论·第一章</title>
      <link href="/2022/04/27/%E9%A2%84-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2022/04/27/%E9%A2%84-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章·绪论"><a href="#第一章·绪论" class="headerlink" title="第一章·绪论"></a>第一章·绪论</h1><hr><h2 id="1-四个基本概念"><a href="#1-四个基本概念" class="headerlink" title="1. 四个基本概念"></a>1. 四个基本概念</h2><ol><li>数据：描述数据的符号记录</li><li>数据库：数据库数据具有 永久存储、有组织、可共享 这三个基本特征</li><li>数据库管理系统：位于 应用和操作系统之间的一层数据管理软件。和操作系统一样是计算机的基础软件</li><li>数据库系统：由 数据库、数据库管理系统、应用程序、数据库管理员 组成的 存储、管理、处理、维护数据的系统</li></ol><hr><h2 id="2-数据库的发展阶段"><a href="#2-数据库的发展阶段" class="headerlink" title="2. 数据库的发展阶段"></a>2. 数据库的发展阶段</h2><ol><li>人工管理阶段：数据不保存、不共享、不具有独立性</li><li>文件系统阶段：可保存，但共享性差，冗余性大，独立性差</li><li>数据库管理系统：数据库的出现使信息系统从以 加工数据的程序为中心 转向 共享的数据库 为中心的新阶段</li></ol><hr><h2 id="2-数据库的发展阶段-1"><a href="#2-数据库的发展阶段-1" class="headerlink" title="2. 数据库的发展阶段"></a>2. 数据库的发展阶段</h2>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;操作系统·第一章</title>
      <link href="/2022/04/27/%E9%A2%84-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2022/04/27/%E9%A2%84-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章·引论"><a href="#第一章·引论" class="headerlink" title="第一章·引论"></a>第一章·引论</h1><hr><h2 id="1-操作系统介绍"><a href="#1-操作系统介绍" class="headerlink" title="1. 操作系统介绍"></a>1. 操作系统介绍</h2><ol><li>定义：一种软件，用来控制和管理计算机软件和硬件资源来方便用户使用。</li><li>地位：为其他软件提供一个运行环境</li><li>基本特征<ol><li>并发：是指多个活动在给定的同一时间 间隔 内进行。</li><li>共享：指计算机系统中的资源被多个进程共用</li><li>异步：进程以不可预知的速度向前推进</li><li>虚拟：把物理上的实体变为若干个逻辑上的对应物</li></ol></li><li>主要功能<ol><li>处理器管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ol></li><li>发展历程：<ol><li>人工操作阶段（无操作系统）</li><li>批处理阶段（操作系统开始出现）</li><li>分时操作系统（不可以排队，有了人机交互）</li><li>实时操作系统（可以插队）</li></ol></li></ol><hr><h2 id="2-不得不知的概念"><a href="#2-不得不知的概念" class="headerlink" title="2. 不得不知的概念"></a>2. 不得不知的概念</h2><ol><li>两种指令：<ol><li>特权指令：用户不可使用的指令</li><li>非特权指令：普通运算指令</li></ol></li><li>两种程序：<ol><li>内核程序：系统管理者，可以执行一切指令</li><li>应用程序：普通用户程序只可执行非特权指令，运行在用户态</li></ol></li><li>处理机状态：<ol><li>用户态：CPU只能执行非特权指令</li><li>核心态（管态、内核态）：可以执行所有指令</li><li>用户态到核心态：通过中断（是硬件完成）</li><li>核心态到用户态</li></ol></li><li>原语：<ol><li>处于操作系统的最底层，是最接近硬件的部分</li><li>这些程序的运行具有原子性，其操作只能一气呵成</li><li>这些程序的运行时间都较短，而且调用频繁</li></ol></li><li>中断：<ol><li>内中断</li><li>外中断</li></ol></li><li>系统调用：系统给程序员（应用程序）提供的唯一接口，可以获得OS的服务，在用户态发生，核心态处理</li><li>体系结构：<ol><li>大内核</li><li>微内核</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;计算机组成原理·第一章</title>
      <link href="/2022/04/27/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2022/04/27/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章·概述"><a href="#第一章·概述" class="headerlink" title="第一章·概述"></a>第一章·概述</h1><hr><h2 id="1-什么是计算机的组成"><a href="#1-什么是计算机的组成" class="headerlink" title="1. 什么是计算机的组成"></a>1. 什么是计算机的组成</h2><p><img src="/2022/04/27/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/p1.png"></p><ol><li>两种信息流：控制信息流 和 数据信息流</li><li>控制信息流包括：指令信息、状态信息、时序信息</li></ol><hr><h2 id="2-冯诺依曼体系结构计算机的特点"><a href="#2-冯诺依曼体系结构计算机的特点" class="headerlink" title="2. 冯诺依曼体系结构计算机的特点"></a>2. 冯诺依曼体系结构计算机的特点</h2><ol><li>硬件由五大功能部件组成：运算器、控制器、储存器、输入设备、输出设备</li><li>软件以 二进制 表示</li><li>采用存储程序<ol><li>所有程序预先存放在存储器中</li><li>指令采用串行执行方式（即一条接着一条执行指令）</li></ol></li></ol><hr><h2 id="3-计算机系统的层次结构"><a href="#3-计算机系统的层次结构" class="headerlink" title="3. 计算机系统的层次结构"></a>3. 计算机系统的层次结构</h2><p><img src="/2022/04/27/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/p2.png"></p><hr><h2 id="4-机器语言、汇编语言、高级语言"><a href="#4-机器语言、汇编语言、高级语言" class="headerlink" title="4. 机器语言、汇编语言、高级语言"></a>4. 机器语言、汇编语言、高级语言</h2><ol><li>机器语言：机器可以直接执行的语言；二进制代码</li><li>汇编语言：用助记符表示的与机器一一语言对应的语言，程序要经过汇编后才能执行</li><li>高级语言：程序要经过解释和编译才能执行</li></ol><hr><h2 id="5-编译程序、解释程序、汇编程序"><a href="#5-编译程序、解释程序、汇编程序" class="headerlink" title="5. 编译程序、解释程序、汇编程序"></a>5. 编译程序、解释程序、汇编程序</h2><ol><li>编译程序：把高级语言输入进行翻译转换，产生出机器语言的 目标程序，然后让计算机去执行目标程序，得到结果（C、C++）</li><li>解释语言：一句一句翻译，边翻译边执行，不形成 目标程序（Python、JavaScript）</li><li>汇编程序：指汇编语言编写的程序；与上面两者完全不是一个概念。</li></ol><hr><h2 id="6-CPI：一条指令所需的时钟周期数"><a href="#6-CPI：一条指令所需的时钟周期数" class="headerlink" title="6. CPI：一条指令所需的时钟周期数"></a>6. CPI：一条指令所需的时钟周期数</h2><p><img src="/2022/04/27/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/p3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;计算机网络·第七章</title>
      <link href="/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
      <url>/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章·网络安全"><a href="#第七章·网络安全" class="headerlink" title="第七章·网络安全"></a>第七章·网络安全</h1><h2 id="1-网络安全概论"><a href="#1-网络安全概论" class="headerlink" title="1. 网络安全概论"></a>1. 网络安全概论</h2><ol><li>网络安全：是指网络中的硬件，软件，数据受到保护</li><li>计算机网络面临的威胁主要分为两大类：<ol><li>主动攻击：<ol><li>主动的恶意行为</li><li>篡改</li><li>恶意程序</li><li>拒绝服务</li></ol></li><li>被动攻击：<ol><li>主要是收集数据而不是进行访问来改变数据</li><li>截获</li><li>窃取</li><li>流量分析</li></ol></li></ol></li><li>网络系统的特性：<ol><li>保密性</li><li>完整性</li><li>可用性</li><li>可靠性</li><li>不可抵赖性</li></ol></li></ol><hr><h2 id="2-加密和交互"><a href="#2-加密和交互" class="headerlink" title="2. 加密和交互"></a>2. 加密和交互</h2><ol><li>加密和解密：<ol><li>加密：通过特殊的算法来改变某种数据，让获得该数据的用户无法得知其信息内容<ul><li>加密手段：<ol><li>MD5加密</li><li>AES加密</li><li>SHA1加密</li><li>RSA加密</li></ol></li></ul></li><li>解密：加密的逆过程</li></ol></li><li>公钥和私钥：<ol><li>对称加密：单钥加密</li><li>非对称加密：通过公钥和私钥进行加密<ul><li>特点：<ol><li>防止重放攻击</li><li>防止数据伪造</li><li>防止数据被篡改</li><li>防止数据抵赖</li></ol></li></ul></li></ol></li><li>防火墙：一种控制访问技术，严格控制进出网络边界的分组，禁止不必要的通信从而减少入侵的潜在可能<ol><li>区域：<ol><li>Local 本地区域</li><li>Trust 受信区</li><li>DMZ 非军事化区</li><li>Untrust 非受信区</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;计算机网络·第六章</title>
      <link href="/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章·应用层"><a href="#第六章·应用层" class="headerlink" title="第六章·应用层"></a>第六章·应用层</h1><h2 id="1-应用层的作用"><a href="#1-应用层的作用" class="headerlink" title="1. 应用层的作用"></a>1. 应用层的作用</h2><ol><li>作用：是最贴近于用户的一层；为用户提供服务。</li></ol><hr><h2 id="2-应用层中常见的协议"><a href="#2-应用层中常见的协议" class="headerlink" title="2. 应用层中常见的协议"></a>2. 应用层中常见的协议</h2><ol><li>域名系统DNS：<ol><li>结构：三级域名.二级域名.顶级域名（mail.cctv.com）</li><li>域名服务器：迭代、递归</li><li>端口号：53</li></ol></li><li>文件传输协议FTP：<ol><li>使用TCP连接，传输数据</li><li>端口号：21（20）</li></ol></li><li>远程终端协议TELNET：<ol><li>使用TCP链接，远程登录到远地的另一台主机上</li><li>端口号：23</li></ol></li><li>万维网和HTTP协议：<ol><li>超文本传输协议HTTP，是一个简单的请求-相应协议</li><li>端口号：80</li></ol></li><li>电子邮件协议：<ol><li>SMTP电子邮件传输协议<ul><li>端口号：25</li></ul></li><li>POP3邮件协议版本3<ul><li>端口号：110</li></ul></li></ol></li><li>DHCP动态主机配置协议：实现一个地址池内的IP自动分配和子网掩码 <ul><li>端口号：68</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;计算机网络·第五章</title>
      <link href="/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章·传输层"><a href="#第五章·传输层" class="headerlink" title="第五章·传输层"></a>第五章·传输层</h1><hr><h2 id="1-传输层的基本概念"><a href="#1-传输层的基本概念" class="headerlink" title="1. 传输层的基本概念"></a>1. 传输层的基本概念</h2><ol><li>传输层：<ol><li>提供端到端的服务</li><li>向上层的应用层提供通信服务</li><li>客户端通过IP地址找到服务端，然后其中每一个应用程序提供一个端口号来进行区分</li></ol></li><li>端口号：<ol><li>FTP：21（20）：FTP（文件传输协议）<ul><li>21连接，20传输数据</li></ul></li><li>TELNET：23：TELNET（远程登陆）</li><li>SMTP：25：SMTP（电子邮件传输协议）<ul><li>POP3（邮件协议版本3）：110</li></ul></li><li>DNS：53：DNS（域名系统）</li><li>TFTP：69：TFTP（简单文件传输协议）</li><li>HTTP:80：HTTP（超文本传输协议）</li><li>SNMP：161：SNMP（简单网络管理协议）</li><li>HTTPS：443：HTTPS（超文本传输安全协议）</li></ol></li></ol><hr><h2 id="1-传输层的两个重要协议"><a href="#1-传输层的两个重要协议" class="headerlink" title="1. 传输层的两个重要协议"></a>1. 传输层的两个重要协议</h2><ol><li>TCP：传输控制协议（TCP）<ol><li>特点：<ol><li>面向连接</li><li>可靠服务</li><li>全双工通信</li><li>面向字节流</li></ol></li><li>窗口：<ol><li>固定窗口</li><li>滑动窗口</li><li>拥塞处理和流量控制</li></ol></li><li>TCP的三次握手和四次挥手</li></ol></li><li>UDP：用户数据报协议<ol><li>特点：<ol><li>无连接</li><li>不可靠的</li><li>面向报文没有拥塞控制</li><li>开销小传输效率高</li></ol></li><li>UDP首部的概念</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;计算机网络·第四章</title>
      <link href="/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章·网络层"><a href="#第四章·网络层" class="headerlink" title="第四章·网络层"></a>第四章·网络层</h1><h2 id="1-网络层的作用"><a href="#1-网络层的作用" class="headerlink" title="1. 网络层的作用"></a>1. 网络层的作用</h2><ol><li>作用：提供点到点的服务</li><li>单位：分组</li></ol><hr><h2 id="2-网际层的协议IP"><a href="#2-网际层的协议IP" class="headerlink" title="2. 网际层的协议IP"></a>2. 网际层的协议IP</h2><ol><li>ARP地址解析协议：根据IP地址获取物理地址</li><li>ICMP国际控制报文协议</li><li>IGMP国际组管理协议</li></ol><hr><h2 id="3-IP地址"><a href="#3-IP地址" class="headerlink" title="3. IP地址"></a>3. IP地址</h2><ol><li>IP地址的概念：IP协议提供给互联网上每一个网络和每一台主机分配一个逻辑地址，来屏蔽物理地址的差异。</li><li>IP地址的组成：网络号+主机号<ul><li>子网掩码: 由1和0组成 1代表主机号</li></ul></li><li>IP地址的分类：A,B,C,D （网络号占用1字节~4字节）</li><li>IPv6：由16进制组成，用来满足IPv4出现匮乏的问题</li></ol><hr><h2 id="4-子网划分"><a href="#4-子网划分" class="headerlink" title="4. 子网划分"></a>4. 子网划分</h2><hr><h2 id="5-网络层的路由"><a href="#5-网络层的路由" class="headerlink" title="5. 网络层的路由"></a>5. 网络层的路由</h2><ol><li><p>路由</p><ol><li>路由是什么？：从源地址到目的地址所经过的路径</li><li>路由器：网络层基本设备，数据转发，存放着通往各个网段的路由表</li><li>路由表：通往其他网段的路径</li><li>网关：所有的网段内部与不同网段进行通信都需要经过网关</li><li>路由获取方式：<ol><li>直连</li><li>静态</li><li>动态</li></ol></li></ol></li><li><p>路由的配置方式</p><ol><li>静态路由：<ul><li>静态路由：由管理员手工配置，适合结构稳定的小型网络</li><li>缺省路由：是一种特殊的路由，当报文没有在路由表中找到匹配的具体表项时才能使用的路由</li></ul></li><li>动态路由：通过协议来实现不同网段的路由互通</li><li>动态路由协议：<ol><li>RIP：基于矢量, 适用于中小型网络拓扑。。</li><li>OSPF：基于链路，适用于较大规模的网络。。</li><li>BGP：自治系统间的路由协议</li><li>IS-IS：内部网关协议</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;计算机网络·第三章</title>
      <link href="/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2022/04/26/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章·数据链路层"><a href="#第三章·数据链路层" class="headerlink" title="第三章·数据链路层"></a>第三章·数据链路层</h1><hr><h2 id="1-数据链路层的基本概念"><a href="#1-数据链路层的基本概念" class="headerlink" title="1. 数据链路层的基本概念"></a>1. 数据链路层的基本概念</h2><ol><li>数据链路层概念：为相邻节点提供可靠数据传输</li><li>帧的概率：<ol><li>数据链路层的单位</li><li>组成<ul><li>帧头：源MAC地址、目的MAC地址、类型</li><li>数据</li><li>帧尾：校验</li></ul></li></ol></li><li>以太网数据帧中的MAC和LLC：<ol><li>MAC：对接网络层</li><li>LLC：对接物理层 </li></ol></li><li>数据链路层的传输方式：<ul><li>单播</li><li>广播</li></ul></li><li>数据链路层的三个基本问题：<ol><li>封装成帧</li><li>透明传输</li><li>差错检测</li></ol></li><li>以太网中的设备：<ol><li>集线器</li><li>交换机</li><li>网桥</li></ol></li></ol><hr><h2 id="2-数据链路层的通信协议"><a href="#2-数据链路层的通信协议" class="headerlink" title="2. 数据链路层的通信协议"></a>2. 数据链路层的通信协议</h2><ol><li>冲突域和广播域：<ol><li>冲突域：交换机的每一个端口都是冲突域；冲突域只能发生在一个网段（第一层：物理层）</li><li>广播域：交换机的所有端口都在一个广播域；广播域在一个或多个网段发生（第二层：数据链路层）</li></ol></li><li>虚拟局域网 VLAN：将物理的 局域网LAN 划分为多个虚拟的局域网<ol><li>优点：<ol><li>划分广播域：减少垃圾数据</li><li>增加局域网安全性</li><li>增加局域网健壮性</li><li>灵活构建工作组</li></ol></li><li>划分方式：<ol><li>基于端口：<ul><li>Access：只许1个VLAN通过</li><li>trunk：只许多个VLAN通过</li></ul></li><li>基于子网</li><li>基于MAC地址</li><li>基于协议</li><li>基于匹配策略</li></ol></li></ol></li><li>CSMA/CD：针对广播型信道中的一个放冲突技术<ul><li>四大要点：<ol><li>先听再发</li><li>边听边发</li><li>冲突停止</li><li>延迟后发</li></ol></li></ul></li><li>PPP：封装数据帧</li><li>CRC：循环冗余校验</li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;计算机网络·第二章</title>
      <link href="/2022/04/24/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2022/04/24/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章·物理层"><a href="#第二章·物理层" class="headerlink" title="第二章·物理层"></a>第二章·物理层</h1><hr><h2 id="1-物理层的基本概念"><a href="#1-物理层的基本概念" class="headerlink" title="1. 物理层的基本概念"></a>1. 物理层的基本概念</h2><ol><li><p>四大特性：</p><ol><li>机械特性：接口是怎么样的</li><li>电气特性：用多少伏的电</li><li>功能特性：线路上电平电压的特性（使用什么介质的 传输光信号/ 电信号）</li><li>过程特性：实现不同功能所发射信号的顺序</li></ol></li><li><p>两种信号：</p><ol><li>模拟信号：不离散，连续的；特定频率的信号，有更加丰富的表现形式</li><li>数字信号：离散，不连续的；只有0和1，有更加强的抗干扰能力</li></ol></li><li><p>调制和编码：</p><ol><li>调制：模拟信号转换（ 模拟信号/数字信号 —&gt; 模拟信号 ）</li><li>编码：数字信号转换（ 模拟信号/数字信号 —&gt; 数字信号 ）<ul><li>步骤：<ol><li>采样</li><li>量化</li><li>编码</li></ol></li></ul></li><li>区别：<ul><li>数据可以通过编码手段转换成数字信号，也可以通过调制手段将数据转为模拟信号</li><li>数字数据可以通过数字发生器转化成数字信号，也可以通过调制器转化成模拟信号</li><li>模拟数据可以通过PCM编码器转化成数字信号，可以通过放大器调制器转成模拟信号<br><img src="/2022/04/24/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E8%B0%83%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81.png"></li></ul></li></ol></li><li><p>传输介质：</p><ol><li><p>双绞线：</p><ol><li>屏蔽双绞线 STP：抗干扰性强，贵一些</li><li>非屏蔽双绞线 UTP：抗干扰差，便宜一些</li><li>制作标准：<ol><li>568B：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕 （ 8根线; 计算机通信实际只是用 1-橙白、2-橙、3-绿白、6-绿  这4根线路）</li><li>568A：13、26调换 （ 绿白、绿、橙白、蓝、蓝白、橙、棕白、棕 ）</li></ol></li></ol></li><li><p>光纤：</p><ol><li>单模光纤：单调专一（直射），传输距离远（ 100 KM ）</li><li>多模光纤：多种繁杂（折射 – 数据会损耗），传输距离近（ 2 KM ）<br><img src="/2022/04/24/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%85%89%E7%BA%A4.png"></li></ol></li><li><p>同轴电缆（已淘汰）</p></li><li><p>无线：无线信号频率 IEEE802.11</p></li></ol></li><li><p>三大部分</p><ol><li>源系统：发送数据的一端（电脑）</li><li>传输系统：传输过程中的各种传输介质</li><li>目标系统：接收数据的电脑</li></ol></li></ol><hr><h2 id="2-物理层的基本通信技术"><a href="#2-物理层的基本通信技术" class="headerlink" title="2. 物理层的基本通信技术"></a>2. 物理层的基本通信技术</h2><ol><li>四种信道复用技术：<ol><li>复用技术：将多种不同的信号在 同一信道上进行传输，复用技术主要是用于解决不同信号传输时如何区分</li><li>频分复用 FDM：划分不同频率来并行传输信号</li><li>时分复用 TDM：划分不同时间段进行传输信号</li><li>波分复用 WDM：根据光波的波长进行传输（合波器耦合; 仅光纤）</li><li>码分复用 CDM：在同一时间同一频率根据传输的数据码进行区分<br><img src="/2022/04/24/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%A4%8D%E7%94%A8%E4%BF%A1%E9%81%93.png"></li></ol></li><li>数据传输方式：<ol><li>通过同一时间传输数量分为：<ul><li>串行传输：通过一条数据线，将数据信号一位一位依次传输</li><li>并行传输：将数据分组，在多条并行信道上同时传输</li></ul></li><li>通过数据报文的双方行为分为：<ul><li>同步传输：两端耦合性，双方同时在线</li><li>异步传输：序列处理，双方必须要同时在线</li></ul></li><li>通过传输信号分为：<ul><li>基带传输：传输数字信号</li><li>频带传输：传输模拟信号（300-3400 HZ）</li></ul></li><li>传输方向：单工，半双工，全双工</li><li>传播对象：单播，组播，广播</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;预&gt;计算机网络·第一章</title>
      <link href="/2022/04/24/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2022/04/24/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章·概述"><a href="#第一章·概述" class="headerlink" title="第一章·概述"></a>第一章·概述</h1><hr><h2 id="1-计算机网络的概念"><a href="#1-计算机网络的概念" class="headerlink" title="1. 计算机网络的概念"></a>1. 计算机网络的概念</h2><ol><li><p>计算机网络的定义：计算机网络是指 独立功能的计算机 用通信功能连接起来 实现资源共享</p></li><li><p>计算机网络的组成：</p><ol><li>终端系统/资源子网：提供共享的软件资源和硬件资源</li><li>通信子网：提供信息交换的网络节点和通信线路</li></ol></li><li><p>计算机网络的类型：</p><ol><li>按照拓扑结构：<ul><li>星型结构</li><li>树型结构</li><li>总线型结构</li><li>环型结构</li><li>网状结构</li></ul></li><li>按照范围分类： <ul><li>局域网 LAN</li><li>城域网 MAN</li><li>广域网 WAN</li><li>补充：<ul><li>个人区域网 PAN</li><li>互联网 Internet（属于广域网）</li></ul></li></ul></li><li>按照传输方式分类：<ul><li>有线<ul><li>IEEE802.3</li></ul></li><li>无线<ul><li>IEEE802.11</li><li>WLAN 无线局域网（wireless）</li><li>WPAN 无线个域网</li></ul></li></ul></li></ol></li></ol><hr><h2 id="2-计算机网络体系结构"><a href="#2-计算机网络体系结构" class="headerlink" title="2. 计算机网络体系结构"></a>2. 计算机网络体系结构</h2><ol><li><p>传输方式：</p><ol><li>按照方向：<ul><li>单工：只能单方向传输的工作模式</li><li>半双工：在同一时间内，线路上只能有一个通过（A→B或B→A）</li><li>全双工：双方可以同时进行数据传输（A→B和B→A）</li></ul></li><li>按照对象和方式：<ul><li>单播：1 对 一</li><li>组播：1 对 多</li><li>广播：1 对 全</li></ul></li></ol></li><li><p>数据交换:</p><ol><li>电路交换：占用信息通道 将整个报文从头至尾的连续传输</li><li>报文交换：一个报文 转发给下一个节点 然后下一个节点下载后 再转发给下一个节点</li><li>分组交换：将报文分成多个更小的组合 分开转发到 一个个节点 在转发到 目标 （提高信道的使用效率）</li></ol></li><li><p>通信协议和体系结构:</p><ol><li>网络协议三要素：<ul><li>语法</li><li>语义</li><li>时序</li></ul></li><li>OSI参考模型（7层 高 –&gt; 低 ; 下层为上层服务; 淘汰了）：<ol><li>应用层：使用 应用程序 通过网络服务</li><li>表示层：负责 处理交换数据的表示方式，例如格式转换（jpg/mp4..），加密或解密，数据压缩和恢复等等</li><li>会话层：负责 通信节点之间会话的 建立和中断，以及数据的交换。</li><li>传输层：提供 端到端（两台电脑） 之间的数据传输服务，实现流量控制。</li><li>网络层：单位 分组，提供 点到点（节点到节点） 之间的通信，提供路由功能（即选择走哪条路），实现拥塞控制，网络互联。</li><li>数据链路层：单位 帧，提供 相邻结点到结点 之间的服务; 提供差错控制和流量控制的方法，实现网络互联。</li><li>物理层：单位 bit, 最基本的电流，电线等一些介质线路。<br><img src="/2022/04/24/%E9%A2%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%AC%AC%E4%B8%80%E7%AB%A0/OSI%E5%8F%82%E8%80%83.png"></li></ol></li><li>TCP/IP参考模型（4层 高 –&gt; 低; 当前常用的）：<ol><li>应用层：会话层 + 表示层 + 应用层</li><li>传输层：传输层</li><li>网际层：网络层</li><li>网络接口层：网络层 + 数据链路层</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端指令笔记(1)</title>
      <link href="/2022/04/17/Linux%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2022/04/17/Linux%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h4 id="·-前言"><a href="#·-前言" class="headerlink" title="· 前言"></a>· 前言</h4><ul><li>使用 Linux - Ubuntu - 16.04 虚拟机 进行学习</li></ul><p><br><br><br></p><hr><h2 id="·-笔记"><a href="#·-笔记" class="headerlink" title="· 笔记"></a>· 笔记</h2><p>命令格式为：「xxx」 「-xxx」 「xxx」</p><ul><li><p>man xxx 可退出帮助：<br>  1）q键  退出<br>  2）/「xxx」  查找字符串</p></li><li><p> 「xxx」 –help  帮助</p></li></ul><ul><li> pwd  查看当前所在路径</li></ul><ul><li>tree  以树状列表显示文件夹内容：<br>  1）tree  当前目录<br>  2）tree「xxx」  指定目录</li></ul><ul><li>ls  以列表的方式显示文件夹内容：<br>  1）ls -a  显示所有文件（包含隐藏文件，即 Linux 中，以 “.” 开头的文件）<ol start="2"><li>ls -l  以详细信息的方式显示列表内容<br>3）ls -h  以更加人性化显示文件大小（即 K / MB / GB）</li></ol></li></ul><ul><li>cd「路径」  切换到指定路径：<br>  1）cd 「」  回到home目录<br>  2）cd 「~」  回到home目录<br>  3）cd 「.」  当前目录<br>  4）cd 「..」  上级目录<br>  5）cd 「-」  上次所在打目录（非上级目录）</li></ul><ul><li>mkdir 「路径」  创建目录：<br>  1）mkdir -p 「路径」  递归创建多个文件夹</li></ul><ul><li>touch 「路径」  创建一个文件：<br>  1）touch 「路径1」 「路径2」 「路径3」  创建多个文件</li></ul><ul><li>gedit 「路径」  打开一个文件进行编辑：<br>  1）gedit 「路径1」 「路径2」 「路径3」  打开多个文件</li></ul><ul><li>rm 「路径」  删除文件：<br>  1）rm -i  以交互模式删除（后悔药提示）<br>  2）rm -f  强制删除不提示<br>  3）rm -r 「文件夹名」 递归删除目录内容</li></ul><ul><li>cp 「原路径」 「目标路径」  拷贝文件或目录：<br>  1）cp -i  以交互模式拷贝(防止重复文件名出现)<br>  2）cp -f  强制覆盖不提示<br>  3）cp -r 「原路径」 「目标路径」  递归拷贝目录所有文件<br>  4）cp -v  显示拷贝的过程<br>  5）cp -a  拷贝原有属性</li></ul><ul><li>mv 「原路径」 「目标路径」  移动文件或目录 / 重命名：<br>  1）mv -i  以交互模式移动(防止重复文件名出现)<br>  2）mv -f  强制覆盖不提示<br>  3）mv -v  显示拷贝的过程<br>  注意：移动文件夹目录无需使用 -r 选项<br>  4）mv  「旧文件名」 「新文件名」  在一个目录移动才可重命名</li></ul><ul><li> clear  清屏 （ ctrl + l ）</li></ul><ul><li> which  查看某个指令所在的位置</li></ul><ul><li>Tab键  自动补全：<br>  1）没有歧义，自动补全<br>  2）有歧义（多个文件）按2次Tab键可以查看候选打文件名</li></ul><ul><li> ctrl + c  终止指令的执行 （ 配合tree指令可用于装X ）</li></ul><ul><li><p> ctrl + shift + =  终端字体放大</p></li><li><p> ctrl + -  终端字体缩小</p></li></ul><ul><li>cal  查看日历：<br>  1）-3  前，本，后 三个月的日历<br>  2）-y  显示一年的日历<br>  3）-j  以一年中第XXX天的格式来显示日历</li></ul><ul><li>date  查看日期时间：<br>  1）date  本身为查看当前的 年月日时分秒<br>  2）格式化字符串显示：<pre><code>  date &quot;+%Y&quot;  输出年份  %m  月份  %d  天数  %H  小时  %M  分钟  %S  秒  %F  等价于 %Y-%m-%d  %T  等价于 %H-%M-%S</code></pre></li></ul><ul><li>history  用来查看历史指令的信息：<br>  1）history 显示所有打历史指令<br>  2）history 「数量」  显示一定数量的历史指令<br>  3）！编号  执行某个历史指令<br>  注意：历史指令保存在 ～/.bash_history 文件中</li></ul><ul><li>cat  查看或连接文件：<br>  1）查看文件：<pre><code>  cat 「文件名」    -n  查看文件时，对每一行进行编号    -b  非空行进行编号    -s  连续2行以上的空行，只显示1行</code></pre>  2）连接文件，把两个文件合并到一起输出：<pre><code>  cat 「文件名1」 「文件名2」</code></pre></li></ul><ul><li>more  用来分屏（分页）查看文件内容<br>  1）more +「X」  从第X行开始查看<br>  2）more -p  先清屏，在查看文件<br>  3）more -s  连续2行以上的空行，只显示一行<br>  注意：与 cat指令 一样可以连接查看多个文件 但会用分割隔开<br>  快捷键：<pre><code>  回车  查看一行  空格  查看下一屏  ctrl+f/f  下一屏  ctrl+b/b  上一屏  q  退出</code></pre></li></ul><ul><li>数据流：<br>  1）输入流<br>  2）输出流<br>  3）标准错误输出流</li></ul><ul><li>重定向：改变数据的流向（一般重定向到文件中）<br>  1）&gt; 　重定向<br>  2）&gt;&gt;  以追加的方式重定向</li></ul><ul><li>管道：一个命令的输出作为另一个命令的输入去使用<br>  1）「指令1」 | 「指令2」 （ 指令1必须要有输出 ）</li></ul><ul><li>建立链接（Linux中链接文件有两种）：<br>  1）软链接：相当于快捷方式，通过软链接可以修改源文件的内容<pre><code>  ln -s 「源文件」 「链接文件名」</code></pre>  2）硬链接：一个文件有多个名字，通过硬链接可以修改源文件的内容<pre><code>  ln 「源文件」 「链接文件名」</code></pre>  注：<br>  共同处：<pre><code>  1）删除软硬链接对源文件都没有影响  2）通过软链接可以修改源文件的内容</code></pre>  异同处：<pre><code>  1）删除源文件，对软链接不可用；硬链接当文件超过1个时则无影响  2）软链接可以指向不存在的文件；硬链接不可以  3）软链接可以对目录创建；硬链接不可以</code></pre></li></ul><ul><li>grep  文本内部搜索:<ol><li>grep ‘内容’ 文件路径</li></ol>  -n  查看结果的行数<br>  -i  忽略大小写<br>  -v  取反<br>  2）grep ‘正则表达式跟上内容’ 文件路径 </li></ul><ul><li>find  在计算机内搜索文件<br>  1）find 目标目录 选项 条件<br>  2）按名称搜索:<pre><code>  find ./ -name test.txt   find ./ -name &#39;*.txt&#39;  搜索所有文本文件  注：正则表达式： ‘*’ 任意一个或多个字符               &#39;?&#39; 任意一个字符</code></pre>  3）按文件大小搜索：<pre><code>  find ./ -size +30M  大于30M  find ./ -size -30M  小于30M  find ./ -size +15M -size -30M  大于15M小于30M</code></pre></li></ul><ul><li>tar  归档 + 压缩 / 解压 + 解档<br>  1）tar -cvf 归档的文件名.tar 文件1 文件2 …  （ 归档 ）<br>  2）tar -xvf 档案文件名.tar  （ 解档 ）<pre><code> 注意：f 必须放到最后</code></pre>  3）tar -zcvf 归档的文件名.tar.gz 文件1 文件2 …  ( 归档+压缩 )<br>  4）tar -zxvf 档案文件名.tar.gz  ( 解压+接档 )<pre><code> 注意：tar -zxvf 档案文件名.tar.gz -C 要解压的目录  （ 指定解压目录位置 ）</code></pre></li></ul><ul><li>zip  压缩<br>  1）zip -r xxx.zip 目录  （ 压缩目录 ）</li><li>unzip  解压缩<br>  1）unzip xxx.zip  （ 解压缩 ）</li></ul><ul><li>文件权限的构成：<br>  1）9个格子 ， 3组 （ 拥有者 u , 组权限 g , 其他用户权限 o ， 所有用户权限 a ）<br>  2）每一组权限可选的权限有：<pre><code>  r 可读  w 可写  x 可执行 （ 文件：文件可以直接运行 ； 绿色 ；目录：表示这个目录可以打开 ）  - 没有权限</code></pre></li></ul><ul><li>chmod  权限修改：<br>  1）字母法：<pre><code>  用户： u g o a  权限设置： +（增加） ， - （撤销） ， = （设置）  具体权限： r w x  用法：chmod 用户+具体权限 文件名</code></pre>  2）数字法<pre><code>  r-4  w-2  x-1  -=0  三位权限数字：第一位，文件拥有者权限  第二位，同组用户权限  第三位，其他用户权限  chmod 权限数字 文件路径</code></pre></li></ul><ul><li>shutdown  关机：<br>  1）shutdown 15:50  指定在15:50关机<br>  2）shutdown +20  指定20分钟后关机<br>  3）shutdown -h now  指定立刻关机</li></ul><ul><li> reboot  重启</li></ul><ul><li>linux 软件安装三种方式：<br>  1）源代码包安装<br>  2）deb包安装<br>  3）apt-get方式</li></ul><ul><li>apt-get 方式安装软件<br>  1）配置软件源  修改/etc/apt/source.list<br>  2）更新软件源  sudo apt-get update<br>  3）安装软件  sudo apt-get install 软件包名字<br>  4）卸载软件  sudo apt-get remove 软件包名字</li></ul><ul><li>ssh  远程登录：<br>1）安装 ssh server服务器端：<br>sudo apt-get install openssh-sever<br>2）客户端登录：<br>ssh 服务器用户名@服务器地址（IP地址）<br>例：ssh <a href="mailto:&#112;&#121;&#116;&#x68;&#x6f;&#110;&#64;&#49;&#x39;&#x32;&#x2e;&#x31;&#x36;&#x38;&#46;&#49;&#49;&#x34;&#x2e;&#53;&#49;&#x34;">&#112;&#121;&#116;&#x68;&#x6f;&#110;&#64;&#49;&#x39;&#x32;&#x2e;&#x31;&#x36;&#x38;&#46;&#49;&#49;&#x34;&#x2e;&#53;&#49;&#x34;</a> –&gt; henghengenaaaaaa</li></ul><ul><li> scp  远程拷贝：<br>1）scp 作用：可以上传或下载文件<br>a.上传：scp 本地路径 服务器用户@服务器IP:服务器路径<br>例：scp ./89893240.jpg <a href="mailto:&#x70;&#121;&#x74;&#104;&#111;&#x6e;&#64;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#46;&#x32;&#x33;&#46;&#49;&#x33;&#x32;">&#x70;&#121;&#x74;&#104;&#111;&#x6e;&#64;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#46;&#x32;&#x33;&#46;&#49;&#x33;&#x32;</a>:<del>/python20/89893240.jpg<br>b.下载：scp 服务器用户@服务器IP:服务器路径 本地路径<br>例：scp <a href="mailto:&#112;&#121;&#116;&#x68;&#x6f;&#x6e;&#x40;&#x31;&#x39;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#x32;&#51;&#46;&#49;&#51;&#x32;">&#112;&#121;&#116;&#x68;&#x6f;&#x6e;&#x40;&#x31;&#x39;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#x32;&#51;&#46;&#49;&#51;&#x32;</a>:</del>/Desktop/Linux指令笔记 ./Linux指令笔记<br>2）如果对象为目录：scp -r</li></ul><ul><li> 编辑器vim介绍：<br>1）三种模式：命令模式（移动光标，复制，删除）  输入模式（编辑文件）  末行模式（保存文件，查找替换）<br>2）三种模式转换：打开文件默认是命令模式 ——a\i\o –&gt;输入模式–&gt;Ese—命令模式—：–&gt;末行模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论如何解决分心从而导致做事效率严重下降这件事</title>
      <link href="/2022/04/08/%E8%AE%BA%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%88%86%E5%BF%83%E4%BB%8E%E8%80%8C%E5%AF%BC%E8%87%B4%E5%81%9A%E4%BA%8B%E6%95%88%E7%8E%87%E4%B8%A5%E9%87%8D%E4%B8%8B%E9%99%8D%E8%BF%99%E4%BB%B6%E4%BA%8B/"/>
      <url>/2022/04/08/%E8%AE%BA%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%88%86%E5%BF%83%E4%BB%8E%E8%80%8C%E5%AF%BC%E8%87%B4%E5%81%9A%E4%BA%8B%E6%95%88%E7%8E%87%E4%B8%A5%E9%87%8D%E4%B8%8B%E9%99%8D%E8%BF%99%E4%BB%B6%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="·-前言"><a href="#·-前言" class="headerlink" title="· 前言"></a>· 前言</h4><p>&emsp;&emsp; 分心太可恨了！连看个10分钟网课都能每3分钟定时切出干别的。。直到过了十几分钟才能回过神继续干之前的活。而且分心状态会越来越严重，就像毒瘾一样，越来越难抗拒。那么应该如何有效快速的提升 “深度工作”的时间？</p><h2 id><a href="#" class="headerlink" title></a><br><br><br></h2><p><br><br><br></p><h2 id="·-解决方法"><a href="#·-解决方法" class="headerlink" title="· 解决方法"></a>· 解决方法</h2><ol><li>强攻战术：社交强制戒断，养成主动戒瘾习惯。</li><li>弹性防御：双峰哲学–将高效时间和低效时间来管理不同权重的任务。</li><li>阵地战: 通过改善学习环境来减少分心，通常将学习和娱乐的环境分离是一个高效的做法，同时减少学习环境的外部干扰，比如嘈杂的环境可以带个耳机用轻音乐覆盖过去。</li><li>决战计划：提前规划好日程表，利用奖励机制通过完成任务的成就感推动自己，可以配合番茄时钟。</li></ol><h2 id="-1"><a href="#-1" class="headerlink" title></a><br><br><br></h2><p><br><br><br></p><h4 id="·-结语"><a href="#·-结语" class="headerlink" title="· 结语"></a>· 结语</h4><p>&emsp;&emsp; 深度工作的最终状态，就是习惯; 就像分心上瘾一样，我们的大脑会自动将深度工作的模式刻入脑内。通常分心时间多半分布在中下午时刻，这种时候可以闭上眼睛小酣一会儿，泡杯咖啡让内心静下来。不写了，继续回去上网课了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-4-6备忘录</title>
      <link href="/2022/04/06/2022-4-6%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>/2022/04/06/2022-4-6%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="·-Content"><a href="#·-Content" class="headerlink" title="· Content:"></a>· Content:</h2><p>嗯。。。。单纯只是个备忘录</p><ol><li>更新 签到爬虫</li><li>誊写之前的项目到博客</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-4-6小破站更新日志</title>
      <link href="/2022/04/06/2022-4-6%E5%B0%8F%E7%A0%B4%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
      <url>/2022/04/06/2022-4-6%E5%B0%8F%E7%A0%B4%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>简要概括；<br>&emsp;&emsp;· 加了文章置顶功能</p>]]></content>
      
      
      <categories>
          
          <category> 更新日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 更新日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022/4/5小破站更新日志</title>
      <link href="/2022/04/05/2022-4-5%E5%B0%8F%E7%A0%B4%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
      <url>/2022/04/05/2022-4-5%E5%B0%8F%E7%A0%B4%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>简要概括；<br>&emsp;&emsp;· 将Github仓库同步到Vercel上<br>&emsp;&emsp;· 将部分在Github上通过jsdeliver进行CDN加速的图床转移到国内的图床网站上<br>&emsp;&emsp;· 更新了博文加密功能</p>]]></content>
      
      
      <categories>
          
          <category> 更新日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 更新日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轻小说追书目录（#TODO）</title>
      <link href="/2022/04/04/%E8%BD%BB%E5%B0%8F%E8%AF%B4%E8%BF%BD%E4%B9%A6%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/04/04/%E8%BD%BB%E5%B0%8F%E8%AF%B4%E8%BF%BD%E4%B9%A6%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>被困于上海疫情灾区的某宅充实的自宅警备计划之一<br><img src="/2022/04/04/%E8%BD%BB%E5%B0%8F%E8%AF%B4%E8%BF%BD%E4%B9%A6%E7%9B%AE%E5%BD%95/%E6%91%86%E7%83%82%E8%AF%81.jpg"></p><p><br><br><br></p><hr><h2 id="轻小说-追书目录"><a href="#轻小说-追书目录" class="headerlink" title="轻小说 - 追书目录 |"></a>轻小说 - 追书目录 |</h2><table><thead><tr><th align="center">序号</th><th align="center">书名</th><th align="center">读后感</th><th align="center">状态</th><th align="center">评分</th></tr></thead><tbody><tr><td align="center">1）</td><td align="center">无职转生</td><td align="center"></td><td align="center">()</td><td align="center"></td></tr><tr><td align="center">2）</td><td align="center">为美好世界送上祝福</td><td align="center"></td><td align="center">()</td><td align="center">9.0</td></tr><tr><td align="center">3）</td><td align="center">英雄王，为了穷尽武道而转生 ～而后成为世界最强见习骑士♀</td><td align="center"></td><td align="center">()</td><td align="center"></td></tr><tr><td align="center">4）</td><td align="center">英雄の娘として生まれ変わった英雄は再び英雄を目指す</td><td align="center"></td><td align="center">(✔)</td><td align="center">8.6</td></tr><tr><td align="center">5）</td><td align="center">继母的拖油瓶是我的前女友</td><td align="center"></td><td align="center">()</td><td align="center">9.2</td></tr><tr><td align="center">6）</td><td align="center">满怀美梦的少年是现实主义者</td><td align="center"></td><td align="center">()</td><td align="center">8.7</td></tr><tr><td align="center">7）</td><td align="center">想变成宅女，就让我当现充！</td><td align="center"></td><td align="center">()</td><td align="center">9.0</td></tr><tr><td align="center">8）</td><td align="center">现实主义勇者的王国再建记</td><td align="center"></td><td align="center">()</td><td align="center">7.5</td></tr><tr><td align="center">9）</td><td align="center">转生猪公爵，这次想说喜欢你</td><td align="center"></td><td align="center">(✔)</td><td align="center">8.5</td></tr><tr><td align="center">10）</td><td align="center">和班上最讨厌的女同学结婚</td><td align="center"></td><td align="center">()</td><td align="center">8.6</td></tr><tr><td align="center">11）</td><td align="center">关于我转生后成为史莱姆的那件事</td><td align="center"></td><td align="center">(✔)</td><td align="center">8.7</td></tr><tr><td align="center">12）</td><td align="center">欢迎来到实力至上教室</td><td align="center"></td><td align="center">()</td><td align="center">8.5</td></tr><tr><td align="center">13）</td><td align="center">八男？别闹了！</td><td align="center"></td><td align="center">()</td><td align="center">7.0</td></tr><tr><td align="center">14）</td><td align="center">Re:从零开始的异世界生活</td><td align="center"></td><td align="center">()</td><td align="center">9.5</td></tr><tr><td align="center">15）</td><td align="center">明天，我会死去，你将重生</td><td align="center"></td><td align="center">(✔)</td><td align="center">9.5</td></tr><tr><td align="center">16）</td><td align="center">关于邻家的天使大人不知不觉把我关成了废人这档子事</td><td align="center"></td><td align="center">()</td><td align="center">8.6</td></tr><tr><td align="center">17）</td><td align="center">爆肝工程师的异世界狂想曲</td><td align="center"></td><td align="center">()</td><td align="center">7.5</td></tr><tr><td align="center">18）</td><td align="center">精灵幻想记</td><td align="center"></td><td align="center">()</td><td align="center">7.5</td></tr><tr><td align="center">19）</td><td align="center">你与我最后的战场，亦或是世界起始的圣战</td><td align="center"></td><td align="center">()</td><td align="center"></td></tr><tr><td align="center">20）</td><td align="center">魔王学院的不适合者</td><td align="center"></td><td align="center">()</td><td align="center"></td></tr><tr><td align="center">21）</td><td align="center">口是心扉的冰室同学 从好感度100%开始的毒蛇女子追求法</td><td align="center"></td><td align="center">(✔)</td><td align="center">8.6</td></tr><tr><td align="center">22）</td><td align="center">我，当备胎女友就可以。</td><td align="center"></td><td align="center">(✔)</td><td align="center">8.8</td></tr><tr><td align="center">23）</td><td align="center">会非常可爱的我交往吧！</td><td align="center"></td><td align="center">(✔)</td><td align="center">8.5</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上海第二工业大学-自动签到爬虫V2.0</title>
      <link href="/2021/09/26/%E4%B8%8A%E6%B5%B7%E7%AC%AC%E4%BA%8C%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6-%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E7%88%AC%E8%99%ABV2-0/"/>
      <url>/2021/09/26/%E4%B8%8A%E6%B5%B7%E7%AC%AC%E4%BA%8C%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6-%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E7%88%AC%E8%99%ABV2-0/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>项目是基于 今天下午被班长打电话 被告知了《论早晨签到重要性与不签会被处分的可能性》后         仔细思索一番 。。。 然后发现比起依赖自己那和鲸鱼一样的记忆力。。不如还是直接依赖电脑算了。。。所以就写了这个爬虫。。。</p><p>自动签到爬虫程序步骤参考之前发布的文章<br>关于想了解如何做成软件等 请直接在博客首页 加我QQ/WECHAT 好友。。</p><hr><p><br><br><br></p><h4 id="V2-0-（-测试版-）"><a href="#V2-0-（-测试版-）" class="headerlink" title="V2.0 （ - 测试版 - ）"></a>V2.0 （ - 测试版 - ）</h4><ol><li>加入更多反爬技术</li><li>使用了tkinter/pygame/playsound等模块 将爬虫程序 制作成软件</li></ol><hr><p><br><br><br></p><h1 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a><font color="#FF0000">下载地址：</font></h1><ol><li><p>CSDN：<a href="https://download.csdn.net/download/Panzer_Jack/24895610">https://download.csdn.net/download/Panzer_Jack/24895610</a></p></li><li><p>GitHub：暂无</p></li><li><p>百度云：链接：<a href="https://pan.baidu.com/s/10PqlFDSdCjSg7fqTluwRFQ">https://pan.baidu.com/s/10PqlFDSdCjSg7fqTluwRFQ</a><br>提取码：0721</p></li><li><p>直接向我本人要</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上海第二工业大学-自动签到爬虫 V1.5</title>
      <link href="/2021/09/24/%E4%B8%8A%E6%B5%B7%E7%AC%AC%E4%BA%8C%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6-%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E7%88%AC%E8%99%ABV1-5/"/>
      <url>/2021/09/24/%E4%B8%8A%E6%B5%B7%E7%AC%AC%E4%BA%8C%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6-%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E7%88%AC%E8%99%ABV1-5/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>项目是基于 今天下午被班长打电话 被告知了《论早晨签到重要性与不签会被处分的可能性》后         仔细思索一番 。。。 然后发现比起依赖自己那和鲸鱼一样的记忆力。。不如还是直接依赖电脑算了。。。所以就写了这个爬虫。。。</p><p>自动签到爬虫步骤：<br>    · 准备相关模块<br>    · python脚本编写<br>    · Python程序 EXE执行文件 包装<br>    · Win10 系统下 按时间自动运行脚本代码</p><hr><p><br><br><br></p><h4 id="V1-5-更新"><a href="#V1-5-更新" class="headerlink" title="V1.5 更新"></a>V1.5 更新</h4><ol><li>加入反游览器自动脚本检测</li><li>加入伪装IP地址（代理IP）</li><li>后台运行</li></ol><hr><p><br><br><br></p><h1 id="准备："><a href="#准备：" class="headerlink" title="准备："></a><font color="#FF0000">准备：</font></h1><ol><li>Python</li><li>selenium模块</li><li>chromedriver（对应你自己的谷歌游览器的版本，可以使用镜像网站下载）</li></ol><hr><p><br><br><br></p><h1 id="脚本编写："><a href="#脚本编写：" class="headerlink" title="脚本编写："></a><font color="#FF0000">脚本编写：</font></h1><hr><h3 id="导入相关模块："><a href="#导入相关模块：" class="headerlink" title="导入相关模块："></a>导入相关模块：</h3><p>导入相关模块，建立模拟游览器，我用的是Chrome，也可以使用其他游览器：</p><pre><code>import timefrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsimport selenium.webdriver</code></pre><hr><h3 id="反爬技术："><a href="#反爬技术：" class="headerlink" title="反爬技术："></a>反爬技术：</h3><pre><code>&lt;!-- 反自动脚本检测 --&gt;opt = Options()opt.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])driver = selenium.webdriver.Chrome(options=opt)&lt;!-- IP伪装 --&gt;opt.add_argument(&quot;--proxy-server=http://代理IP地址:端口&quot;)</code></pre><hr><h3 id="后台自动运行："><a href="#后台自动运行：" class="headerlink" title="后台自动运行："></a>后台自动运行：</h3><pre><code>opt.add_argument(&#39;--headless&#39;)opt.add_argument(&#39;disbale-gpu&#39;)</code></pre><hr><h3 id="打开校园网："><a href="#打开校园网：" class="headerlink" title="打开校园网："></a>打开校园网：</h3><pre><code>url = &quot;https://hsm.sspu.edu.cn/&quot;driver.get(url)time.sleep(2)</code></pre><hr><h3 id="自动签到："><a href="#自动签到：" class="headerlink" title="自动签到："></a>自动签到：</h3><pre><code>driver.find_element_by_id(&quot;username&quot;).send_keys(&quot;你的账号&quot;)driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;你的密码&quot;)driver.find_element_by_class_name(&quot;submit_button&quot;).click()time.sleep(1)driver.find_element_by_class_name(&quot;icos&quot;).click()driver.find_element_by_id(&quot;fineui_2-inputEl-icon&quot;).click()driver.find_element_by_id(&quot;p1_TiWen-inputEl&quot;).send_keys(&quot;36&quot;)driver.find_element_by_class_name(&quot;f-field-checkbox-switch&quot;).click()time.sleep(2)driver.find_element_by_class_name(&quot;f-btn-text&quot;).click()</code></pre><hr><h3 id="自动退出游览器"><a href="#自动退出游览器" class="headerlink" title="自动退出游览器"></a>自动退出游览器</h3><pre><code>time.sleep(3)driver.quit()</code></pre><hr><p><br><br><br></p><h1 id="Python程序-EXE-包装："><a href="#Python程序-EXE-包装：" class="headerlink" title="Python程序 EXE 包装："></a><font color="#FF0000">Python程序 EXE 包装：</font></h1><hr><h3 id="pip3-安装-pyinstaller"><a href="#pip3-安装-pyinstaller" class="headerlink" title="pip3 安装 pyinstaller"></a>pip3 安装 pyinstaller</h3><pre><code>&lt;!-- 使用cmd命令台 --&gt;pip3 install pyinstaller</code></pre><hr><h3 id="pyinstaller-包装-python脚本"><a href="#pyinstaller-包装-python脚本" class="headerlink" title="pyinstaller 包装 python脚本"></a>pyinstaller 包装 python脚本</h3><pre><code>&lt;!-- 使用cmd命令切换到当前路径下 --&gt;&lt;!-- 然后执行指令(下面的xxxx写你自己程序的名字)： --&gt;pyinstaller  xxxx.py&lt;!-- 然后在该目录下./dist/xxxx/xxxx.exe出现exe文件 --&gt;</code></pre><hr><p><br><br><br></p><h1 id="Win10-系统下-按时间自动运行脚本代码："><a href="#Win10-系统下-按时间自动运行脚本代码：" class="headerlink" title="Win10 系统下 按时间自动运行脚本代码："></a><font color="#FF0000">Win10 系统下 按时间自动运行脚本代码：</font></h1><ol><li>打开 控制面板\系统和安全\管理工具\任务计划程序 </li><li>创建基本任务（在右边那栏里头）：名称描述你自己随便写</li><li>然后签到时间为 每天 （反正我们这边是每天都要签到的）</li><li>每日：开始时间 就是 开始时间</li><li>操作：启动程序</li><li>将程序与脚本 牵引至 之前你所包装的python exe执行文件上</li><li>点击完成</li><li>重复设立 多个执行任务 （防止某一次卡机 爬虫程序失败）</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上海第二工业大学-自动签到爬虫</title>
      <link href="/2021/09/22/%E4%B8%8A%E6%B5%B7%E7%AC%AC%E4%BA%8C%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6-%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E7%88%AC%E8%99%AB/"/>
      <url>/2021/09/22/%E4%B8%8A%E6%B5%B7%E7%AC%AC%E4%BA%8C%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6-%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>项目是基于 今天下午被班长打电话 被告知了《论早晨签到重要性与不签会被处分的可能性》后         仔细思索一番 。。。 然后发现比起依赖自己那和鲸鱼一样的记忆力。。不如还是直接依赖电脑算了。。。所以就写了这个爬虫。。。</p><p>自动签到爬虫步骤：<br>    · 准备相关模块<br>    · python脚本编写<br>    · Python程序 EXE执行文件 包装<br>    · Win10 系统下 按时间自动运行脚本代码</p><hr><p><br><br><br></p><h1 id="准备："><a href="#准备：" class="headerlink" title="准备："></a><font color="#FF0000">准备：</font></h1><ol><li>Python</li><li>selenium模块</li><li>chromedriver（对应你自己的谷歌游览器的版本，可以使用镜像网站下载）</li></ol><hr><p><br><br><br></p><h1 id="脚本编写："><a href="#脚本编写：" class="headerlink" title="脚本编写："></a><font color="#FF0000">脚本编写：</font></h1><hr><h3 id="导入相关模块："><a href="#导入相关模块：" class="headerlink" title="导入相关模块："></a>导入相关模块：</h3><p>导入相关模块，建立模拟游览器，我用的是Chrome，也可以使用其他游览器：</p><pre><code>import timeimport selenium.webdriverdriver = selenium.webdriver.Chrome()</code></pre><hr><h3 id="打开校园网："><a href="#打开校园网：" class="headerlink" title="打开校园网："></a>打开校园网：</h3><pre><code>url = &quot;https://hsm.sspu.edu.cn/&quot;driver.get(url)time.sleep(2)</code></pre><hr><h3 id="自动签到："><a href="#自动签到：" class="headerlink" title="自动签到："></a>自动签到：</h3><pre><code>driver.find_element_by_id(&quot;username&quot;).send_keys(&quot;你的账号&quot;)driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;你的密码&quot;)driver.find_element_by_class_name(&quot;submit_button&quot;).click()time.sleep(1)driver.find_element_by_class_name(&quot;icos&quot;).click()driver.find_element_by_id(&quot;fineui_2-inputEl-icon&quot;).click()driver.find_element_by_id(&quot;p1_TiWen-inputEl&quot;).send_keys(&quot;36&quot;)driver.find_element_by_class_name(&quot;f-field-checkbox-switch&quot;).click()time.sleep(2)driver.find_element_by_class_name(&quot;f-btn-text&quot;).click()</code></pre><hr><h3 id="自动退出游览器"><a href="#自动退出游览器" class="headerlink" title="自动退出游览器"></a>自动退出游览器</h3><pre><code>time.sleep(3)driver.quit()</code></pre><hr><p><br><br><br></p><h1 id="Python程序-EXE-包装："><a href="#Python程序-EXE-包装：" class="headerlink" title="Python程序 EXE 包装："></a><font color="#FF0000">Python程序 EXE 包装：</font></h1><hr><h3 id="pip3-安装-pyinstaller"><a href="#pip3-安装-pyinstaller" class="headerlink" title="pip3 安装 pyinstaller"></a>pip3 安装 pyinstaller</h3><pre><code>&lt;!-- 使用cmd命令台 --&gt;pip3 install pyinstaller</code></pre><hr><h3 id="pyinstaller-包装-python脚本"><a href="#pyinstaller-包装-python脚本" class="headerlink" title="pyinstaller 包装 python脚本"></a>pyinstaller 包装 python脚本</h3><pre><code>&lt;!-- 使用cmd命令切换到当前路径下 --&gt;&lt;!-- 然后执行指令(下面的xxxx写你自己程序的名字)： --&gt;pyinstaller  xxxx.py&lt;!-- 然后在该目录下./dist/xxxx/xxxx.exe出现exe文件 --&gt;</code></pre><hr><p><br><br><br></p><h1 id="Win10-系统下-按时间自动运行脚本代码："><a href="#Win10-系统下-按时间自动运行脚本代码：" class="headerlink" title="Win10 系统下 按时间自动运行脚本代码："></a><font color="#FF0000">Win10 系统下 按时间自动运行脚本代码：</font></h1><ol><li>打开 控制面板\系统和安全\管理工具\任务计划程序 </li><li>创建基本任务（在右边那栏里头）：名称描述你自己随便写</li><li>然后签到时间为 每天 （反正我们这边是每天都要签到的）</li><li>每日：开始时间 就是 开始时间</li><li>操作：启动程序</li><li>将程序与脚本 牵引至 之前你所包装的python exe执行文件上</li><li>点击完成</li><li>重复设立 多个执行任务 （防止某一次卡机 爬虫程序失败）</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 字体属性</title>
      <link href="/2021/09/14/CSS-%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7/"/>
      <url>/2021/09/14/CSS-%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>CSS-字体属性-学习笔记<br>字体属性：<br>    · 字体系列<br>    · 字体大小<br>    · 字体粗细<br>    · 文字样式（如斜体等）<br>    · 字体复合属性<br>    · 总结</p><hr><p><br><br><br></p><h1 id="·-字体系列"><a href="#·-字体系列" class="headerlink" title="· 字体系列"></a>· 字体系列</h1><p>CSS 使用 font-family 属性定义字体系列<br>用法：</p><pre><code>&lt;style&gt;    .font &#123;        font-family: &#39;Microsoft Yahei&#39;, &#39;Times New Roman&#39;, Times, serif;    &#125;&lt;/style&gt;</code></pre><br><strong><p>· 各种字体之间必须使用英文下的逗号隔开<tr><br>· 一般情况下，如果有空格隔开的多个单词的字体，加引号</tr><tr><br>· 尽量使用系统默认的自带字体，保证在任何用户的游览器中都能正确显示</tr><tr><br>· 最常见的几个字体：’Mircrosoft Yahei’, tahoma, arial, ‘Hiragino Sans GB’ </tr></p></strong><hr><p><br><br><br></p><h1 id="·-字体大小"><a href="#·-字体大小" class="headerlink" title="· 字体大小"></a>· 字体大小</h1><p>CSS 使用 font-family 属性定义文本的字体系列<br>用法：</p><pre><code>.font-size &#123;    font-size: 100px;&#125;</code></pre><br><strong><p>· px( 像素 )大小是我们网页的最常用的单位<tr><br>· 谷歌游览器默认的字体大小为16px</tr><tr><br>· 不同游览器可能默认显示的字体大小不一致，我们尽量给一个明确值大小，不要默认大小</tr><tr><br>· 我们该可以给body指定整个页面的大小:</tr></p><pre><code> body &#123;     font-size: 16px; &#125; &lt;!-- 标题标签比较特殊,需要单独指定文字大小 --&gt; h2 &#123;     font-size: 20px; &#125;</code></pre></strong><hr><p><br><br><br></p><h1 id="·-字体粗细"><a href="#·-字体粗细" class="headerlink" title="· 字体粗细"></a>· 字体粗细</h1><p>CSS 使用 font-weight 属性定义字体粗细<br>用法：</p><pre><code>.font-weight-bold &#123;    font-weight: bold;&#125;/* 实际开发中，提倡用数字 表示加粗或变细 */.font-weight &#123;    font-weight: 700;&#125;h2 &#123;    font-weight: 400;&#125;</code></pre><br><strong><p>· normal 默认值<tr><br>· bold 加粗</tr><tr><br>· number 100 ~ 900，其中normal等于400，bold等于700</tr><tr><br>· 学会让加粗标签不加粗，或其他标签加粗</tr></p></strong><hr><p><br><br><br></p><h1 id="·-文字样式"><a href="#·-文字样式" class="headerlink" title="· 文字样式"></a>· 文字样式</h1><p>CSS 使用 font-style 属性设置文本的风格<br>用法：</p><pre><code>.font-weight-bold &#123;    font-weight: bold;&#125;</code></pre><br><strong><p>· normal 默认值<tr><br>· bold 加粗</tr><tr><br>· number 100 ~ 900，其中normal等于400，bold等于700</tr><tr><br>· 学会让加粗标签不加粗，或其他标签加粗</tr></p></strong><hr><p><br><br><br></p><h1 id="·-字体复合属性"><a href="#·-字体复合属性" class="headerlink" title="· 字体复合属性"></a>· 字体复合属性</h1><p>CSS 使用 font-style 属性设置文本的风格<br>用法：</p><pre><code>.div &#123;    /* 复合属性：简写的方式 */    /* font: font-style font-weight font-size/line-height font-family */    font: italic 700 16px &quot;Microsoft YaHei&quot;&#125;</code></pre><br><strong><p>· 使用 font 属性时，必须按上面语法格式中的顺序书写，<font color="#FF0000">不能更换顺序</font>， 并且各个属性间以<font color="#FF0000">空格</font>隔开<tr><br>· 不需要设置的属性可以省略（取默认值），但<font color="#FF0000">必须保留 font-size 和 font-family 属性</font>否则 font 属性 将不起作用</tr><tr></tr></p></strong><hr><p><br><br><br></p><h1 id="·-总结"><a href="#·-总结" class="headerlink" title="· 总结"></a>· 总结</h1>   <table border="1" cellspacing="0">        <tr>            <th>                属性            </th>            <th>                表示            </th>            <th>                注意点            </th>        </tr>        <tr>            <td>font-size</td>            <td>字号</td>            <td>我们通常用的单位是px像素，一定要跟上单位</td>        </tr>        <tr>            <td>font-family</td>            <td>字体</td>            <td>实际工作中按照团队约定来写字体</td>        </tr>        <tr>            <td>font-weight</td>            <td>字体粗细</td>            <td>记住加粗是 700 或者 bold 不加粗 是 normal 或者 400 记住数字不跟单位</td>        </tr>        <tr>            <td>font-style</td>            <td>字体样式</td>            <td>记住倾斜是 italic ; 不倾斜是 normal ； 工作中我们最常用 normal</td>        </tr>        <tr>            <td>font</td>            <td>字体连写</td>            <td>1.字体连写是有顺序的 ; 不能随意换位置  2.其中字号 和 字体 必须同时出现</td>        </tr>    </table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML + CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础选择器</title>
      <link href="/2021/09/14/CSS-%E5%9F%BA%E7%A1%80%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2021/09/14/CSS-%E5%9F%BA%E7%A1%80%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>CSS-基础选择器-学习笔记<br>基础选择器分为 4 种：<br>    · 标签选择器<br>    · 类选择器<br>    · id选择器<br>    · 通配符选择器</p><hr><p><br><br><br></p><h1 id="·-标签选择器"><a href="#·-标签选择器" class="headerlink" title="· 标签选择器"></a>· 标签选择器</h1><p>作用：可以选出所有相同的标签，例如 p, h1, h2 ….<br>特点：不能差异化选择，一次性全部选中所选的标签<br>使用情况：较多<br>用法：</p><pre><code>&lt;head&gt;    &lt;style&gt;        /* 标签选择器 : 协商标签名 */        p &#123;            color: rgb(0, 255, 64);            /* 字体大小 */            font-size: 50px;            text-align: center;        &#125;        div &#123;            color: red;            font-size: 30px;            text-align: center;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;丛雨酱板载!&lt;/p&gt;    &lt;div&gt;芳乃芳乃 芳乃真香！&lt;/div&gt;&lt;/body&gt;</code></pre><hr><p><br><br></p><h1 id="·-类选择器"><a href="#·-类选择器" class="headerlink" title="· 类选择器"></a>· 类选择器</h1><p>作用：可以选出1个或多个标签<br>特点：可以根据需求选择<br>使用情况：非常多<br>用法：</p><pre><code>&lt;head&gt;    &lt;style&gt;        /* 类选择器口诀: 样式 点（.） 定义  结构 类（class）调用  一个或多个  开发最常用 */        /* 多类名用处统一格式 节省代码量 */        .box-wh-100px &#123;            width: 100px;            height: 100px;        &#125;        .red &#123;            color: red;        &#125;        .green &#123;            color: green;        &#125;        .font50 &#123;            font-size: 50px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;red font50&quot;&gt;丛雨酱!&lt;/div&gt;    &lt;div class=&quot;green&quot;&gt;芳乃酱!&lt;/div&gt;&lt;/body&gt;</code></pre><hr><p><br><br></p><h1 id="·-id选择器"><a href="#·-id选择器" class="headerlink" title="· id选择器"></a>· id选择器</h1><p>作用：一次只能选择1个标签<br>特点：ID属性只能在每个HTML文档中出现一次<br>使用情况：一般和 js 搭配<br>用法：</p><pre><code>&lt;head&gt;    &lt;style&gt;        /* id选择器的口诀:样式#定义，结构id调用，只能调用一次，其他不能使用-这是官方规定的-规范- */        #pink &#123;            color: green;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;pink&quot;&gt;丛雨&lt;/div&gt;    &lt;!-- 只能调用一次id选择器，因此下方id根据官方规定不能使用了 --&gt;    &lt;!-- &lt;div id=&quot;pink&quot;&gt;丛雨&lt;/div&gt;  --&gt;&lt;/body&gt;</code></pre><hr><p><br><br></p><h1 id="·-通配符选择器"><a href="#·-通配符选择器" class="headerlink" title="· 通配符选择器"></a>· 通配符选择器</h1><p>作用：选择所有的标签<br>特点：选择的太多，有部分不需要<br>使用情况：特殊情况使用（如全部灰色界面-以致默哀<br>用法：</p><pre><code>&lt;head&gt;    &lt;style&gt;        /* * 把 html body div span li 等等标签都改为了其规定的样式 */        /* 在特殊情况使用 */        * &#123;            color: red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;丛雨&lt;/div&gt;&lt;/body&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML + CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live2D处女作:风车子</title>
      <link href="/2021/09/13/Live2D%E5%A4%84%E5%A5%B3%E4%BD%9C-%E9%A3%8E%E8%BD%A6%E5%AD%90/"/>
      <url>/2021/09/13/Live2D%E5%A4%84%E5%A5%B3%E4%BD%9C-%E9%A3%8E%E8%BD%A6%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="角色介绍"><a href="#角色介绍" class="headerlink" title="角色介绍"></a>角色介绍</h1><p>我的第一个Live2D试水作。。（非美术专业的。。画渣轻喷</p><p>中文名：风车子<br>Name：Huusyako<br>Live2D模型师 &amp; 原画师：Panzer_Jack</p><hr><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>原画Pixiv:<a href="https://www.pixiv.net/artworks/92558011">https://www.pixiv.net/artworks/92558011</a><br>Live2D:<a href="https://steamcommunity.com/sharedfiles/filedetails/?id=2593842996">https://steamcommunity.com/sharedfiles/filedetails/?id=2593842996</a></p><hr><h3 id="工程展示图"><a href="#工程展示图" class="headerlink" title="工程展示图"></a>工程展示图</h3><p><img src="/2021/09/13/Live2D%E5%A4%84%E5%A5%B3%E4%BD%9C-%E9%A3%8E%E8%BD%A6%E5%AD%90/%E5%B7%A5%E7%A8%8B%E5%9B%BE.png"></p><hr><h3 id="原画展示图"><a href="#原画展示图" class="headerlink" title="原画展示图"></a>原画展示图</h3><p><img src="/2021/09/13/Live2D%E5%A4%84%E5%A5%B3%E4%BD%9C-%E9%A3%8E%E8%BD%A6%E5%AD%90/%E5%8E%9F%E7%94%BB.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 美术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Live2D + 原画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Panzer_Jack 的 个人博客成立日</title>
      <link href="/2021/09/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2021/09/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先感谢CSDN那些大佬的经验 以及yremp大神的技术博客。不仅成功建立此博客，也成功完成了第一个Target，在大一开学前拥有自己的独立个人博客。</p><hr><h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><p>本博客站点是由国际程序猿最大同性交流网站GitHub的 GitHub Page 搭建而成，其中又包含了 Hexo框架（Sakura), CDN技术, Git终端指令， Live2D技术（笑，当然是我自己画的模型）日常英语，等等（绝不是我忘了!</p><hr><h1 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h1><p>yremp大神的技术博客:<a href="https://yremp.live/hexo-sakura/">https://yremp.live/hexo-sakura/</a><br>Hexo指令：<a href="https://blog.csdn.net/Ivan_zcy/article/details/82916911?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163146075316780261955941%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163146075316780261955941&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-1-82916911.first_rank_v2_pc_rank_v29&amp;utm_term=hexo+s%E5%8D%9A%E5%AE%A2%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/Ivan_zcy/article/details/82916911?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163146075316780261955941%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163146075316780261955941&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-1-82916911.first_rank_v2_pc_rank_v29&amp;utm_term=hexo+s%E5%8D%9A%E5%AE%A2%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187</a><br>live2d 网页嵌入技术：<a href="https://blog.csdn.net/cungudafa/article/details/104282643?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexosakura%20live2d&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104282643.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/cungudafa/article/details/104282643?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexosakura%20live2d&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104282643.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187</a> （ 正在研究中ing ）<br>以及各种CSDN相关文献 等等。。</p>]]></content>
      
      
      <categories>
          
          <category> 更新日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 更新日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>占位</title>
      <link href="/1999/11/30/%E5%8D%A0%E5%BA%95/"/>
      <url>/1999/11/30/%E5%8D%A0%E5%BA%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Linux </category>
          
          <category> Python </category>
          
          <category> 后端 </category>
          
          <category> 项目 </category>
          
          <category> C/C++ </category>
          
          <category> 算法 </category>
          
          <category> Java </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 占底 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
